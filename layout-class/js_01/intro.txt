Введение в JS

0. История JS
- 1995г - самый популярный браузер Netscape Navigator,конкурент IE
(быстрее и только на винде). Netscape решил сделать скриптовый язык, 
который будет работать прямо в браузере. 
До этого были либо статичные HTML, либо динамические страницы, 
но которые создавались при помощи серверных технологий
Варианты
 - JAVA (оч популярен в то время)
 - Новый язык ( live script он же JavaScript)

 Через 2 недели первые результаты

 - 1996г появился IEv3 с поддержкой JS. Сделано с помощью обратного инжениринга. Не 1 в 1 Конечно
 Из-за этого сайты работали либо там либо там (IE и Netscape)

 Это проблема которая всем не нравилась
 Netscape решили язык стандартизировать. Этим занялась компания ECMA International (1996)
 Первая версия появилась в 1997
 версия 2 в 1998
 версия 3 в 1999
 версия 4 в 2000, но IE ушла и версия не взлетела

 Альтернативы языку небыло, делали быстро - в результате ошибки

 Netscape заменило Mozilla
 в 2004г появилось FF

 в 2005г придумали AJAX

 появился gmail - первое динамическое приложение
 JS был ключевым компонентом и поэтому стал так популярен
 
 2008г гугл выпустил новый движок v8 и основанный на нем браузер гугл хроме
 
 2009г - ECMAScript 5 - появился strict mode. 

 2015г - ECMAScript 6 - самое большое изменение за всю историю


1. Для чего JS
- простыми словами - чтобы "оживить" статичные html страницы

2. Общая информация

JS - является интерпритируемым языком программирования. 

Современный JavaScript – это «безопасный» язык программирования. 
Т е код запускается сверху вниз и результат запуска немедленно возвращается. 
Не нужно преобразовывать код в другую форму, 
перед запуском в браузере в отличии от компилируемого языка программирования.
JS не предоставляет низкоуровневый доступ к памяти или процессору, 
потому что изначально был создан для браузеров, не требующих этого.

Компилируемые языки преобразуются (компилируются) в другую форму, прежде чем они будут запущены компьютером. 
Например, C / C ++ компилируются в язык ассемблера, который затем запускается компьютером.

Языки можно различать на клиентский и серверный
Клиентский код — это код, который запускается на компьютере пользователя. 
При просмотре веб-страницы, клиентский код загружается, а затем запускается и отображается браузером.

Серверный код запускается на сервере, затем его результаты загружаются и отображаются в браузере. 
Примеры популярных серверных веб-языков включают PHP, Python, Ruby и ASP.NET. И JavaScript! 
JavaScript так же может использоваться, как серверный язык, например в популярной среде Node.js

Слово динамический используется для описания и клиентского JavaScript, 
и серверного языка — это относится к возможности обновления отображения веб-страницы/приложения, 
чтобы показывать разные вещи в разных обстоятельствах, генерируя новый контент по мере необходимости. 
Серверный код динамически генерирует новый контент на сервере, например достаёт данные из базы данных, 
тогда как клиентский JavaScript динамически генерирует новое содержание внутри браузера на клиенте, 
например создаёт новую HTML таблицу, вставляя в неё данные полученные с сервера, затем отображает таблицу на веб-странице, которую видит пользователь. 
В этих двух контекстах значение немного отличается, но связано, и обычно оба подхода (серверный и клиентский) работают вместе.

Веб-страница без динамического обновления контента называется статической — она просто показывает один и тот же контент все время.

3. Возиожности JS

Возможности JavaScript сильно зависят от окружения, в котором он работает. 
Например, Node.JS поддерживает функции чтения/записи произвольных файлов, выполнения сетевых запросов и т.д.

В браузере для JavaScript доступно всё, что связано с манипулированием веб-страницами, 
взаимодействием с пользователем и веб-сервером.

Например, в браузере JavaScript может:

- Добавлять новый HTML-код на страницу, изменять существующее содержимое, модифицировать стили.
- Реагировать на действия пользователя, щелчки мыши, перемещения указателя, нажатия клавиш.
- Отправлять сетевые запросы на удалённые сервера, скачивать и загружать файлы (технологии AJAX и COMET).
- Получать и устанавливать куки, задавать вопросы посетителю, показывать сообщения.
- Запоминать данные на стороне клиента («local storage»).

JS не может в браузере

Ограничения связанны с безопастностью

- JavaScript на веб-странице не может читать/записывать произвольные файлы на жёстком диске, 
копировать их или запускать программы. Он не имеет прямого доступа к системным функциям ОС.
Современные браузеры позволяют ему работать с файлами, но с ограниченным доступом, и предоставляют его, 
только если пользователь выполняет определённые действия, такие как «перетаскивание» файла в окно браузера или его выбор с помощью тега <input>.
Существуют способы взаимодействия с камерой/микрофоном и другими устройствами, 
но они требуют явного разрешения пользователя.

- Различные окна/вкладки не знают друг о друге. Иногда одно окно, используя JavaScript, открывает другое окно. 
Но даже в этом случае JavaScript с одной страницы не имеет доступа к другой, 
если они пришли с разных сайтов (с другого домена, протокола или порта).

- JavaScript может легко взаимодействовать с сервером, с которого пришла текущая страница. 
Но его способность получать данные с других сайтов/доменов ограничена. 
Хотя это возможно в принципе, для чего требуется явное согласие 
(выраженное в заголовках HTTP) с удалённой стороной. Опять же, это ограничение безопасности.

Подобные ограничения не действуют, если JavaScript используется вне браузера, например — на сервере.

4. Сильные стороны JS

- Полная интеграция с HTML/CSS.
- Простые вещи делаются просто.
- Поддерживается всеми основными браузерами и включён по умолчанию.

JavaScript – это единственная браузерная технология, сочетающая в себе все эти три вещи.

5. Имена переменных
В JavaScript есть два ограничения, касающиеся имён переменных:

Имя переменной должно содержать только буквы, цифры или символы $ и _.
Первый символ не должен быть цифрой.
Примеры допустимых имён:

let userName;
let test123;
Если имя содержит несколько слов, обычно используется верблюжья нотация, 
то есть, слова следуют одно за другим, 
где каждое следующее слово начинается с заглавной буквы: myVeryLongName.

Самое интересное – знак доллара '$' и подчёркивание '_' также можно использовать в названиях. Это обычные символы, как и буквы, без какого-либо особого значения.

Эти имена являются допустимыми:

let $ = 1; // объявили переменную с именем "$"
let _ = 2; // а теперь переменную с именем "_"

alert($ + _); // 3

Примеры неправильных имён переменных:
let 1a; // не может начинаться с цифры
let my-name; // дефис '-' не разрешён в имени

Регистр имеет значение
Переменные с именами apple и APPLE – это две разные переменные.

Нелатинские буквы разрешены, но не рекомендуются
Можно использовать любой язык, включая кириллицу или даже иероглифы, например:

let имя = '...';
let 我 = '...';
Технически здесь нет ошибки, такие имена разрешены, но есть международная традиция использовать английский язык в именах переменных. 
Даже если мы пишем небольшой скрипт, у него может быть долгая жизнь впереди. Людям из других стран, возможно, придётся прочесть его не один раз.

Зарезервированные имена
Существует список зарезервированных слов, которые нельзя использовать в качестве имён переменных, потому что они используются самим языком.

Например: let, class, return и function зарезервированы.

Приведённый ниже код даёт синтаксическую ошибку:

let let = 5; // нельзя назвать переменную "let", ошибка!
let return = 5; // также нельзя назвать переменную "return", ошибка!

Несколько хороших правил:

Используйте легко читаемые имена, такие как userName или shoppingCart.
Избегайте использования аббревиатур или коротких имён, таких как a, b, c, 
за исключением тех случаев, когда вы точно знаете, что так нужно.
Делайте имена максимально описательными и лаконичными. 
Примеры плохих имён: data и value. Такие имена ничего не говорят. 
Их можно использовать только в том случае, если из контекста кода очевидно, какие данные хранит переменная.
Договоритесь с вашей командой об используемых терминах. 
Если посетитель сайта называется «user», 
тогда мы должны называть связанные с ним переменные currentUser или newUser, а не, к примеру, currentVisitor или newManInTown.



6. Ответы на вопросы
- Что значит "JS слабо типизированный язык"?

JS - это язык программирования со слабой типизацией. 
Это означает, что в JavaScript переменные могут содержать значения разных типов данных, 
и их тип может изменяться во время выполнения программы.

Например, в JavaScript вы можете объявить переменную x и присвоить ей значение 10:

let x = 10;
Затем вы можете переназначить переменную x и присвоить ей строковое значение:

x = 'Hello, world!';
В других языках программирования, таких как Java или C#, 
вы должны объявить тип переменной и не можете изменять ее тип во время выполнения программы. 
В JavaScript же тип переменной определяется автоматически, в зависимости от значения, которое вы ей присваиваете.

- Что значит js язык с "динамической типизацией"?

Динами́ческая типиза́ция — приём, используемый в языках программирования и языках спецификации, 
при котором переменная связывается с типом в момент присваивания значения, 
а не в момент объявления переменной. 
Таким образом, в различных участках программы одна и та же переменная может принимать значения разных типов.

Динамическая типизация js — это важное свойство языка, 
которое позволяет переменным менять свой тип данных в процессе выполнения программы. 
Такое поведение отличает JS от некоторых других языков программирования, 
где тип переменной должен быть объявлен заранее и не может изменяться во время работы программы

- Какие типы значений есть в JS?
JS имеет 8 встроенных типов данных:
null --- let age = null;
undefined --- let age;
boolean --- let nameFieldChecked = true;  let isGreater = 4 > 1;
number --- let n = 123; // 123.5, e, Infinity, -Infinity, NaN.
string --- let message = "hello";
object --- не примитивный, для более сложных данных let myObject = { name: "Andrew", age: 100}
symbol --- для уникальных уникальных идендификаторов 
BigInt --- const bigInt = 1234567890123456789012345678901234567890n;

BigInt
В JavaScript тип number не может безопасно работать с числами, большими, чем (2^53-1) (т. е. 9007199254740991) 
или меньшими, чем -(2^53-1) для отрицательных чисел.

Если говорить совсем точно, то, технически, тип number может хранить 
большие целые числа (до 1.7976931348623157 * 10^308), 
но за пределами безопасного диапазона целых чисел ±(2^53-1) 
будет ошибка точности, так как не все цифры помещаются в фиксированную 64-битную память. 
Поэтому можно хранить «приблизительное» значение.

Например, эти два числа (прямо за пределами безопасного диапазона) совпадают:

console.log(9007199254740991 + 1); // 9007199254740992
console.log(9007199254740991 + 2); // 9007199254740992

То есть все нечетные целые числа, большие чем (2^53-1), вообще не могут храниться в типе number.
В большинстве случаев безопасного диапазона чисел от -(2^53-1) до (2^53-1) вполне достаточно, 
но иногда нам требуется весь диапазон действительно гигантских целых чисел без каких-либо 
ограничений или пропущенных значений внутри него. Например, в криптографии или при использовании метки времени («timestamp») с микросекундами.

Тип BigInt был добавлен в JavaScript, чтобы дать возможность работать с целыми числами произвольной длины.

Чтобы создать значение типа BigInt, необходимо добавить n в конец числового литерала:

// символ "n" в конце означает, что это BigInt
const bigInt = 1234567890123456789012345678901234567890n;

- Какой оператор позволяет определить тип значений в JS?

Оператор typeof

Оператор typeof возвращает тип аргумента. 
Это полезно, когда мы хотим обрабатывать значения различных типов по-разному или просто хотим сделать проверку.

У него есть две синтаксические формы:

// Обычный синтаксис
typeof 5 // Выведет "number"
// Синтаксис, напоминающий вызов функции (встречается реже)
typeof(5) // Также выведет "number"
Если передается выражение, то нужно заключать его в скобки, т.к. 
typeof имеет более высокий приоритет, чем бинарные операторы:

typeof 50 + " Квартир"; // Выведет "number Квартир"
typeof (50 + " Квартир"); // Выведет "string"

Другими словами, скобки необходимы для определения типа значения, 
которое получилось в результате выполнения выражения в них.

Вызов typeof x возвращает строку с именем типа:

typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)
Последние три строки нуждаются в пояснении:

Math — это встроенный объект, который предоставляет математические операции и константы. 

Результатом вызова typeof null является "object". Это официально признанная ошибка в typeof, 
ведущая начало с времён создания JavaScript и сохранённая для совместимости. 
Конечно, null не является объектом. Это специальное значение с отдельным типом.

Вызов typeof alert возвращает "function", потому что alert является функцией
В JavaScript нет специального типа «функция». 
Функции относятся к объектному типу. Но typeof обрабатывает их особым образом, возвращая "function". 
Так тоже повелось от создания JavaScript. Формально это неверно, но может быть удобным на практике.

- Что такое операнд и оператор?

В JavaScript оператор - это специальный символ, используемый для выполнения операций над операндами (значениями и переменными). 

Операнд – то, к чему применяется оператор. 
Например, в умножении 5 * 2 есть два операнда: левый операнд равен 5, а правый операнд равен 2. 
Иногда их называют «аргументами» вместо «операндов».

- Какие операторы есь в JS?

Типы операторов

Операторы присваивания (=, +=, -=, *=, /=, %=, **=)
Арифметические операторы (+, -, *, /, %, **, ++, --)
Операторы сравнения (==, !=, ===, !==, >, <, >=, <=)
Логические операторы (&&, ||, ||=, &&=, !, ??, ??=)
Побитовые операторы (&, \|, ^, ~, <<, >>, >>>)
Строковые операторы (конкатенация)
Другие операторы (,, ?:, delete typeof, void, in, instanceof)

Разделяют на унарные и бинарные


Унарным называется оператор, 
который применяется к одному операнду. 
Например, оператор унарный минус "-" меняет знак числа на противоположный:

let x = 1;

x = -x;
alert( x ); // -1, применили унарный минус

Бинарным называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:

let x = 1, y = 3;
alert( y - x ); // 2, бинарный минус вычитает значения

…	…	…
15	унарный плюс	+
15	унарный минус	-
14	возведение в степень	**
13	умножение	*
13	деление	/
12	сложение	+
12	вычитание	-
…	…	…
2	присваивание	=
…	…	…

- Как проверяются условия в JS?

Оператор ИЛИ -  ||
Оператор || выполняет следующие действия:
Вычисляет операнды слева направо.
Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда.
Если все операнды являются ложными (false), возвращает последний из них.

Оператор И -  &&
Оператор && выполняет следующие действия:
Вычисляет операнды слева направо.
Каждый операнд преобразует в логическое значение. Если результат false, останавливается и возвращает исходное значение этого операнда.
Если все операнды были истинными, возвращается последний.

Оператор ! - НЕ
Оператор принимает один аргумент и выполняет следующие действия:
Сначала приводит аргумент к логическому типу true/false.
Затем возвращает противоположное значение.


- Что такое истинные и ложные значения в JS?

Ложные значения - это такие значения в js, которые при преобразовании к логическому типу станут false
- 0 (ноль)
- "" (пустая строка)
- underfined (не присвоенное значение)
- null (отсутствие значения)
- NaN (ошибка математического вычисления)

Все остальное  - истинные значения

- Какие есть циклы в JS?

Цикл while

while (condition) {
  // код
  // также называемый "телом цикла"
} 

Код из тела цикла выполняется, пока условие condition истинно.

Например, цикл ниже выводит i, пока i < 3:

let i = 0;
while (i < 3) { // выводит 0, затем 1, затем 2
  alert( i );
  i++;
}
Одно выполнение тела цикла по-научному называется итерация. Цикл в примере выше совершает три итерации.

Цикл «do…while»
Проверку условия можно разместить под телом цикла, используя специальный синтаксис do..while:

do {
  // тело цикла
} while (condition);
Цикл сначала выполнит тело, а затем проверит условие condition, и пока его значение равно true, он будет выполняться снова и снова.

Например:

let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
Такая форма синтаксиса оправдана, если вы хотите, чтобы тело цикла выполнилось хотя бы один раз, 
даже если условие окажется ложным. На практике чаще используется форма с предусловием: while(…) {…}.


Цикл «for»
Более сложный, но при этом самый распространённый цикл — цикл for.

Выглядит он так:

for (начало; условие; шаг) {
  // ... тело цикла ...
}
Давайте разберёмся, что означает каждая часть, на примере. Цикл ниже выполняет alert(i) для i от 0 до (но не включая) 3:

for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
  alert(i);
}
Рассмотрим конструкцию for подробней:
		
начало	let i = 0	Выполняется один раз при входе в цикл
условие	i < 3	Проверяется перед каждой итерацией цикла.
Если оно вычислится в false, цикл остановится.
тело	alert(i)	Выполняется снова и снова, пока условие вычисляется в true.
шаг	i++	Выполняется после тела цикла на каждой итерации перед проверкой условия.

В целом, алгоритм работы цикла выглядит следующим образом:

Выполнить начало
→ (Если условие == true → Выполнить тело, Выполнить шаг)
→ (Если условие == true → Выполнить тело, Выполнить шаг)
→ (Если условие == true → Выполнить тело, Выполнить шаг)
→ ...
То есть, начало выполняется один раз, а затем каждая итерация заключается в проверке условия, после которой выполняется тело и шаг.

Если тема циклов для вас нова, может быть полезным вернуться к примеру выше и воспроизвести его работу на листе бумаги, шаг за шагом.

- Назовите команды git позволяющие работать с ветками?

Чтобы в Git добавить ветку мы используем:
git branch <name of new branch>

Чтобы переключиться на другую ветку
git checkout <name of branch>

Фиксация изменений в ветке
git add '<file name>'

Добавление комита в ветку
git commit -m '<information about commit>'

Проверка состояния изменений в ветке
git status

Отправить изменения на удаленный сервер 
git push

Подтянуть изменения с удаленного сервера
git pull

Переименовать ветку
git branch -m <new name of branch>

Удалить ветку
git branch -d <name of branch>

Посмотреть на журнал изменений
git log