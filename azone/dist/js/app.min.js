/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/smooth-scroll/dist/smooth-scroll.polyfills.min.js":
/*!************************************************************************!*\
  !*** ./node_modules/smooth-scroll/dist/smooth-scroll.polyfills.min.js ***!
  \************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! smooth-scroll v16.1.3 | (c) 2020 Chris Ferdinandi | MIT License | http://github.com/cferdinandi/smooth-scroll */\nwindow.Element&&!Element.prototype.closest&&(Element.prototype.closest=function(e){var t,n=(this.document||this.ownerDocument).querySelectorAll(e),o=this;do{for(t=n.length;0<=--t&&n.item(t)!==o;);}while(t<0&&(o=o.parentElement));return o}),(function(){if(\"function\"==typeof window.CustomEvent)return;function e(e,t){t=t||{bubbles:!1,cancelable:!1,detail:void 0};var n=document.createEvent(\"CustomEvent\");return n.initCustomEvent(e,t.bubbles,t.cancelable,t.detail),n}e.prototype=window.Event.prototype,window.CustomEvent=e})(),(function(){for(var r=0,e=[\"ms\",\"moz\",\"webkit\",\"o\"],t=0;t<e.length&&!window.requestAnimationFrame;++t)window.requestAnimationFrame=window[e[t]+\"RequestAnimationFrame\"],window.cancelAnimationFrame=window[e[t]+\"CancelAnimationFrame\"]||window[e[t]+\"CancelRequestAnimationFrame\"];window.requestAnimationFrame||(window.requestAnimationFrame=function(e,t){var n=(new Date).getTime(),o=Math.max(0,16-(n-r)),a=window.setTimeout((function(){e(n+o)}),o);return r=n+o,a}),window.cancelAnimationFrame||(window.cancelAnimationFrame=function(e){clearTimeout(e)})})(),(function(e,t){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){return t(e)}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):0})(\"undefined\"!=typeof __webpack_require__.g?__webpack_require__.g:\"undefined\"!=typeof window?window:this,(function(M){\"use strict\";var q={ignore:\"[data-scroll-ignore]\",header:null,topOnEmptyHash:!0,speed:500,speedAsDuration:!1,durationMax:null,durationMin:null,clip:!0,offset:0,easing:\"easeInOutCubic\",customEasing:null,updateURL:!0,popstate:!0,emitEvents:!0},I=function(){var n={};return Array.prototype.forEach.call(arguments,(function(e){for(var t in e){if(!e.hasOwnProperty(t))return;n[t]=e[t]}})),n},r=function(e){\"#\"===e.charAt(0)&&(e=e.substr(1));for(var t,n=String(e),o=n.length,a=-1,r=\"\",i=n.charCodeAt(0);++a<o;){if(0===(t=n.charCodeAt(a)))throw new InvalidCharacterError(\"Invalid character: the input contains U+0000.\");1<=t&&t<=31||127==t||0===a&&48<=t&&t<=57||1===a&&48<=t&&t<=57&&45===i?r+=\"\\\\\"+t.toString(16)+\" \":r+=128<=t||45===t||95===t||48<=t&&t<=57||65<=t&&t<=90||97<=t&&t<=122?n.charAt(a):\"\\\\\"+n.charAt(a)}return\"#\"+r},F=function(){return Math.max(document.body.scrollHeight,document.documentElement.scrollHeight,document.body.offsetHeight,document.documentElement.offsetHeight,document.body.clientHeight,document.documentElement.clientHeight)},L=function(e){return e?(t=e,parseInt(M.getComputedStyle(t).height,10)+e.offsetTop):0;var t},x=function(e,t,n){0===e&&document.body.focus(),n||(e.focus(),document.activeElement!==e&&(e.setAttribute(\"tabindex\",\"-1\"),e.focus(),e.style.outline=\"none\"),M.scrollTo(0,t))},H=function(e,t,n,o){if(t.emitEvents&&\"function\"==typeof M.CustomEvent){var a=new CustomEvent(e,{bubbles:!0,detail:{anchor:n,toggle:o}});document.dispatchEvent(a)}};return function(o,e){var b,a,A,O,C={};C.cancelScroll=function(e){cancelAnimationFrame(O),O=null,e||H(\"scrollCancel\",b)},C.animateScroll=function(a,r,e){C.cancelScroll();var i=I(b||q,e||{}),c=\"[object Number]\"===Object.prototype.toString.call(a),t=c||!a.tagName?null:a;if(c||t){var s=M.pageYOffset;i.header&&!A&&(A=document.querySelector(i.header));var n,o,u,l,m,d,f,h,p=L(A),g=c?a:(function(e,t,n,o){var a=0;if(e.offsetParent)for(;a+=e.offsetTop,e=e.offsetParent;);return a=Math.max(a-t-n,0),o&&(a=Math.min(a,F()-M.innerHeight)),a})(t,p,parseInt(\"function\"==typeof i.offset?i.offset(a,r):i.offset,10),i.clip),y=g-s,v=F(),w=0,S=(n=y,u=(o=i).speedAsDuration?o.speed:Math.abs(n/1e3*o.speed),o.durationMax&&u>o.durationMax?o.durationMax:o.durationMin&&u<o.durationMin?o.durationMin:parseInt(u,10)),E=function(e){var t,n,o;l||(l=e),w+=e-l,d=s+y*(n=m=1<(m=0===S?0:w/S)?1:m,\"easeInQuad\"===(t=i).easing&&(o=n*n),\"easeOutQuad\"===t.easing&&(o=n*(2-n)),\"easeInOutQuad\"===t.easing&&(o=n<.5?2*n*n:(4-2*n)*n-1),\"easeInCubic\"===t.easing&&(o=n*n*n),\"easeOutCubic\"===t.easing&&(o=--n*n*n+1),\"easeInOutCubic\"===t.easing&&(o=n<.5?4*n*n*n:(n-1)*(2*n-2)*(2*n-2)+1),\"easeInQuart\"===t.easing&&(o=n*n*n*n),\"easeOutQuart\"===t.easing&&(o=1- --n*n*n*n),\"easeInOutQuart\"===t.easing&&(o=n<.5?8*n*n*n*n:1-8*--n*n*n*n),\"easeInQuint\"===t.easing&&(o=n*n*n*n*n),\"easeOutQuint\"===t.easing&&(o=1+--n*n*n*n*n),\"easeInOutQuint\"===t.easing&&(o=n<.5?16*n*n*n*n*n:1+16*--n*n*n*n*n),t.customEasing&&(o=t.customEasing(n)),o||n),M.scrollTo(0,Math.floor(d)),(function(e,t){var n=M.pageYOffset;if(e==t||n==t||(s<t&&M.innerHeight+n)>=v)return C.cancelScroll(!0),x(a,t,c),H(\"scrollStop\",i,a,r),!(O=l=null)})(d,g)||(O=M.requestAnimationFrame(E),l=e)};0===M.pageYOffset&&M.scrollTo(0,0),f=a,h=i,c||history.pushState&&h.updateURL&&history.pushState({smoothScroll:JSON.stringify(h),anchor:f.id},document.title,f===document.documentElement?\"#top\":\"#\"+f.id),\"matchMedia\"in M&&M.matchMedia(\"(prefers-reduced-motion)\").matches?x(a,Math.floor(g),!1):(H(\"scrollStart\",i,a,r),C.cancelScroll(!0),M.requestAnimationFrame(E))}};var t=function(e){if(!e.defaultPrevented&&!(0!==e.button||e.metaKey||e.ctrlKey||e.shiftKey)&&\"closest\"in e.target&&(a=e.target.closest(o))&&\"a\"===a.tagName.toLowerCase()&&!e.target.closest(b.ignore)&&a.hostname===M.location.hostname&&a.pathname===M.location.pathname&&/#/.test(a.href)){var t,n;try{t=r(decodeURIComponent(a.hash))}catch(e){t=r(a.hash)}if(\"#\"===t){if(!b.topOnEmptyHash)return;n=document.documentElement}else n=document.querySelector(t);(n=n||\"#top\"!==t?n:document.documentElement)&&(e.preventDefault(),(function(e){if(history.replaceState&&e.updateURL&&!history.state){var t=M.location.hash;t=t||\"\",history.replaceState({smoothScroll:JSON.stringify(e),anchor:t||M.pageYOffset},document.title,t||M.location.href)}})(b),C.animateScroll(n,a))}},n=function(e){if(null!==history.state&&history.state.smoothScroll&&history.state.smoothScroll===JSON.stringify(b)){var t=history.state.anchor;\"string\"==typeof t&&t&&!(t=document.querySelector(r(history.state.anchor)))||C.animateScroll(t,null,{updateURL:!1})}};C.destroy=function(){b&&(document.removeEventListener(\"click\",t,!1),M.removeEventListener(\"popstate\",n,!1),C.cancelScroll(),O=A=a=b=null)};return (function(){if(!(\"querySelector\"in document&&\"addEventListener\"in M&&\"requestAnimationFrame\"in M&&\"closest\"in M.Element.prototype))throw\"Smooth Scroll: This browser does not support the required JavaScript methods and browser APIs.\";C.destroy(),b=I(q,e||{}),A=b.header?document.querySelector(b.header):null,document.addEventListener(\"click\",t,!1),b.updateURL&&b.popstate&&M.addEventListener(\"popstate\",n,!1)})(),C}}));\n\n//# sourceURL=webpack://gulp-2022/./node_modules/smooth-scroll/dist/smooth-scroll.polyfills.min.js?");

/***/ }),

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _files_functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./files/functions.js */ \"./src/js/files/functions.js\");\n/* harmony import */ var _libs_popup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/popup.js */ \"./src/js/libs/popup.js\");\n/* harmony import */ var _files_sliders_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./files/sliders.js */ \"./src/js/files/sliders.js\");\n/* harmony import */ var _files_scroll_scroll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./files/scroll/scroll.js */ \"./src/js/files/scroll/scroll.js\");\n/* harmony import */ var _libs_dynamic_adapt_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./libs/dynamic_adapt.js */ \"./src/js/libs/dynamic_adapt.js\");\n/* harmony import */ var _files_script_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./files/script.js */ \"./src/js/files/script.js\");\n/*\n(i) Код попадает в итоговый файл,\nтолько когда вызвана функция,\nнапример flsFunctions.spollers();\nИли когда импортирован весь файл,\n// например import \"files/script.js\";\nНеиспользуемый (не вызванный)\nкод в итоговый файл не попадает.\n\nЕсли мы хотим добавить модуль\nследует его расскоментировать\n*/\n\n// Включить/выключить FLS (Full Logging System) (в работе)\nwindow['FLS'] = true;\n\n// Подключение основного файла стилей\n// import \"../scss/style.scss\";\n\n// ========================================================================================================================================================================================================================================================\n// Функционал ========================================================================================================================================================================================================================================================\n// ========================================================================================================================================================================================================================================================\n\n\n/* Проверка поддержки webp, добавление класса webp или no-webp для HTML */\n/* (i) необходимо для корректного отображения webp из css  */\n// flsFunctions.isWebp();\n/* Добавление класса touch для HTML если браузер мобильный */\n// flsFunctions.addTouchClass();\n/* Добавление loaded для HTML после полной загрузки страницы */\n// flsFunctions.addLoadedClass();\n/* Модуль для работы с меню (Бургер) */\n// flsFunctions.menuInit();\n/* Учет плавающей панели на мобильных устройствах при 100vh */\n// flsFunctions.fullVHfix();\n\n/*\nМодуль работы со спойлерами\nДокументация: https://template.fls.guru/template-docs/modul-spojlery.html\nСниппет (HTML): spollers\n*/\n// flsFunctions.spollers();\n\n/*\nМодуль работы с табами\nДокументация: https://template.fls.guru/template-docs/modul-taby.html\nСниппет (HTML): tabs\n*/\n_files_functions_js__WEBPACK_IMPORTED_MODULE_0__.tabs();\n\n/*\nМодуль \"показать еще\"\nДокументация: https://template.fls.guru/template-docs/modul-pokazat-eshhjo.html\nСниппет (HTML): showmore\n*/\n// flsFunctions.showMore();\n\n/*\nПопапы\nДокументация: https://template.fls.guru/template-docs/funkcional-popup.html\nСниппет (HTML): pl\n*/\n\n\n/*\nМодуль параллакса мышью\nДокументация: \nСниппет (HTML): \n*/\n// import './libs/parallax-mouse.js'\n\n// ========================================================================================================================================================================================================================================================\n// Работа с формами ========================================================================================================================================================================================================================================================\n// ========================================================================================================================================================================================================================================================\n// import * as flsForms from \"./files/forms/forms.js\";\n\n/* Работа с полями формы */\n/* Документация: https://template.fls.guru/template-docs/rabota-s-formami.html */\n// flsForms.formFieldsInit({ viewPass: false });\n\n/* Oтправка формы */\n/* Документация: https://template.fls.guru/template-docs/rabota-s-formami.html */\n// flsForms.formSubmit();\n\n/* Модуль формы \"колличество\" */\n// flsForms.formQuantity();\n\n/* Модуль звездного рейтинга */\n// flsForms.formRating();\n\n/* Модуль работы с select. */\n// import './libs/select.js'\n\n/* (В работе) Модуль работы с масками.*/\n/*\nПодключение и настройка выполняется в файле js/files/forms/inputmask.js\nДокументация по работе в шаблоне:\nДокументация плагина: https://github.com/RobinHerbots/inputmask\nСниппет(HTML):\n*/\n// import \"./files/forms/inputmask.js\";\n\n/* Модуль работы с ползунком */\n/*\nПодключение и настройка выполняется в файле js/files/forms/range.js\nДокументация по работе в шаблоне:\nДокументация плагина: https://refreshless.com/nouislider/\nСниппет (HTML): range\n*/\n// import \"./files/forms/range.js\";\n\n/* Модуль работы с подсказками (tippy) */\n/*\nПодключение плагина Tippy.js и настройка выполняется в файле js/files/tippy.js\nДокументация по работе в шаблоне:\nДокументация плагина: https://atomiks.github.io/tippyjs/\nСниппет (HTML): tip (добавляет атрибут с подсказкой для html тега)\n*/\n// import \"./files/tippy.js\";\n\n// ========================================================================================================================================================================================================================================================\n// Работа со слайдером (Swiper) ========================================================================================================================================================================================================================================================\n// ========================================================================================================================================================================================================================================================\n/*\nНастройка подключения плагина слайдера Swiper и новых слайдеров выполняется в файле js/files/sliders.js\nДокументация по работе в шаблоне: https://template.fls.guru/template-docs/rabota-so-slajderom-swiper.html\nДокументация плагина: https://swiperjs.com/\nСниппет(HTML): swiper\n*/\n\n\n// ========================================================================================================================================================================================================================================================\n// Модули работы с прокруткой страницы ========================================================================================================================================================================================================================================================\n// ========================================================================================================================================================================================================================================================\n\n/*\nИзменение дизайна скроллбара\nДокументация по работе в шаблоне: В HTML добавляем к блоку атрибут data-simplebar\nДокументация плагина: https://github.com/Grsmto/simplebar/tree/master/packages/simplebar\nСниппет(HTML): \n*/\n// import './files/scroll/simplebar.js';\n\n// Ленивая (отложенная) загрузка картинок\n// Документация по работе в шаблоне: https://template.fls.guru/template-docs/modul-lenivaya-podgruzka-lazy-loading.html\n// Документация плагина: https://github.com/verlok/vanilla-lazyload\n// Сниппет(HTML):\n// import './files/scroll/lazyload.js';\n\n// Наблюдатель за объектами c атрибутом data-watch\n// Документация: https://template.fls.guru/template-docs/modul-nabljudatel-za-poyavleniem-elementa-pri-skrolle.html\n// Сниппет(HTML):\n// import './libs/watcher.js'\n\n// Функции работы скроллом\n\n\n// Плавная навигация по странице\n// Документация: https://template.fls.guru/template-docs/modul-plavnoj-navigacii-po-stranice.html\n_files_scroll_scroll_js__WEBPACK_IMPORTED_MODULE_3__.pageNavigation();\n\n// Функционал добавления классов к хедеру при прокрутке\n// Документация: https://template.fls.guru/template-docs/modul-dobavleniya-klassov-k-shapke-pri-prokrutke-stranicy.html\n_files_scroll_scroll_js__WEBPACK_IMPORTED_MODULE_3__.headerScroll();\n\n// Функционал липкого блока\n// flsScroll.stickyBlock();\n\n// ========================================================================================================================================================================================================================================================\n// Галерея ========================================================================================================================================================================================================================================================\n// ========================================================================================================================================================================================================================================================\n/*\nДокументация по работе в шаблоне: \nДокументация плагина: https://www.lightgalleryjs.com/docs/\nСниппет(HTML):\n*/\n// import \"./files/gallery.js\";\n\n// ========================================================================================================================================================================================================================================================\n// Прочие плагины ============================================================================================================================================================================================================================================================================================================\n// ========================================================================================================================================================================================================================================================\n\n/* Динамический адаптив */\n// Документация: https://template.fls.guru/template-docs/dinamicheskij-adaptiv.html\n\n\n/* Форматирование чисел */\n// import './libs/wNumb.min.js';\n\n// ========================================================================================================================================================================================================================================================\n// Прочее ========================================================================================================================================================================================================================================================\n// ========================================================================================================================================================================================================================================================\n/* Подключаем файлы со своим кодом */\n// import \"./files/map.js\";\n\n//============================================================================================================================================================================================================================================\n\n//# sourceURL=webpack://gulp-2022/./src/js/app.js?");

/***/ }),

/***/ "./src/js/files/functions.js":
/*!***********************************!*\
  !*** ./src/js/files/functions.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FLS\": () => (/* binding */ FLS),\n/* harmony export */   \"_slideDown\": () => (/* binding */ _slideDown),\n/* harmony export */   \"_slideToggle\": () => (/* binding */ _slideToggle),\n/* harmony export */   \"_slideUp\": () => (/* binding */ _slideUp),\n/* harmony export */   \"addLoadedClass\": () => (/* binding */ addLoadedClass),\n/* harmony export */   \"addTouchClass\": () => (/* binding */ addTouchClass),\n/* harmony export */   \"bodyLock\": () => (/* binding */ bodyLock),\n/* harmony export */   \"bodyLockStatus\": () => (/* binding */ bodyLockStatus),\n/* harmony export */   \"bodyLockToggle\": () => (/* binding */ bodyLockToggle),\n/* harmony export */   \"bodyUnlock\": () => (/* binding */ bodyUnlock),\n/* harmony export */   \"dataMediaQueries\": () => (/* binding */ dataMediaQueries),\n/* harmony export */   \"fullVHfix\": () => (/* binding */ fullVHfix),\n/* harmony export */   \"getDigFormat\": () => (/* binding */ getDigFormat),\n/* harmony export */   \"getDigFromString\": () => (/* binding */ getDigFromString),\n/* harmony export */   \"getHash\": () => (/* binding */ getHash),\n/* harmony export */   \"indexInParent\": () => (/* binding */ indexInParent),\n/* harmony export */   \"isMobile\": () => (/* binding */ isMobile),\n/* harmony export */   \"isWebp\": () => (/* binding */ isWebp),\n/* harmony export */   \"menuClose\": () => (/* binding */ menuClose),\n/* harmony export */   \"menuInit\": () => (/* binding */ menuInit),\n/* harmony export */   \"menuOpen\": () => (/* binding */ menuOpen),\n/* harmony export */   \"removeClasses\": () => (/* binding */ removeClasses),\n/* harmony export */   \"setHash\": () => (/* binding */ setHash),\n/* harmony export */   \"showMore\": () => (/* binding */ showMore),\n/* harmony export */   \"spollers\": () => (/* binding */ spollers),\n/* harmony export */   \"tabs\": () => (/* binding */ tabs),\n/* harmony export */   \"uniqArray\": () => (/* binding */ uniqArray)\n/* harmony export */ });\n/* harmony import */ var _modules_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules.js */ \"./src/js/files/modules.js\");\n// Подключение списка активных модулей\n\n\n/* Проверка поддержки webp, добавление класса webp или no-webp для HTML */\nfunction isWebp() {\n\t// Проверка поддержки webp\n\tfunction testWebP(callback) {\n\t\tlet webP = new Image();\n\t\twebP.onload = webP.onerror = function () {\n\t\t\tcallback(webP.height == 2);\n\t\t};\n\t\twebP.src = \"data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA\";\n\t}\n\t// Добавление класса _webp или _no-webp для HTML\n\ttestWebP(function (support) {\n\t\tlet className = support === true ? 'webp' : 'no-webp';\n\t\tdocument.documentElement.classList.add(className);\n\t});\n}\n/* Проверка мобильного браузера */\nlet isMobile = {\n\tAndroid: function () {\n\t\treturn navigator.userAgent.match(/Android/i);\n\t},\n\tBlackBerry: function () {\n\t\treturn navigator.userAgent.match(/BlackBerry/i);\n\t},\n\tiOS: function () {\n\t\treturn navigator.userAgent.match(/iPhone|iPad|iPod/i);\n\t},\n\tOpera: function () {\n\t\treturn navigator.userAgent.match(/Opera Mini/i);\n\t},\n\tWindows: function () {\n\t\treturn navigator.userAgent.match(/IEMobile/i);\n\t},\n\tany: function () {\n\t\treturn (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows());\n\t}\n};\n/* Добавление класса touch для HTML если браузер мобильный */\nfunction addTouchClass() {\n\t// Добавление класса _touch для HTML если браузер мобильный\n\tif (isMobile.any()) document.documentElement.classList.add('touch');\n}\n// Добавление loaded для HTML после полной загрузки страницы\nfunction addLoadedClass() {\n\twindow.addEventListener(\"load\", function () {\n\t\tsetTimeout(function () {\n\t\t\tdocument.documentElement.classList.add('loaded');\n\t\t}, 0);\n\t});\n}\n// Получение хеша в адресе сайта\nfunction getHash() {\n\tif (location.hash) {\n\t\treturn location.hash.replace('#', '');\n\t}\n}\n// Указание хеша в адресе сайта\nfunction setHash(hash) {\n\thash = hash ? `#${hash}` : window.location.href.split('#')[0];\n\thistory.pushState('', '', hash);\n}\n// Учет плавающей панели на мобильных устройствах при 100vh\nfunction fullVHfix() {\n\tconst fullScreens = document.querySelectorAll('[data-fullscreen]');\n\tif (fullScreens.length && isMobile.any()) {\n\t\twindow.addEventListener('resize', fixHeight);\n\n\t\tfunction fixHeight() {\n\t\t\tlet vh = window.innerHeight * 0.01;\n\t\t\tdocument.documentElement.style.setProperty('--vh', `${vh}px`);\n\t\t}\n\t\tfixHeight();\n\t}\n}\n// Вспомогательные модули плавного расскрытия и закрытия объекта ======================================================================================================================================================================\nlet _slideUp = (target, duration = 500, showmore = 0) => {\n\tif (!target.classList.contains('_slide')) {\n\t\ttarget.classList.add('_slide');\n\t\ttarget.style.transitionProperty = 'height, margin, padding';\n\t\ttarget.style.transitionDuration = duration + 'ms';\n\t\ttarget.style.height = `${target.offsetHeight}px`;\n\t\ttarget.offsetHeight;\n\t\ttarget.style.overflow = 'hidden';\n\t\ttarget.style.height = showmore ? `${showmore}px` : `0px`;\n\t\ttarget.style.paddingTop = 0;\n\t\ttarget.style.paddingBottom = 0;\n\t\ttarget.style.marginTop = 0;\n\t\ttarget.style.marginBottom = 0;\n\t\twindow.setTimeout(() => {\n\t\t\ttarget.hidden = !showmore ? true : false;\n\t\t\t!showmore ? target.style.removeProperty('height') : null;\n\t\t\ttarget.style.removeProperty('padding-top');\n\t\t\ttarget.style.removeProperty('padding-bottom');\n\t\t\ttarget.style.removeProperty('margin-top');\n\t\t\ttarget.style.removeProperty('margin-bottom');\n\t\t\t!showmore ? target.style.removeProperty('overflow') : null;\n\t\t\ttarget.style.removeProperty('transition-duration');\n\t\t\ttarget.style.removeProperty('transition-property');\n\t\t\ttarget.classList.remove('_slide');\n\t\t\t// Создаем событие \n\t\t\tdocument.dispatchEvent(new CustomEvent(\"slideUpDone\", {\n\t\t\t\tdetail: {\n\t\t\t\t\ttarget: target\n\t\t\t\t}\n\t\t\t}));\n\t\t}, duration);\n\t}\n}\nlet _slideDown = (target, duration = 500, showmore = 0) => {\n\tif (!target.classList.contains('_slide')) {\n\t\ttarget.classList.add('_slide');\n\t\ttarget.hidden = target.hidden ? false : null;\n\t\tshowmore ? target.style.removeProperty('height') : null;\n\t\tlet height = target.offsetHeight;\n\t\ttarget.style.overflow = 'hidden';\n\t\ttarget.style.height = showmore ? `${showmore}px` : `0px`;\n\t\ttarget.style.paddingTop = 0;\n\t\ttarget.style.paddingBottom = 0;\n\t\ttarget.style.marginTop = 0;\n\t\ttarget.style.marginBottom = 0;\n\t\ttarget.offsetHeight;\n\t\ttarget.style.transitionProperty = \"height, margin, padding\";\n\t\ttarget.style.transitionDuration = duration + 'ms';\n\t\ttarget.style.height = height + 'px';\n\t\ttarget.style.removeProperty('padding-top');\n\t\ttarget.style.removeProperty('padding-bottom');\n\t\ttarget.style.removeProperty('margin-top');\n\t\ttarget.style.removeProperty('margin-bottom');\n\t\twindow.setTimeout(() => {\n\t\t\ttarget.style.removeProperty('height');\n\t\t\ttarget.style.removeProperty('overflow');\n\t\t\ttarget.style.removeProperty('transition-duration');\n\t\t\ttarget.style.removeProperty('transition-property');\n\t\t\ttarget.classList.remove('_slide');\n\t\t\t// Создаем событие \n\t\t\tdocument.dispatchEvent(new CustomEvent(\"slideDownDone\", {\n\t\t\t\tdetail: {\n\t\t\t\t\ttarget: target\n\t\t\t\t}\n\t\t\t}));\n\t\t}, duration);\n\t}\n}\nlet _slideToggle = (target, duration = 500) => {\n\tif (target.hidden) {\n\t\treturn _slideDown(target, duration);\n\t} else {\n\t\treturn _slideUp(target, duration);\n\t}\n}\n// Вспомогательные модули блокировки прокрутки и скочка ====================================================================================================================================================================================================================================================================================\nlet bodyLockStatus = true;\nlet bodyLockToggle = (delay = 500) => {\n\tif (document.documentElement.classList.contains('lock')) {\n\t\tbodyUnlock(delay);\n\t} else {\n\t\tbodyLock(delay);\n\t}\n}\nlet bodyUnlock = (delay = 500) => {\n\tlet body = document.querySelector(\"body\");\n\tif (bodyLockStatus) {\n\t\tlet lock_padding = document.querySelectorAll(\"[data-lp]\");\n\t\tsetTimeout(() => {\n\t\t\tfor (let index = 0; index < lock_padding.length; index++) {\n\t\t\t\tconst el = lock_padding[index];\n\t\t\t\tel.style.paddingRight = '0px';\n\t\t\t}\n\t\t\tbody.style.paddingRight = '0px';\n\t\t\tdocument.documentElement.classList.remove(\"lock\");\n\t\t}, delay);\n\t\tbodyLockStatus = false;\n\t\tsetTimeout(function () {\n\t\t\tbodyLockStatus = true;\n\t\t}, delay);\n\t}\n}\nlet bodyLock = (delay = 500) => {\n\tlet body = document.querySelector(\"body\");\n\tif (bodyLockStatus) {\n\t\tlet lock_padding = document.querySelectorAll(\"[data-lp]\");\n\t\tfor (let index = 0; index < lock_padding.length; index++) {\n\t\t\tconst el = lock_padding[index];\n\t\t\tel.style.paddingRight = window.innerWidth - document.querySelector('.wrapper').offsetWidth + 'px';\n\t\t}\n\t\tbody.style.paddingRight = window.innerWidth - document.querySelector('.wrapper').offsetWidth + 'px';\n\t\tdocument.documentElement.classList.add(\"lock\");\n\n\t\tbodyLockStatus = false;\n\t\tsetTimeout(function () {\n\t\t\tbodyLockStatus = true;\n\t\t}, delay);\n\t}\n}\n// Модуль работы со спойлерами =======================================================================================================================================================================================================================\n/*\nДокументация по работе в шаблоне: https://template.fls.guru/template-docs/modul-spojlery.html\nСниппет (HTML): spollers\n*/\nfunction spollers() {\n\tconst spollersArray = document.querySelectorAll('[data-spollers]');\n\tif (spollersArray.length > 0) {\n\t\t// Получение обычных слойлеров\n\t\tconst spollersRegular = Array.from(spollersArray).filter(function (item, index, self) {\n\t\t\treturn !item.dataset.spollers.split(\",\")[0];\n\t\t});\n\t\t// Инициализация обычных слойлеров\n\t\tif (spollersRegular.length) {\n\t\t\tinitSpollers(spollersRegular);\n\t\t}\n\t\t// Получение слойлеров с медиа запросами\n\t\tlet mdQueriesArray = dataMediaQueries(spollersArray, \"spollers\");\n\t\tif (mdQueriesArray && mdQueriesArray.length) {\n\t\t\tmdQueriesArray.forEach(mdQueriesItem => {\n\t\t\t\t// Событие\n\t\t\t\tmdQueriesItem.matchMedia.addEventListener(\"change\", function () {\n\t\t\t\t\tinitSpollers(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);\n\t\t\t\t});\n\t\t\t\tinitSpollers(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);\n\t\t\t});\n\t\t}\n\t\t// Инициализация\n\t\tfunction initSpollers(spollersArray, matchMedia = false) {\n\t\t\tspollersArray.forEach(spollersBlock => {\n\t\t\t\tspollersBlock = matchMedia ? spollersBlock.item : spollersBlock;\n\t\t\t\tif (matchMedia.matches || !matchMedia) {\n\t\t\t\t\tspollersBlock.classList.add('_spoller-init');\n\t\t\t\t\tinitSpollerBody(spollersBlock);\n\t\t\t\t\tspollersBlock.addEventListener(\"click\", setSpollerAction);\n\t\t\t\t} else {\n\t\t\t\t\tspollersBlock.classList.remove('_spoller-init');\n\t\t\t\t\tinitSpollerBody(spollersBlock, false);\n\t\t\t\t\tspollersBlock.removeEventListener(\"click\", setSpollerAction);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t// Работа с контентом\n\t\tfunction initSpollerBody(spollersBlock, hideSpollerBody = true) {\n\t\t\tlet spollerTitles = spollersBlock.querySelectorAll('[data-spoller]');\n\t\t\tif (spollerTitles.length) {\n\t\t\t\tspollerTitles = Array.from(spollerTitles).filter(item => item.closest('[data-spollers]') === spollersBlock);\n\t\t\t\tspollerTitles.forEach(spollerTitle => {\n\t\t\t\t\tif (hideSpollerBody) {\n\t\t\t\t\t\tspollerTitle.removeAttribute('tabindex');\n\t\t\t\t\t\tif (!spollerTitle.classList.contains('_spoller-active')) {\n\t\t\t\t\t\t\tspollerTitle.nextElementSibling.hidden = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tspollerTitle.setAttribute('tabindex', '-1');\n\t\t\t\t\t\tspollerTitle.nextElementSibling.hidden = false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfunction setSpollerAction(e) {\n\t\t\tconst el = e.target;\n\t\t\tif (el.closest('[data-spoller]')) {\n\t\t\t\tconst spollerTitle = el.closest('[data-spoller]');\n\t\t\t\tconst spollersBlock = spollerTitle.closest('[data-spollers]');\n\t\t\t\tconst oneSpoller = spollersBlock.hasAttribute('data-one-spoller');\n\t\t\t\tconst spollerSpeed = spollersBlock.dataset.spollersSpeed ? parseInt(spollersBlock.dataset.spollersSpeed) : 500;\n\t\t\t\tif (!spollersBlock.querySelectorAll('._slide').length) {\n\t\t\t\t\tif (oneSpoller && !spollerTitle.classList.contains('_spoller-active')) {\n\t\t\t\t\t\thideSpollersBody(spollersBlock);\n\t\t\t\t\t}\n\t\t\t\t\tspollerTitle.classList.toggle('_spoller-active');\n\t\t\t\t\t_slideToggle(spollerTitle.nextElementSibling, spollerSpeed);\n\t\t\t\t}\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t}\n\n\t\tfunction hideSpollersBody(spollersBlock) {\n\t\t\tconst spollerActiveTitle = spollersBlock.querySelector('[data-spoller]._spoller-active');\n\t\t\tconst spollerSpeed = spollersBlock.dataset.spollersSpeed ? parseInt(spollersBlock.dataset.spollersSpeed) : 500;\n\t\t\tif (spollerActiveTitle && !spollersBlock.querySelectorAll('._slide').length) {\n\t\t\t\tspollerActiveTitle.classList.remove('_spoller-active');\n\t\t\t\t_slideUp(spollerActiveTitle.nextElementSibling, spollerSpeed);\n\t\t\t}\n\t\t}\n\t\t// Закрытие при клике вне спойлера\n\t\tconst spollersClose = document.querySelectorAll('[data-spoller-close]');\n\t\tif (spollersClose.length) {\n\t\t\tdocument.addEventListener(\"click\", function (e) {\n\t\t\t\tconst el = e.target;\n\t\t\t\tif (!el.closest('[data-spollers]')) {\n\t\t\t\t\tspollersClose.forEach(spollerClose => {\n\t\t\t\t\t\tconst spollersBlock = spollerClose.closest('[data-spollers]');\n\t\t\t\t\t\tconst spollerSpeed = spollersBlock.dataset.spollersSpeed ? parseInt(spollersBlock.dataset.spollersSpeed) : 500;\n\t\t\t\t\t\tspollerClose.classList.remove('_spoller-active');\n\t\t\t\t\t\t_slideUp(spollerClose.nextElementSibling, spollerSpeed);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n// Модуь работы с табами =======================================================================================================================================================================================================================\n/*\nДокументация по работе в шаблоне: https://template.fls.guru/template-docs/modul-taby.html\nСниппет (HTML): tabs\n*/\nfunction tabs() {\n\tconst tabs = document.querySelectorAll('[data-tabs]');\n\tlet tabsActiveHash = [];\n\n\tif (tabs.length > 0) {\n\t\tconst hash = getHash();\n\t\tif (hash && hash.startsWith('tab-')) {\n\t\t\ttabsActiveHash = hash.replace('tab-', '').split('-');\n\t\t}\n\t\ttabs.forEach((tabsBlock, index) => {\n\t\t\ttabsBlock.classList.add('_tab-init');\n\t\t\ttabsBlock.setAttribute('data-tabs-index', index);\n\t\t\ttabsBlock.addEventListener(\"click\", setTabsAction);\n\t\t\tinitTabs(tabsBlock);\n\t\t});\n\n\t\t// Получение слойлеров с медиа запросами\n\t\tlet mdQueriesArray = dataMediaQueries(tabs, \"tabs\");\n\t\tif (mdQueriesArray && mdQueriesArray.length) {\n\t\t\tmdQueriesArray.forEach(mdQueriesItem => {\n\t\t\t\t// Событие\n\t\t\t\tmdQueriesItem.matchMedia.addEventListener(\"change\", function () {\n\t\t\t\t\tsetTitlePosition(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);\n\t\t\t\t});\n\t\t\t\tsetTitlePosition(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);\n\t\t\t});\n\t\t}\n\t}\n\t// Установка позиций заголовков\n\tfunction setTitlePosition(tabsMediaArray, matchMedia) {\n\t\ttabsMediaArray.forEach(tabsMediaItem => {\n\t\t\ttabsMediaItem = tabsMediaItem.item;\n\t\t\tlet tabsTitles = tabsMediaItem.querySelector('[data-tabs-titles]');\n\t\t\tlet tabsTitleItems = tabsMediaItem.querySelectorAll('[data-tabs-title]');\n\t\t\tlet tabsContent = tabsMediaItem.querySelector('[data-tabs-body]');\n\t\t\tlet tabsContentItems = tabsMediaItem.querySelectorAll('[data-tabs-item]');\n\t\t\ttabsTitleItems = Array.from(tabsTitleItems).filter(item => item.closest('[data-tabs]') === tabsMediaItem);\n\t\t\ttabsContentItems = Array.from(tabsContentItems).filter(item => item.closest('[data-tabs]') === tabsMediaItem);\n\t\t\ttabsContentItems.forEach((tabsContentItem, index) => {\n\t\t\t\tif (matchMedia.matches) {\n\t\t\t\t\ttabsContent.append(tabsTitleItems[index]);\n\t\t\t\t\ttabsContent.append(tabsContentItem);\n\t\t\t\t\ttabsMediaItem.classList.add('_tab-spoller');\n\t\t\t\t} else {\n\t\t\t\t\ttabsTitles.append(tabsTitleItems[index]);\n\t\t\t\t\ttabsMediaItem.classList.remove('_tab-spoller');\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\t// Работа с контентом\n\tfunction initTabs(tabsBlock) {\n\t\tlet tabsTitles = tabsBlock.querySelectorAll('[data-tabs-titles]>*');\n\t\tlet tabsContent = tabsBlock.querySelectorAll('[data-tabs-body]>*');\n\t\tconst tabsBlockIndex = tabsBlock.dataset.tabsIndex;\n\t\tconst tabsActiveHashBlock = tabsActiveHash[0] == tabsBlockIndex;\n\n\t\tif (tabsActiveHashBlock) {\n\t\t\tconst tabsActiveTitle = tabsBlock.querySelector('[data-tabs-titles]>._tab-active');\n\t\t\ttabsActiveTitle ? tabsActiveTitle.classList.remove('_tab-active') : null;\n\t\t}\n\t\tif (tabsContent.length) {\n\t\t\ttabsContent = Array.from(tabsContent).filter(item => item.closest('[data-tabs]') === tabsBlock);\n\t\t\ttabsTitles = Array.from(tabsTitles).filter(item => item.closest('[data-tabs]') === tabsBlock);\n\t\t\ttabsContent.forEach((tabsContentItem, index) => {\n\t\t\t\ttabsTitles[index].setAttribute('data-tabs-title', '');\n\t\t\t\ttabsContentItem.setAttribute('data-tabs-item', '');\n\n\t\t\t\tif (tabsActiveHashBlock && index == tabsActiveHash[1]) {\n\t\t\t\t\ttabsTitles[index].classList.add('_tab-active');\n\t\t\t\t}\n\t\t\t\ttabsContentItem.hidden = !tabsTitles[index].classList.contains('_tab-active');\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction setTabsStatus(tabsBlock) {\n\t\tlet tabsTitles = tabsBlock.querySelectorAll('[data-tabs-title]');\n\t\tlet tabsContent = tabsBlock.querySelectorAll('[data-tabs-item]');\n\t\tconst tabsBlockIndex = tabsBlock.dataset.tabsIndex;\n\n\t\tfunction isTabsAnamate(tabsBlock) {\n\t\t\tif (tabsBlock.hasAttribute('data-tabs-animate')) {\n\t\t\t\treturn tabsBlock.dataset.tabsAnimate > 0 ? Number(tabsBlock.dataset.tabsAnimate) : 500;\n\t\t\t}\n\t\t}\n\t\tconst tabsBlockAnimate = isTabsAnamate(tabsBlock);\n\t\tif (tabsContent.length > 0) {\n\t\t\tconst isHash = tabsBlock.hasAttribute('data-tabs-hash');\n\t\t\ttabsContent = Array.from(tabsContent).filter(item => item.closest('[data-tabs]') === tabsBlock);\n\t\t\ttabsTitles = Array.from(tabsTitles).filter(item => item.closest('[data-tabs]') === tabsBlock);\n\t\t\ttabsContent.forEach((tabsContentItem, index) => {\n\t\t\t\tif (tabsTitles[index].classList.contains('_tab-active')) {\n\t\t\t\t\tif (tabsBlockAnimate) {\n\t\t\t\t\t\t_slideDown(tabsContentItem, tabsBlockAnimate);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttabsContentItem.hidden = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (isHash && !tabsContentItem.closest('.popup')) {\n\t\t\t\t\t\tsetHash(`tab-${tabsBlockIndex}-${index}`);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (tabsBlockAnimate) {\n\t\t\t\t\t\t_slideUp(tabsContentItem, tabsBlockAnimate);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttabsContentItem.hidden = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction setTabsAction(e) {\n\t\tconst el = e.target;\n\t\tif (el.closest('[data-tabs-title]')) {\n\t\t\tconst tabTitle = el.closest('[data-tabs-title]');\n\t\t\tconst tabsBlock = tabTitle.closest('[data-tabs]');\n\t\t\tif (!tabTitle.classList.contains('_tab-active') && !tabsBlock.querySelector('._slide')) {\n\t\t\t\tlet tabActiveTitle = tabsBlock.querySelectorAll('[data-tabs-title]._tab-active');\n\t\t\t\ttabActiveTitle.length ? tabActiveTitle = Array.from(tabActiveTitle).filter(item => item.closest('[data-tabs]') === tabsBlock) : null;\n\t\t\t\ttabActiveTitle.length ? tabActiveTitle[0].classList.remove('_tab-active') : null;\n\t\t\t\ttabTitle.classList.add('_tab-active');\n\t\t\t\tsetTabsStatus(tabsBlock);\n\t\t\t}\n\t\t\te.preventDefault();\n\t\t}\n\t}\n}\n// Модуль работы с меню (бургер) =======================================================================================================================================================================================================================\n/*\nДокументация по работе в шаблоне: https://template.fls.guru/template-docs/menu-burger.html\nСниппет (HTML): menu\n*/\nfunction menuInit() {\n\tif (document.querySelector(\".icon-menu\")) {\n\t\tdocument.addEventListener(\"click\", function (e) {\n\t\t\tif (bodyLockStatus && e.target.closest('.icon-menu')) {\n\t\t\t\tbodyLockToggle();\n\t\t\t\tdocument.documentElement.classList.toggle(\"menu-open\");\n\t\t\t}\n\t\t});\n\t};\n}\nfunction menuOpen() {\n\tbodyLock();\n\tdocument.documentElement.classList.add(\"menu-open\");\n}\nfunction menuClose() {\n\tbodyUnlock();\n\tdocument.documentElement.classList.remove(\"menu-open\");\n}\n// Модуль \"показать еще\" =======================================================================================================================================================================================================================\n/*\nДокументация по работе в шаблоне: https://template.fls.guru/template-docs/modul-pokazat-eshhjo.html\nСниппет (HTML): showmore\n*/\nfunction showMore() {\n\twindow.addEventListener(\"load\", function (e) {\n\t\tconst showMoreBlocks = document.querySelectorAll('[data-showmore]');\n\t\tlet showMoreBlocksRegular;\n\t\tlet mdQueriesArray;\n\t\tif (showMoreBlocks.length) {\n\t\t\t// Получение обычных объектов\n\t\t\tshowMoreBlocksRegular = Array.from(showMoreBlocks).filter(function (item, index, self) {\n\t\t\t\treturn !item.dataset.showmoreMedia;\n\t\t\t});\n\t\t\t// Инициализация обычных объектов\n\t\t\tshowMoreBlocksRegular.length ? initItems(showMoreBlocksRegular) : null;\n\n\t\t\tdocument.addEventListener(\"click\", showMoreActions);\n\t\t\twindow.addEventListener(\"resize\", showMoreActions);\n\n\t\t\t// Получение объектов с медиа запросами\n\t\t\tmdQueriesArray = dataMediaQueries(showMoreBlocks, \"showmoreMedia\");\n\t\t\tif (mdQueriesArray && mdQueriesArray.length) {\n\t\t\t\tmdQueriesArray.forEach(mdQueriesItem => {\n\t\t\t\t\t// Событие\n\t\t\t\t\tmdQueriesItem.matchMedia.addEventListener(\"change\", function () {\n\t\t\t\t\t\tinitItems(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tinitItemsMedia(mdQueriesArray);\n\t\t\t}\n\t\t}\n\n\t\tfunction initItemsMedia(mdQueriesArray) {\n\t\t\tmdQueriesArray.forEach(mdQueriesItem => {\n\t\t\t\tinitItems(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);\n\t\t\t});\n\t\t}\n\n\t\tfunction initItems(showMoreBlocks, matchMedia) {\n\t\t\tshowMoreBlocks.forEach(showMoreBlock => {\n\t\t\t\tinitItem(showMoreBlock, matchMedia);\n\t\t\t});\n\t\t}\n\n\t\tfunction initItem(showMoreBlock, matchMedia = false) {\n\t\t\tshowMoreBlock = matchMedia ? showMoreBlock.item : showMoreBlock;\n\t\t\tlet showMoreContent = showMoreBlock.querySelectorAll('[data-showmore-content]');\n\t\t\tlet showMoreButton = showMoreBlock.querySelectorAll('[data-showmore-button]');\n\t\t\tshowMoreContent = Array.from(showMoreContent).filter(item => item.closest('[data-showmore]') === showMoreBlock)[0];\n\t\t\tshowMoreButton = Array.from(showMoreButton).filter(item => item.closest('[data-showmore]') === showMoreBlock)[0];\n\t\t\tconst hiddenHeight = getHeight(showMoreBlock, showMoreContent);\n\t\t\tif (matchMedia.matches || !matchMedia) {\n\t\t\t\tif (hiddenHeight < getOriginalHeight(showMoreContent)) {\n\t\t\t\t\t_slideUp(showMoreContent, 0, hiddenHeight);\n\t\t\t\t\tshowMoreButton.hidden = false;\n\t\t\t\t} else {\n\t\t\t\t\t_slideDown(showMoreContent, 0, hiddenHeight);\n\t\t\t\t\tshowMoreButton.hidden = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_slideDown(showMoreContent, 0, hiddenHeight);\n\t\t\t\tshowMoreButton.hidden = true;\n\t\t\t}\n\t\t}\n\n\t\tfunction getHeight(showMoreBlock, showMoreContent) {\n\t\t\tlet hiddenHeight = 0;\n\t\t\tconst showMoreType = showMoreBlock.dataset.showmore ? showMoreBlock.dataset.showmore : 'size';\n\t\t\tif (showMoreType === 'items') {\n\t\t\t\tconst showMoreTypeValue = showMoreContent.dataset.showmoreContent ? showMoreContent.dataset.showmoreContent : 3;\n\t\t\t\tconst showMoreItems = showMoreContent.children;\n\t\t\t\tfor (let index = 1; index < showMoreItems.length; index++) {\n\t\t\t\t\tconst showMoreItem = showMoreItems[index - 1];\n\t\t\t\t\thiddenHeight += showMoreItem.offsetHeight;\n\t\t\t\t\tif (index == showMoreTypeValue) break\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst showMoreTypeValue = showMoreContent.dataset.showmoreContent ? showMoreContent.dataset.showmoreContent : 150;\n\t\t\t\thiddenHeight = showMoreTypeValue;\n\t\t\t}\n\t\t\treturn hiddenHeight;\n\t\t}\n\n\t\tfunction getOriginalHeight(showMoreContent) {\n\t\t\tlet parentHidden;\n\t\t\tlet hiddenHeight = showMoreContent.offsetHeight;\n\t\t\tshowMoreContent.style.removeProperty('height');\n\t\t\tif (showMoreContent.closest(`[hidden]`)) {\n\t\t\t\tparentHidden = showMoreContent.closest(`[hidden]`);\n\t\t\t\tparentHidden.hidden = false;\n\t\t\t}\n\t\t\tlet originalHeight = showMoreContent.offsetHeight;\n\t\t\tparentHidden ? parentHidden.hidden = true : null;\n\t\t\tshowMoreContent.style.height = `${hiddenHeight}px`;\n\t\t\treturn originalHeight;\n\t\t}\n\n\t\tfunction showMoreActions(e) {\n\t\t\tconst targetEvent = e.target;\n\t\t\tconst targetType = e.type;\n\t\t\tif (targetType === 'click') {\n\t\t\t\tif (targetEvent.closest('[data-showmore-button]')) {\n\t\t\t\t\tconst showMoreButton = targetEvent.closest('[data-showmore-button]');\n\t\t\t\t\tconst showMoreBlock = showMoreButton.closest('[data-showmore]');\n\t\t\t\t\tconst showMoreContent = showMoreBlock.querySelector('[data-showmore-content]');\n\t\t\t\t\tconst showMoreSpeed = showMoreBlock.dataset.showmoreButton ? showMoreBlock.dataset.showmoreButton : '500';\n\t\t\t\t\tconst hiddenHeight = getHeight(showMoreBlock, showMoreContent);\n\t\t\t\t\tif (!showMoreContent.classList.contains('_slide')) {\n\t\t\t\t\t\tshowMoreBlock.classList.contains('_showmore-active') ? _slideUp(showMoreContent, showMoreSpeed, hiddenHeight) : _slideDown(showMoreContent, showMoreSpeed, hiddenHeight);\n\t\t\t\t\t\tshowMoreBlock.classList.toggle('_showmore-active');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (targetType === 'resize') {\n\t\t\t\tshowMoreBlocksRegular && showMoreBlocksRegular.length ? initItems(showMoreBlocksRegular) : null;\n\t\t\t\tmdQueriesArray && mdQueriesArray.length ? initItemsMedia(mdQueriesArray) : null;\n\t\t\t}\n\t\t}\n\t});\n}\n//================================================================================================================================================================================================================================================================================================================\n// Прочие полезные функции ================================================================================================================================================================================================================================================================================================================\n//================================================================================================================================================================================================================================================================================================================\n// FLS (Full Logging System)\nfunction FLS(message) {\n\tsetTimeout(() => {\n\t\tif (window.FLS) {\n\t\t\tconsole.log(message);\n\t\t}\n\t}, 0);\n}\n// Получить цифры из строки\nfunction getDigFromString(item) {\n\treturn parseInt(item.replace(/[^\\d]/g, ''))\n}\n// Форматирование цифр типа 100 000 000\nfunction getDigFormat(item) {\n\treturn item.toString().replace(/(\\d)(?=(\\d\\d\\d)+([^\\d]|$))/g, \"$1 \");\n}\n// Убрать класс из всех элементов массива\nfunction removeClasses(array, className) {\n\tfor (var i = 0; i < array.length; i++) {\n\t\tarray[i].classList.remove(className);\n\t}\n}\n// Уникализация массива\nfunction uniqArray(array) {\n\treturn array.filter(function (item, index, self) {\n\t\treturn self.indexOf(item) === index;\n\t});\n}\n// Функция получения индекса внутри родителя\nfunction indexInParent(parent, element) {\n\tconst array = Array.prototype.slice.call(parent.children);\n\treturn Array.prototype.indexOf.call(array, element);\n};\n// Обработа медиа запросов из атрибутов \nfunction dataMediaQueries(array, dataSetValue) {\n\t// Получение объектов с медиа запросами\n\tconst media = Array.from(array).filter(function (item, index, self) {\n\t\tif (item.dataset[dataSetValue]) {\n\t\t\treturn item.dataset[dataSetValue].split(\",\")[0];\n\t\t}\n\t});\n\t// Инициализация объектов с медиа запросами\n\tif (media.length) {\n\t\tconst breakpointsArray = [];\n\t\tmedia.forEach(item => {\n\t\t\tconst params = item.dataset[dataSetValue];\n\t\t\tconst breakpoint = {};\n\t\t\tconst paramsArray = params.split(\",\");\n\t\t\tbreakpoint.value = paramsArray[0];\n\t\t\tbreakpoint.type = paramsArray[1] ? paramsArray[1].trim() : \"max\";\n\t\t\tbreakpoint.item = item;\n\t\t\tbreakpointsArray.push(breakpoint);\n\t\t});\n\t\t// Получаем уникальные брейкпоинты\n\t\tlet mdQueries = breakpointsArray.map(function (item) {\n\t\t\treturn '(' + item.type + \"-width: \" + item.value + \"px),\" + item.value + ',' + item.type;\n\t\t});\n\t\tmdQueries = uniqArray(mdQueries);\n\t\tconst mdQueriesArray = [];\n\n\t\tif (mdQueries.length) {\n\t\t\t// Работаем с каждым брейкпоинтом\n\t\t\tmdQueries.forEach(breakpoint => {\n\t\t\t\tconst paramsArray = breakpoint.split(\",\");\n\t\t\t\tconst mediaBreakpoint = paramsArray[1];\n\t\t\t\tconst mediaType = paramsArray[2];\n\t\t\t\tconst matchMedia = window.matchMedia(paramsArray[0]);\n\t\t\t\t// Объекты с нужными условиями\n\t\t\t\tconst itemsArray = breakpointsArray.filter(function (item) {\n\t\t\t\t\tif (item.value === mediaBreakpoint && item.type === mediaType) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tmdQueriesArray.push({\n\t\t\t\t\titemsArray,\n\t\t\t\t\tmatchMedia\n\t\t\t\t})\n\t\t\t});\n\t\t\treturn mdQueriesArray;\n\t\t}\n\t}\n}\n//================================================================================================================================================================================================================================================================================================================\n\n//# sourceURL=webpack://gulp-2022/./src/js/files/functions.js?");

/***/ }),

/***/ "./src/js/files/modules.js":
/*!*********************************!*\
  !*** ./src/js/files/modules.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"flsModules\": () => (/* binding */ flsModules)\n/* harmony export */ });\nconst flsModules = {}\n\n//# sourceURL=webpack://gulp-2022/./src/js/files/modules.js?");

/***/ }),

/***/ "./src/js/files/script.js":
/*!********************************!*\
  !*** ./src/js/files/script.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functions.js */ \"./src/js/files/functions.js\");\n/* harmony import */ var _modules_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules.js */ \"./src/js/files/modules.js\");\n// Подключение функционала \"Чертогов Фрилансера\"\n\n// Подключение списка активных модулей\n\n\n/*!\n * dist/inputmask.min\n * https://github.com/RobinHerbots/Inputmask\n * Copyright (c) 2010 - 2020 Robin Herbots\n * Licensed under the MIT license\n * Version: 5.0.3\n */\n\n!function webpackUniversalModuleDefinition(root, factory) { if (\"object\" == typeof exports && \"object\" == typeof module) module.exports = factory(); else if (\"function\" == typeof define && define.amd) define([], factory); else { var a = factory(); for (var i in a) (\"object\" == typeof exports ? exports : root)[i] = a[i] } }(window, function () { return modules = [function (module) { module.exports = JSON.parse('{\"BACKSPACE\":8,\"BACKSPACE_SAFARI\":127,\"DELETE\":46,\"DOWN\":40,\"END\":35,\"ENTER\":13,\"ESCAPE\":27,\"HOME\":36,\"INSERT\":45,\"LEFT\":37,\"PAGE_DOWN\":34,\"PAGE_UP\":33,\"RIGHT\":39,\"SPACE\":32,\"TAB\":9,\"UP\":38,\"X\":88,\"CONTROL\":17}') }, function (module, exports, __nested_webpack_require_1011__) { \"use strict\"; function _typeof(obj) { return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function _typeof(obj) { return typeof obj } : function _typeof(obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj }, _typeof(obj) } var $ = __nested_webpack_require_1011__(2), window = __nested_webpack_require_1011__(3), document = window.document, generateMaskSet = __nested_webpack_require_1011__(4).generateMaskSet, analyseMask = __nested_webpack_require_1011__(4).analyseMask, maskScope = __nested_webpack_require_1011__(7); function Inputmask(alias, options, internal) { if (!(this instanceof Inputmask)) return new Inputmask(alias, options, internal); this.el = void 0, this.events = {}, this.maskset = void 0, this.refreshValue = !1, !0 !== internal && ($.isPlainObject(alias) ? options = alias : (options = options || {}, alias && (options.alias = alias)), this.opts = $.extend(!0, {}, this.defaults, options), this.noMasksCache = options && void 0 !== options.definitions, this.userOptions = options || {}, resolveAlias(this.opts.alias, options, this.opts), this.isRTL = this.opts.numericInput) } function resolveAlias(aliasStr, options, opts) { var aliasDefinition = Inputmask.prototype.aliases[aliasStr]; return aliasDefinition ? (aliasDefinition.alias && resolveAlias(aliasDefinition.alias, void 0, opts), $.extend(!0, opts, aliasDefinition), $.extend(!0, opts, options), !0) : (null === opts.mask && (opts.mask = aliasStr), !1) } function importAttributeOptions(npt, opts, userOptions, dataAttribute) { function importOption(option, optionData) { optionData = void 0 !== optionData ? optionData : npt.getAttribute(dataAttribute + \"-\" + option), null !== optionData && (\"string\" == typeof optionData && (0 === option.indexOf(\"on\") ? optionData = window[optionData] : \"false\" === optionData ? optionData = !1 : \"true\" === optionData && (optionData = !0)), userOptions[option] = optionData) } if (!0 === opts.importDataAttributes) { var attrOptions = npt.getAttribute(dataAttribute), option, dataoptions, optionData, p; if (attrOptions && \"\" !== attrOptions && (attrOptions = attrOptions.replace(/'/g, '\"'), dataoptions = JSON.parse(\"{\" + attrOptions + \"}\")), dataoptions) for (p in optionData = void 0, dataoptions) if (\"alias\" === p.toLowerCase()) { optionData = dataoptions[p]; break } for (option in importOption(\"alias\", optionData), userOptions.alias && resolveAlias(userOptions.alias, userOptions, opts), opts) { if (dataoptions) for (p in optionData = void 0, dataoptions) if (p.toLowerCase() === option.toLowerCase()) { optionData = dataoptions[p]; break } importOption(option, optionData) } } return $.extend(!0, opts, userOptions), \"rtl\" !== npt.dir && !opts.rightAlign || (npt.style.textAlign = \"right\"), \"rtl\" !== npt.dir && !opts.numericInput || (npt.dir = \"ltr\", npt.removeAttribute(\"dir\"), opts.isRTL = !0), Object.keys(userOptions).length } Inputmask.prototype = { dataAttribute: \"data-inputmask\", defaults: { _maxTestPos: 500, placeholder: \"_\", optionalmarker: [\"[\", \"]\"], quantifiermarker: [\"{\", \"}\"], groupmarker: [\"(\", \")\"], alternatormarker: \"|\", escapeChar: \"\\\\\", mask: null, regex: null, oncomplete: $.noop, onincomplete: $.noop, oncleared: $.noop, repeat: 0, greedy: !1, autoUnmask: !1, removeMaskOnSubmit: !1, clearMaskOnLostFocus: !0, insertMode: !0, insertModeVisual: !0, clearIncomplete: !1, alias: null, onKeyDown: $.noop, onBeforeMask: null, onBeforePaste: function onBeforePaste(pastedValue, opts) { return $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(this, pastedValue, opts) : pastedValue }, onBeforeWrite: null, onUnMask: null, showMaskOnFocus: !0, showMaskOnHover: !0, onKeyValidation: $.noop, skipOptionalPartCharacter: \" \", numericInput: !1, rightAlign: !1, undoOnEscape: !0, radixPoint: \"\", _radixDance: !1, groupSeparator: \"\", keepStatic: null, positionCaretOnTab: !0, tabThrough: !1, supportsInputType: [\"text\", \"tel\", \"url\", \"password\", \"search\"], ignorables: [8, 9, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229], isComplete: null, preValidation: null, postValidation: null, staticDefinitionSymbol: void 0, jitMasking: !1, nullable: !0, inputEventOnly: !1, noValuePatching: !1, positionCaretOnClick: \"lvp\", casing: null, inputmode: \"text\", importDataAttributes: !0, shiftPositions: !0 }, definitions: { 9: { validator: \"[0-9\\uff11-\\uff19]\", definitionSymbol: \"*\" }, a: { validator: \"[A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5]\", definitionSymbol: \"*\" }, \"*\": { validator: \"[0-9\\uff11-\\uff19A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5]\" } }, aliases: {}, masksCache: {}, mask: function mask(elems) { var that = this; return \"string\" == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)), elems = elems.nodeName ? [elems] : elems, $.each(elems, function (ndx, el) { var scopedOpts = $.extend(!0, {}, that.opts); if (importAttributeOptions(el, scopedOpts, $.extend(!0, {}, that.userOptions), that.dataAttribute)) { var maskset = generateMaskSet(scopedOpts, that.noMasksCache); void 0 !== maskset && (void 0 !== el.inputmask && (el.inputmask.opts.autoUnmask = !0, el.inputmask.remove()), el.inputmask = new Inputmask(void 0, void 0, !0), el.inputmask.opts = scopedOpts, el.inputmask.noMasksCache = that.noMasksCache, el.inputmask.userOptions = $.extend(!0, {}, that.userOptions), el.inputmask.isRTL = scopedOpts.isRTL || scopedOpts.numericInput, el.inputmask.el = el, el.inputmask.maskset = maskset, $.data(el, \"_inputmask_opts\", scopedOpts), maskScope.call(el.inputmask, { action: \"mask\" })) } }), elems && elems[0] && elems[0].inputmask || this }, option: function option(options, noremask) { return \"string\" == typeof options ? this.opts[options] : \"object\" === _typeof(options) ? ($.extend(this.userOptions, options), this.el && !0 !== noremask && this.mask(this.el), this) : void 0 }, unmaskedvalue: function unmaskedvalue(value) { return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), maskScope.call(this, { action: \"unmaskedvalue\", value: value }) }, remove: function remove() { return maskScope.call(this, { action: \"remove\" }) }, getemptymask: function getemptymask() { return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), maskScope.call(this, { action: \"getemptymask\" }) }, hasMaskedValue: function hasMaskedValue() { return !this.opts.autoUnmask }, isComplete: function isComplete() { return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), maskScope.call(this, { action: \"isComplete\" }) }, getmetadata: function getmetadata() { return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), maskScope.call(this, { action: \"getmetadata\" }) }, isValid: function isValid(value) { return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), maskScope.call(this, { action: \"isValid\", value: value }) }, format: function format(value, metadata) { return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), maskScope.call(this, { action: \"format\", value: value, metadata: metadata }) }, setValue: function setValue(value) { this.el && $(this.el).trigger(\"setvalue\", [value]) }, analyseMask: analyseMask }, Inputmask.extendDefaults = function (options) { $.extend(!0, Inputmask.prototype.defaults, options) }, Inputmask.extendDefinitions = function (definition) { $.extend(!0, Inputmask.prototype.definitions, definition) }, Inputmask.extendAliases = function (alias) { $.extend(!0, Inputmask.prototype.aliases, alias) }, Inputmask.format = function (value, options, metadata) { return Inputmask(options).format(value, metadata) }, Inputmask.unmask = function (value, options) { return Inputmask(options).unmaskedvalue(value) }, Inputmask.isValid = function (value, options) { return Inputmask(options).isValid(value) }, Inputmask.remove = function (elems) { \"string\" == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)), elems = elems.nodeName ? [elems] : elems, $.each(elems, function (ndx, el) { el.inputmask && el.inputmask.remove() }) }, Inputmask.setValue = function (elems, value) { \"string\" == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)), elems = elems.nodeName ? [elems] : elems, $.each(elems, function (ndx, el) { el.inputmask ? el.inputmask.setValue(value) : $(el).trigger(\"setvalue\", [value]) }) }; var escapeRegexRegex = new RegExp(\"(\\\\\" + [\"/\", \".\", \"*\", \"+\", \"?\", \"|\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", \"\\\\\", \"$\", \"^\"].join(\"|\\\\\") + \")\", \"gim\"); Inputmask.escapeRegex = function (str) { return str.replace(escapeRegexRegex, \"\\\\$1\") }, Inputmask.dependencyLib = $, window.Inputmask = Inputmask, module.exports = Inputmask }, function (module, exports, __nested_webpack_require_9880__) { \"use strict\"; function _typeof(obj) { return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function _typeof(obj) { return typeof obj } : function _typeof(obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj }, _typeof(obj) } var window = __nested_webpack_require_9880__(3), document = window.document; function indexOf(list, elem) { for (var i = 0, len = list.length; i < len; i++)if (list[i] === elem) return i; return -1 } function isWindow(obj) { return null != obj && obj === obj.window } function isArraylike(obj) { var length = \"length\" in obj && obj.length, ltype = _typeof(obj); return \"function\" !== ltype && !isWindow(obj) && (!(1 !== obj.nodeType || !length) || (\"array\" === ltype || 0 === length || \"number\" == typeof length && 0 < length && length - 1 in obj)) } function isValidElement(elem) { return elem instanceof Element } function DependencyLib(elem) { return elem instanceof DependencyLib ? elem : this instanceof DependencyLib ? void (null != elem && elem !== window && (this[0] = elem.nodeName ? elem : void 0 !== elem[0] && elem[0].nodeName ? elem[0] : document.querySelector(elem), void 0 !== this[0] && null !== this[0] && (this[0].eventRegistry = this[0].eventRegistry || {}))) : new DependencyLib(elem) } DependencyLib.prototype = { on: function on(events, handler) { function addEvent(ev, namespace) { elem.addEventListener ? elem.addEventListener(ev, handler, !1) : elem.attachEvent && elem.attachEvent(\"on\" + ev, handler), eventRegistry[ev] = eventRegistry[ev] || {}, eventRegistry[ev][namespace] = eventRegistry[ev][namespace] || [], eventRegistry[ev][namespace].push(handler) } if (isValidElement(this[0])) for (var eventRegistry = this[0].eventRegistry, elem = this[0], _events = events.split(\" \"), endx = 0; endx < _events.length; endx++) { var nsEvent = _events[endx].split(\".\"), ev = nsEvent[0], namespace = nsEvent[1] || \"global\"; addEvent(ev, namespace) } return this }, off: function off(events, handler) { var eventRegistry, elem; function removeEvent(ev, namespace, handler) { if (ev in eventRegistry == !0) if (elem.removeEventListener ? elem.removeEventListener(ev, handler, !1) : elem.detachEvent && elem.detachEvent(\"on\" + ev, handler), \"global\" === namespace) for (var nmsp in eventRegistry[ev]) eventRegistry[ev][nmsp].splice(eventRegistry[ev][nmsp].indexOf(handler), 1); else eventRegistry[ev][namespace].splice(eventRegistry[ev][namespace].indexOf(handler), 1) } function resolveNamespace(ev, namespace) { var evts = [], hndx, hndL; if (0 < ev.length) if (void 0 === handler) for (hndx = 0, hndL = eventRegistry[ev][namespace].length; hndx < hndL; hndx++)evts.push({ ev: ev, namespace: namespace && 0 < namespace.length ? namespace : \"global\", handler: eventRegistry[ev][namespace][hndx] }); else evts.push({ ev: ev, namespace: namespace && 0 < namespace.length ? namespace : \"global\", handler: handler }); else if (0 < namespace.length) for (var evNdx in eventRegistry) for (var nmsp in eventRegistry[evNdx]) if (nmsp === namespace) if (void 0 === handler) for (hndx = 0, hndL = eventRegistry[evNdx][nmsp].length; hndx < hndL; hndx++)evts.push({ ev: evNdx, namespace: nmsp, handler: eventRegistry[evNdx][nmsp][hndx] }); else evts.push({ ev: evNdx, namespace: nmsp, handler: handler }); return evts } if (isValidElement(this[0])) { eventRegistry = this[0].eventRegistry, elem = this[0]; for (var _events = events.split(\" \"), endx = 0; endx < _events.length; endx++)for (var nsEvent = _events[endx].split(\".\"), offEvents = resolveNamespace(nsEvent[0], nsEvent[1]), i = 0, offEventsL = offEvents.length; i < offEventsL; i++)removeEvent(offEvents[i].ev, offEvents[i].namespace, offEvents[i].handler) } return this }, trigger: function trigger(events, argument_1) { if (isValidElement(this[0])) for (var eventRegistry = this[0].eventRegistry, elem = this[0], _events = \"string\" == typeof events ? events.split(\" \") : [events.type], endx = 0; endx < _events.length; endx++) { var nsEvent = _events[endx].split(\".\"), ev = nsEvent[0], namespace = nsEvent[1] || \"global\"; if (void 0 !== document && \"global\" === namespace) { var evnt, i, params = { bubbles: !0, cancelable: !0, detail: argument_1 }; if (document.createEvent) { try { evnt = new CustomEvent(ev, params) } catch (e) { evnt = document.createEvent(\"CustomEvent\"), evnt.initCustomEvent(ev, params.bubbles, params.cancelable, params.detail) } events.type && DependencyLib.extend(evnt, events), elem.dispatchEvent(evnt) } else evnt = document.createEventObject(), evnt.eventType = ev, evnt.detail = argument_1, events.type && DependencyLib.extend(evnt, events), elem.fireEvent(\"on\" + evnt.eventType, evnt) } else if (void 0 !== eventRegistry[ev]) if (events = events.type ? events : DependencyLib.Event(events), events.detail = arguments.slice(1), \"global\" === namespace) for (var nmsp in eventRegistry[ev]) for (i = 0; i < eventRegistry[ev][nmsp].length; i++)eventRegistry[ev][nmsp][i].apply(elem, arguments); else for (i = 0; i < eventRegistry[ev][namespace].length; i++)eventRegistry[ev][namespace][i].apply(elem, arguments) } return this } }, DependencyLib.isFunction = function (obj) { return \"function\" == typeof obj }, DependencyLib.noop = function () { }, DependencyLib.isArray = Array.isArray, DependencyLib.inArray = function (elem, arr, i) { return null == arr ? -1 : indexOf(arr, elem, i) }, DependencyLib.valHooks = void 0, DependencyLib.isPlainObject = function (obj) { return \"object\" === _typeof(obj) && !obj.nodeType && !isWindow(obj) && !(obj.constructor && !Object.hasOwnProperty.call(obj.constructor.prototype, \"isPrototypeOf\")) }, DependencyLib.extend = function () { var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = !1; for (\"boolean\" == typeof target && (deep = target, target = arguments[i] || {}, i++), \"object\" === _typeof(target) || DependencyLib.isFunction(target) || (target = {}), i === length && (target = this, i--); i < length; i++)if (null != (options = arguments[i])) for (name in options) src = target[name], copy = options[name], target !== copy && (deep && copy && (DependencyLib.isPlainObject(copy) || (copyIsArray = DependencyLib.isArray(copy))) ? (clone = copyIsArray ? (copyIsArray = !1, src && DependencyLib.isArray(src) ? src : []) : src && DependencyLib.isPlainObject(src) ? src : {}, target[name] = DependencyLib.extend(deep, clone, copy)) : void 0 !== copy && (target[name] = copy)); return target }, DependencyLib.each = function (obj, callback) { var value, i = 0; if (isArraylike(obj)) for (var length = obj.length; i < length && (value = callback.call(obj[i], i, obj[i]), !1 !== value); i++); else for (i in obj) if (value = callback.call(obj[i], i, obj[i]), !1 === value) break; return obj }, DependencyLib.data = function (owner, key, value) { if (void 0 === value) return owner.__data ? owner.__data[key] : null; owner.__data = owner.__data || {}, owner.__data[key] = value }, \"function\" == typeof window.CustomEvent ? DependencyLib.Event = window.CustomEvent : (DependencyLib.Event = function (event, params) { params = params || { bubbles: !1, cancelable: !1, detail: void 0 }; var evt = document.createEvent(\"CustomEvent\"); return evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail), evt }, DependencyLib.Event.prototype = window.Event.prototype), module.exports = DependencyLib }, function (module, exports, __nested_webpack_require_17364__) { \"use strict\"; var __WEBPACK_AMD_DEFINE_RESULT__; function _typeof(obj) { return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function _typeof(obj) { return typeof obj } : function _typeof(obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj }, _typeof(obj) } __WEBPACK_AMD_DEFINE_RESULT__ = function () { return \"undefined\" != typeof window ? window : new (eval(\"require('jsdom').JSDOM\"))(\"\").window }.call(exports, __nested_webpack_require_17364__, exports, module), void 0 === __WEBPACK_AMD_DEFINE_RESULT__ || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__) }, function (module, exports, __nested_webpack_require_18076__) { \"use strict\"; var $ = __nested_webpack_require_18076__(2); function generateMaskSet(opts, nocache) { var ms; function generateMask(mask, metadata, opts) { var regexMask = !1, masksetDefinition, maskdefKey; if (null !== mask && \"\" !== mask || (regexMask = null !== opts.regex, mask = regexMask ? (mask = opts.regex, mask.replace(/^(\\^)(.*)(\\$)$/, \"$2\")) : (regexMask = !0, \".*\")), 1 === mask.length && !1 === opts.greedy && 0 !== opts.repeat && (opts.placeholder = \"\"), 0 < opts.repeat || \"*\" === opts.repeat || \"+\" === opts.repeat) { var repeatStart = \"*\" === opts.repeat ? 0 : \"+\" === opts.repeat ? 1 : opts.repeat; mask = opts.groupmarker[0] + mask + opts.groupmarker[1] + opts.quantifiermarker[0] + repeatStart + \",\" + opts.repeat + opts.quantifiermarker[1] } return maskdefKey = regexMask ? \"regex_\" + opts.regex : opts.numericInput ? mask.split(\"\").reverse().join(\"\") : mask, !1 !== opts.keepStatic && (maskdefKey = \"ks_\" + maskdefKey), void 0 === Inputmask.prototype.masksCache[maskdefKey] || !0 === nocache ? (masksetDefinition = { mask: mask, maskToken: Inputmask.prototype.analyseMask(mask, regexMask, opts), validPositions: {}, _buffer: void 0, buffer: void 0, tests: {}, excludes: {}, metadata: metadata, maskLength: void 0, jitOffset: {} }, !0 !== nocache && (Inputmask.prototype.masksCache[maskdefKey] = masksetDefinition, masksetDefinition = $.extend(!0, {}, Inputmask.prototype.masksCache[maskdefKey]))) : masksetDefinition = $.extend(!0, {}, Inputmask.prototype.masksCache[maskdefKey]), masksetDefinition } if ($.isFunction(opts.mask) && (opts.mask = opts.mask(opts)), $.isArray(opts.mask)) { if (1 < opts.mask.length) { null === opts.keepStatic && (opts.keepStatic = !0); var altMask = opts.groupmarker[0]; return $.each(opts.isRTL ? opts.mask.reverse() : opts.mask, function (ndx, msk) { 1 < altMask.length && (altMask += opts.groupmarker[1] + opts.alternatormarker + opts.groupmarker[0]), void 0 === msk.mask || $.isFunction(msk.mask) ? altMask += msk : altMask += msk.mask }), altMask += opts.groupmarker[1], generateMask(altMask, opts.mask, opts) } opts.mask = opts.mask.pop() } return null === opts.keepStatic && (opts.keepStatic = !1), ms = opts.mask && void 0 !== opts.mask.mask && !$.isFunction(opts.mask.mask) ? generateMask(opts.mask.mask, opts.mask, opts) : generateMask(opts.mask, opts.mask, opts), ms } function analyseMask(mask, regexMask, opts) { var tokenizer = /(?:[?*+]|\\{[0-9+*]+(?:,[0-9+*]*)?(?:\\|[0-9+*]*)?\\})|[^.?*+^${[]()|\\\\]+|./g, regexTokenizer = /\\[\\^?]?(?:[^\\\\\\]]+|\\\\[\\S\\s]?)*]?|\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\\S\\s]?)|\\((?:\\?[:=!]?)?|(?:[?*+]|\\{[0-9]+(?:,[0-9]*)?\\})\\??|[^.?*+^${[()|\\\\]+|./g, escaped = !1, currentToken = new MaskToken, match, m, openenings = [], maskTokens = [], openingToken, currentOpeningToken, alternator, lastMatch, closeRegexGroup = !1; function MaskToken(isGroup, isOptional, isQuantifier, isAlternator) { this.matches = [], this.openGroup = isGroup || !1, this.alternatorGroup = !1, this.isGroup = isGroup || !1, this.isOptional = isOptional || !1, this.isQuantifier = isQuantifier || !1, this.isAlternator = isAlternator || !1, this.quantifier = { min: 1, max: 1 } } function insertTestDefinition(mtoken, element, position) { position = void 0 !== position ? position : mtoken.matches.length; var prevMatch = mtoken.matches[position - 1]; if (regexMask) 0 === element.indexOf(\"[\") || escaped && /\\\\d|\\\\s|\\\\w]/i.test(element) || \".\" === element ? mtoken.matches.splice(position++, 0, { fn: new RegExp(element, opts.casing ? \"i\" : \"\"), static: !1, optionality: !1, newBlockMarker: void 0 === prevMatch ? \"master\" : prevMatch.def !== element, casing: null, def: element, placeholder: void 0, nativeDef: element }) : (escaped && (element = element[element.length - 1]), $.each(element.split(\"\"), function (ndx, lmnt) { prevMatch = mtoken.matches[position - 1], mtoken.matches.splice(position++, 0, { fn: /[a-z]/i.test(opts.staticDefinitionSymbol || lmnt) ? new RegExp(\"[\" + (opts.staticDefinitionSymbol || lmnt) + \"]\", opts.casing ? \"i\" : \"\") : null, static: !0, optionality: !1, newBlockMarker: void 0 === prevMatch ? \"master\" : prevMatch.def !== lmnt && !0 !== prevMatch.static, casing: null, def: opts.staticDefinitionSymbol || lmnt, placeholder: void 0 !== opts.staticDefinitionSymbol ? lmnt : void 0, nativeDef: (escaped ? \"'\" : \"\") + lmnt }) })), escaped = !1; else { var maskdef = (opts.definitions ? opts.definitions[element] : void 0) || Inputmask.prototype.definitions[element]; maskdef && !escaped ? mtoken.matches.splice(position++, 0, { fn: maskdef.validator ? \"string\" == typeof maskdef.validator ? new RegExp(maskdef.validator, opts.casing ? \"i\" : \"\") : new function () { this.test = maskdef.validator } : new RegExp(\".\"), static: maskdef.static || !1, optionality: !1, newBlockMarker: void 0 === prevMatch ? \"master\" : prevMatch.def !== (maskdef.definitionSymbol || element), casing: maskdef.casing, def: maskdef.definitionSymbol || element, placeholder: maskdef.placeholder, nativeDef: element, generated: maskdef.generated }) : (mtoken.matches.splice(position++, 0, { fn: /[a-z]/i.test(opts.staticDefinitionSymbol || element) ? new RegExp(\"[\" + (opts.staticDefinitionSymbol || element) + \"]\", opts.casing ? \"i\" : \"\") : null, static: !0, optionality: !1, newBlockMarker: void 0 === prevMatch ? \"master\" : prevMatch.def !== element && !0 !== prevMatch.static, casing: null, def: opts.staticDefinitionSymbol || element, placeholder: void 0 !== opts.staticDefinitionSymbol ? element : void 0, nativeDef: (escaped ? \"'\" : \"\") + element }), escaped = !1) } } function verifyGroupMarker(maskToken) { maskToken && maskToken.matches && $.each(maskToken.matches, function (ndx, token) { var nextToken = maskToken.matches[ndx + 1]; (void 0 === nextToken || void 0 === nextToken.matches || !1 === nextToken.isQuantifier) && token && token.isGroup && (token.isGroup = !1, regexMask || (insertTestDefinition(token, opts.groupmarker[0], 0), !0 !== token.openGroup && insertTestDefinition(token, opts.groupmarker[1]))), verifyGroupMarker(token) }) } function defaultCase() { if (0 < openenings.length) { if (currentOpeningToken = openenings[openenings.length - 1], insertTestDefinition(currentOpeningToken, m), currentOpeningToken.isAlternator) { alternator = openenings.pop(); for (var mndx = 0; mndx < alternator.matches.length; mndx++)alternator.matches[mndx].isGroup && (alternator.matches[mndx].isGroup = !1); 0 < openenings.length ? (currentOpeningToken = openenings[openenings.length - 1], currentOpeningToken.matches.push(alternator)) : currentToken.matches.push(alternator) } } else insertTestDefinition(currentToken, m) } function reverseTokens(maskToken) { function reverseStatic(st) { return st === opts.optionalmarker[0] ? st = opts.optionalmarker[1] : st === opts.optionalmarker[1] ? st = opts.optionalmarker[0] : st === opts.groupmarker[0] ? st = opts.groupmarker[1] : st === opts.groupmarker[1] && (st = opts.groupmarker[0]), st } for (var match in maskToken.matches = maskToken.matches.reverse(), maskToken.matches) if (Object.prototype.hasOwnProperty.call(maskToken.matches, match)) { var intMatch = parseInt(match); if (maskToken.matches[match].isQuantifier && maskToken.matches[intMatch + 1] && maskToken.matches[intMatch + 1].isGroup) { var qt = maskToken.matches[match]; maskToken.matches.splice(match, 1), maskToken.matches.splice(intMatch + 1, 0, qt) } void 0 !== maskToken.matches[match].matches ? maskToken.matches[match] = reverseTokens(maskToken.matches[match]) : maskToken.matches[match] = reverseStatic(maskToken.matches[match]) } return maskToken } function groupify(matches) { var groupToken = new MaskToken(!0); return groupToken.openGroup = !1, groupToken.matches = matches, groupToken } function closeGroup() { if (openingToken = openenings.pop(), openingToken.openGroup = !1, void 0 !== openingToken) if (0 < openenings.length) { if (currentOpeningToken = openenings[openenings.length - 1], currentOpeningToken.matches.push(openingToken), currentOpeningToken.isAlternator) { alternator = openenings.pop(); for (var mndx = 0; mndx < alternator.matches.length; mndx++)alternator.matches[mndx].isGroup = !1, alternator.matches[mndx].alternatorGroup = !1; 0 < openenings.length ? (currentOpeningToken = openenings[openenings.length - 1], currentOpeningToken.matches.push(alternator)) : currentToken.matches.push(alternator) } } else currentToken.matches.push(openingToken); else defaultCase() } function groupQuantifier(matches) { var lastMatch = matches.pop(); return lastMatch.isQuantifier && (lastMatch = groupify([matches.pop(), lastMatch])), lastMatch } for (regexMask && (opts.optionalmarker[0] = void 0, opts.optionalmarker[1] = void 0); match = regexMask ? regexTokenizer.exec(mask) : tokenizer.exec(mask);) { if (m = match[0], regexMask) switch (m.charAt(0)) { case \"?\": m = \"{0,1}\"; break; case \"+\": case \"*\": m = \"{\" + m + \"}\"; break; case \"|\": if (0 === openenings.length) { var altRegexGroup = groupify(currentToken.matches); altRegexGroup.openGroup = !0, openenings.push(altRegexGroup), currentToken.matches = [], closeRegexGroup = !0 } break }if (escaped) defaultCase(); else switch (m.charAt(0)) { case \"(?=\": break; case \"(?!\": break; case \"(?<=\": break; case \"(?<!\": break; case opts.escapeChar: escaped = !0, regexMask && defaultCase(); break; case opts.optionalmarker[1]: case opts.groupmarker[1]: closeGroup(); break; case opts.optionalmarker[0]: openenings.push(new MaskToken(!1, !0)); break; case opts.groupmarker[0]: openenings.push(new MaskToken(!0)); break; case opts.quantifiermarker[0]: var quantifier = new MaskToken(!1, !1, !0); m = m.replace(/[{}]/g, \"\"); var mqj = m.split(\"|\"), mq = mqj[0].split(\",\"), mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]), mq1 = 1 === mq.length ? mq0 : isNaN(mq[1]) ? mq[1] : parseInt(mq[1]); \"*\" !== mq0 && \"+\" !== mq0 || (mq0 = \"*\" === mq1 ? 0 : 1), quantifier.quantifier = { min: mq0, max: mq1, jit: mqj[1] }; var matches = 0 < openenings.length ? openenings[openenings.length - 1].matches : currentToken.matches; if (match = matches.pop(), match.isAlternator) { matches.push(match), matches = match.matches; var groupToken = new MaskToken(!0), tmpMatch = matches.pop(); matches.push(groupToken), matches = groupToken.matches, match = tmpMatch } match.isGroup || (match = groupify([match])), matches.push(match), matches.push(quantifier); break; case opts.alternatormarker: if (0 < openenings.length) { currentOpeningToken = openenings[openenings.length - 1]; var subToken = currentOpeningToken.matches[currentOpeningToken.matches.length - 1]; lastMatch = currentOpeningToken.openGroup && (void 0 === subToken.matches || !1 === subToken.isGroup && !1 === subToken.isAlternator) ? openenings.pop() : groupQuantifier(currentOpeningToken.matches) } else lastMatch = groupQuantifier(currentToken.matches); if (lastMatch.isAlternator) openenings.push(lastMatch); else if (lastMatch.alternatorGroup ? (alternator = openenings.pop(), lastMatch.alternatorGroup = !1) : alternator = new MaskToken(!1, !1, !1, !0), alternator.matches.push(lastMatch), openenings.push(alternator), lastMatch.openGroup) { lastMatch.openGroup = !1; var alternatorGroup = new MaskToken(!0); alternatorGroup.alternatorGroup = !0, openenings.push(alternatorGroup) } break; default: defaultCase() } } for (closeRegexGroup && closeGroup(); 0 < openenings.length;)openingToken = openenings.pop(), currentToken.matches.push(openingToken); return 0 < currentToken.matches.length && (verifyGroupMarker(currentToken), maskTokens.push(currentToken)), (opts.numericInput || opts.isRTL) && reverseTokens(maskTokens[0]), maskTokens } module.exports = { generateMaskSet: generateMaskSet, analyseMask: analyseMask } }, function (module, exports, __nested_webpack_require_29811__) { \"use strict\"; __nested_webpack_require_29811__(6), __nested_webpack_require_29811__(8), __nested_webpack_require_29811__(9), __nested_webpack_require_29811__(10), module.exports = __nested_webpack_require_29811__(1) }, function (module, exports, __nested_webpack_require_30015__) { \"use strict\"; var Inputmask = __nested_webpack_require_30015__(1); Inputmask.extendDefinitions({ A: { validator: \"[A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5]\", casing: \"upper\" }, \"&\": { validator: \"[0-9A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5]\", casing: \"upper\" }, \"#\": { validator: \"[0-9A-Fa-f]\", casing: \"upper\" } }); var ipValidatorRegex = new RegExp(\"25[0-5]|2[0-4][0-9]|[01][0-9][0-9]\"); function ipValidator(chrs, maskset, pos, strict, opts) { return chrs = -1 < pos - 1 && \".\" !== maskset.buffer[pos - 1] ? (chrs = maskset.buffer[pos - 1] + chrs, -1 < pos - 2 && \".\" !== maskset.buffer[pos - 2] ? maskset.buffer[pos - 2] + chrs : \"0\" + chrs) : \"00\" + chrs, ipValidatorRegex.test(chrs) } Inputmask.extendAliases({ cssunit: { regex: \"[+-]?[0-9]+\\\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)\" }, url: { regex: \"(https?|ftp)//.*\", autoUnmask: !1 }, ip: { mask: \"i[i[i]].j[j[j]].k[k[k]].l[l[l]]\", definitions: { i: { validator: ipValidator }, j: { validator: ipValidator }, k: { validator: ipValidator }, l: { validator: ipValidator } }, onUnMask: function onUnMask(maskedValue, unmaskedValue, opts) { return maskedValue }, inputmode: \"numeric\" }, email: { mask: \"*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]\", greedy: !1, casing: \"lower\", onBeforePaste: function onBeforePaste(pastedValue, opts) { return pastedValue = pastedValue.toLowerCase(), pastedValue.replace(\"mailto:\", \"\") }, definitions: { \"*\": { validator: \"[0-9\\uff11-\\uff19A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5!#$%&'*+/=?^_`{|}~-]\" }, \"-\": { validator: \"[0-9A-Za-z-]\" } }, onUnMask: function onUnMask(maskedValue, unmaskedValue, opts) { return maskedValue }, inputmode: \"email\" }, mac: { mask: \"##:##:##:##:##:##\" }, vin: { mask: \"V{13}9{4}\", definitions: { V: { validator: \"[A-HJ-NPR-Za-hj-npr-z\\\\d]\", casing: \"upper\" } }, clearIncomplete: !0, autoUnmask: !0 }, ssn: { mask: \"999-99-9999\", postValidation: function postValidation(buffer, pos, c, currentResult, opts, maskset, strict) { return /^(?!219-09-9999|078-05-1120)(?!666|000|9.{2}).{3}-(?!00).{2}-(?!0{4}).{4}$/.test(buffer.join(\"\")) } } }), module.exports = Inputmask }, function (module, exports, __nested_webpack_require_32190__) { \"use strict\"; function _typeof(obj) { return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function _typeof(obj) { return typeof obj } : function _typeof(obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj }, _typeof(obj) } var $ = __nested_webpack_require_32190__(2), window = __nested_webpack_require_32190__(3), document = window.document, ua = window.navigator && window.navigator.userAgent || \"\", ie = 0 < ua.indexOf(\"MSIE \") || 0 < ua.indexOf(\"Trident/\"), mobile = \"ontouchstart\" in window, iemobile = /iemobile/i.test(ua), iphone = /iphone/i.test(ua) && !iemobile, keyCode = __nested_webpack_require_32190__(0); module.exports = function maskScope(actionObj, maskset, opts) { maskset = maskset || this.maskset, opts = opts || this.opts; var inputmask = this, el = this.el, isRTL = this.isRTL || (this.isRTL = opts.numericInput), undoValue, $el, skipKeyPressEvent = !1, skipInputEvent = !1, validationEvent = !1, ignorable = !1, maxLength, mouseEnter = !1, originalPlaceholder = void 0; function getMaskTemplate(baseOnInput, minimalPos, includeMode, noJit, clearOptionalTail) { var greedy = opts.greedy; clearOptionalTail && (opts.greedy = !1), minimalPos = minimalPos || 0; var maskTemplate = [], ndxIntlzr, pos = 0, test, testPos, jitRenderStatic; do { if (!0 === baseOnInput && maskset.validPositions[pos]) testPos = clearOptionalTail && !0 === maskset.validPositions[pos].match.optionality && void 0 === maskset.validPositions[pos + 1] && (!0 === maskset.validPositions[pos].generatedInput || maskset.validPositions[pos].input == opts.skipOptionalPartCharacter && 0 < pos) ? determineTestTemplate(pos, getTests(pos, ndxIntlzr, pos - 1)) : maskset.validPositions[pos], test = testPos.match, ndxIntlzr = testPos.locator.slice(), maskTemplate.push(!0 === includeMode ? testPos.input : !1 === includeMode ? test.nativeDef : getPlaceholder(pos, test)); else { testPos = getTestTemplate(pos, ndxIntlzr, pos - 1), test = testPos.match, ndxIntlzr = testPos.locator.slice(); var jitMasking = !0 !== noJit && (!1 !== opts.jitMasking ? opts.jitMasking : test.jit); jitRenderStatic = jitRenderStatic && test.static && test.def !== opts.groupSeparator && null === test.fn || maskset.validPositions[pos - 1] && test.static && test.def !== opts.groupSeparator && null === test.fn, jitRenderStatic || !1 === jitMasking || void 0 === jitMasking || \"number\" == typeof jitMasking && isFinite(jitMasking) && pos < jitMasking ? maskTemplate.push(!1 === includeMode ? test.nativeDef : getPlaceholder(pos, test)) : jitRenderStatic = !1 } pos++ } while ((void 0 === maxLength || pos < maxLength) && (!0 !== test.static || \"\" !== test.def) || pos < minimalPos); return \"\" === maskTemplate[maskTemplate.length - 1] && maskTemplate.pop(), !1 === includeMode && void 0 !== maskset.maskLength || (maskset.maskLength = pos - 1), opts.greedy = greedy, maskTemplate } function resetMaskSet(soft) { maskset.buffer = void 0, !0 !== soft && (maskset.validPositions = {}, maskset.p = 0) } function getLastValidPosition(closestTo, strict, validPositions) { var before = -1, after = -1, valids = validPositions || maskset.validPositions; for (var posNdx in void 0 === closestTo && (closestTo = -1), valids) { var psNdx = parseInt(posNdx); valids[psNdx] && (strict || !0 !== valids[psNdx].generatedInput) && (psNdx <= closestTo && (before = psNdx), closestTo <= psNdx && (after = psNdx)) } return -1 === before || before == closestTo ? after : -1 == after ? before : closestTo - before < after - closestTo ? before : after } function getDecisionTaker(tst) { var decisionTaker = tst.locator[tst.alternation]; return \"string\" == typeof decisionTaker && 0 < decisionTaker.length && (decisionTaker = decisionTaker.split(\",\")[0]), void 0 !== decisionTaker ? decisionTaker.toString() : \"\" } function getLocator(tst, align) { var locator = (null != tst.alternation ? tst.mloc[getDecisionTaker(tst)] : tst.locator).join(\"\"); if (\"\" !== locator) for (; locator.length < align;)locator += \"0\"; return locator } function determineTestTemplate(pos, tests) { pos = 0 < pos ? pos - 1 : 0; for (var altTest = getTest(pos), targetLocator = getLocator(altTest), tstLocator, closest, bestMatch, ndx = 0; ndx < tests.length; ndx++) { var tst = tests[ndx]; tstLocator = getLocator(tst, targetLocator.length); var distance = Math.abs(tstLocator - targetLocator); (void 0 === closest || \"\" !== tstLocator && distance < closest || bestMatch && !opts.greedy && bestMatch.match.optionality && \"master\" === bestMatch.match.newBlockMarker && (!tst.match.optionality || !tst.match.newBlockMarker) || bestMatch && bestMatch.match.optionalQuantifier && !tst.match.optionalQuantifier) && (closest = distance, bestMatch = tst) } return bestMatch } function getTestTemplate(pos, ndxIntlzr, tstPs) { return maskset.validPositions[pos] || determineTestTemplate(pos, getTests(pos, ndxIntlzr ? ndxIntlzr.slice() : ndxIntlzr, tstPs)) } function getTest(pos, tests) { return maskset.validPositions[pos] ? maskset.validPositions[pos] : (tests || getTests(pos))[0] } function positionCanMatchDefinition(pos, testDefinition, opts) { for (var valid = !1, tests = getTests(pos), tndx = 0; tndx < tests.length; tndx++) { if (tests[tndx].match && (!(tests[tndx].match.nativeDef !== testDefinition.match[opts.shiftPositions ? \"def\" : \"nativeDef\"] || opts.shiftPositions && testDefinition.match.static) || tests[tndx].match.nativeDef === testDefinition.match.nativeDef)) { valid = !0; break } if (tests[tndx].match && tests[tndx].match.def === testDefinition.match.nativeDef) { valid = void 0; break } } return !1 === valid && void 0 !== maskset.jitOffset[pos] && (valid = positionCanMatchDefinition(pos + maskset.jitOffset[pos], testDefinition, opts)), valid } function getTests(pos, ndxIntlzr, tstPs) { var maskTokens = maskset.maskToken, testPos = ndxIntlzr ? tstPs : 0, ndxInitializer = ndxIntlzr ? ndxIntlzr.slice() : [0], matches = [], insertStop = !1, latestMatch, cacheDependency = ndxIntlzr ? ndxIntlzr.join(\"\") : \"\"; function resolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) { function handleMatch(match, loopNdx, quantifierRecurse) { function isFirstMatch(latestMatch, tokenGroup) { var firstMatch = 0 === $.inArray(latestMatch, tokenGroup.matches); return firstMatch || $.each(tokenGroup.matches, function (ndx, match) { if (!0 === match.isQuantifier ? firstMatch = isFirstMatch(latestMatch, tokenGroup.matches[ndx - 1]) : Object.prototype.hasOwnProperty.call(match, \"matches\") && (firstMatch = isFirstMatch(latestMatch, match)), firstMatch) return !1 }), firstMatch } function resolveNdxInitializer(pos, alternateNdx, targetAlternation) { var bestMatch, indexPos; if ((maskset.tests[pos] || maskset.validPositions[pos]) && $.each(maskset.tests[pos] || [maskset.validPositions[pos]], function (ndx, lmnt) { if (lmnt.mloc[alternateNdx]) return bestMatch = lmnt, !1; var alternation = void 0 !== targetAlternation ? targetAlternation : lmnt.alternation, ndxPos = void 0 !== lmnt.locator[alternation] ? lmnt.locator[alternation].toString().indexOf(alternateNdx) : -1; (void 0 === indexPos || ndxPos < indexPos) && -1 !== ndxPos && (bestMatch = lmnt, indexPos = ndxPos) }), bestMatch) { var bestMatchAltIndex = bestMatch.locator[bestMatch.alternation], locator = bestMatch.mloc[alternateNdx] || bestMatch.mloc[bestMatchAltIndex] || bestMatch.locator; return locator.slice((void 0 !== targetAlternation ? targetAlternation : bestMatch.alternation) + 1) } return void 0 !== targetAlternation ? resolveNdxInitializer(pos, alternateNdx) : void 0 } function isSubsetOf(source, target) { function expand(pattern) { for (var expanded = [], start = -1, end, i = 0, l = pattern.length; i < l; i++)if (\"-\" === pattern.charAt(i)) for (end = pattern.charCodeAt(i + 1); ++start < end;)expanded.push(String.fromCharCode(start)); else start = pattern.charCodeAt(i), expanded.push(pattern.charAt(i)); return expanded.join(\"\") } return source.match.def === target.match.nativeDef || !(!(opts.regex || source.match.fn instanceof RegExp && target.match.fn instanceof RegExp) || !0 === source.match.static || !0 === target.match.static) && -1 !== expand(target.match.fn.toString().replace(/[[\\]/]/g, \"\")).indexOf(expand(source.match.fn.toString().replace(/[[\\]/]/g, \"\"))) } function staticCanMatchDefinition(source, target) { return !0 === source.match.static && !0 !== target.match.static && target.match.fn.test(source.match.def, maskset, pos, !1, opts, !1) } function setMergeLocators(targetMatch, altMatch) { var alternationNdx = targetMatch.alternation, shouldMerge = void 0 === altMatch || alternationNdx === altMatch.alternation && -1 === targetMatch.locator[alternationNdx].toString().indexOf(altMatch.locator[alternationNdx]); if (!shouldMerge && alternationNdx > altMatch.alternation) for (var i = altMatch.alternation; i < alternationNdx; i++)if (targetMatch.locator[i] !== altMatch.locator[i]) { alternationNdx = i, shouldMerge = !0; break } if (shouldMerge) { targetMatch.mloc = targetMatch.mloc || {}; var locNdx = targetMatch.locator[alternationNdx]; if (void 0 !== locNdx) { if (\"string\" == typeof locNdx && (locNdx = locNdx.split(\",\")[0]), void 0 === targetMatch.mloc[locNdx] && (targetMatch.mloc[locNdx] = targetMatch.locator.slice()), void 0 !== altMatch) { for (var ndx in altMatch.mloc) \"string\" == typeof ndx && (ndx = ndx.split(\",\")[0]), void 0 === targetMatch.mloc[ndx] && (targetMatch.mloc[ndx] = altMatch.mloc[ndx]); targetMatch.locator[alternationNdx] = Object.keys(targetMatch.mloc).join(\",\") } return !0 } targetMatch.alternation = void 0 } return !1 } function isSameLevel(targetMatch, altMatch) { if (targetMatch.locator.length !== altMatch.locator.length) return !1; for (var locNdx = targetMatch.alternation + 1; locNdx < targetMatch.locator.length; locNdx++)if (targetMatch.locator[locNdx] !== altMatch.locator[locNdx]) return !1; return !0 } if (testPos > opts._maxTestPos && void 0 !== quantifierRecurse) throw \"Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. \" + maskset.mask; if (testPos === pos && void 0 === match.matches) return matches.push({ match: match, locator: loopNdx.reverse(), cd: cacheDependency, mloc: {} }), !0; if (void 0 !== match.matches) { if (match.isGroup && quantifierRecurse !== match) { if (match = handleMatch(maskToken.matches[$.inArray(match, maskToken.matches) + 1], loopNdx, quantifierRecurse), match) return !0 } else if (match.isOptional) { var optionalToken = match, mtchsNdx = matches.length; if (match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse), match) { if ($.each(matches, function (ndx, mtch) { mtchsNdx <= ndx && (mtch.match.optionality = !0) }), latestMatch = matches[matches.length - 1].match, void 0 !== quantifierRecurse || !isFirstMatch(latestMatch, optionalToken)) return !0; insertStop = !0, testPos = pos } } else if (match.isAlternator) { var alternateToken = match, malternateMatches = [], maltMatches, currentMatches = matches.slice(), loopNdxCnt = loopNdx.length, altIndex = 0 < ndxInitializer.length ? ndxInitializer.shift() : -1; if (-1 === altIndex || \"string\" == typeof altIndex) { var currentPos = testPos, ndxInitializerClone = ndxInitializer.slice(), altIndexArr = [], amndx; if (\"string\" == typeof altIndex) altIndexArr = altIndex.split(\",\"); else for (amndx = 0; amndx < alternateToken.matches.length; amndx++)altIndexArr.push(amndx.toString()); if (void 0 !== maskset.excludes[pos]) { for (var altIndexArrClone = altIndexArr.slice(), i = 0, exl = maskset.excludes[pos].length; i < exl; i++) { var excludeSet = maskset.excludes[pos][i].toString().split(\":\"); loopNdx.length == excludeSet[1] && altIndexArr.splice(altIndexArr.indexOf(excludeSet[0]), 1) } 0 === altIndexArr.length && (delete maskset.excludes[pos], altIndexArr = altIndexArrClone) } (!0 === opts.keepStatic || isFinite(parseInt(opts.keepStatic)) && currentPos >= opts.keepStatic) && (altIndexArr = altIndexArr.slice(0, 1)); for (var unMatchedAlternation = !1, ndx = 0; ndx < altIndexArr.length; ndx++) { amndx = parseInt(altIndexArr[ndx]), matches = [], ndxInitializer = \"string\" == typeof altIndex && resolveNdxInitializer(testPos, amndx, loopNdxCnt) || ndxInitializerClone.slice(), alternateToken.matches[amndx] && handleMatch(alternateToken.matches[amndx], [amndx].concat(loopNdx), quantifierRecurse) ? match = !0 : 0 === ndx && (unMatchedAlternation = !0), maltMatches = matches.slice(), testPos = currentPos, matches = []; for (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) { var altMatch = maltMatches[ndx1], dropMatch = !1; altMatch.match.jit = altMatch.match.jit || unMatchedAlternation, altMatch.alternation = altMatch.alternation || loopNdxCnt, setMergeLocators(altMatch); for (var ndx2 = 0; ndx2 < malternateMatches.length; ndx2++) { var altMatch2 = malternateMatches[ndx2]; if (\"string\" != typeof altIndex || void 0 !== altMatch.alternation && -1 !== $.inArray(altMatch.locator[altMatch.alternation].toString(), altIndexArr)) { if (altMatch.match.nativeDef === altMatch2.match.nativeDef) { dropMatch = !0, setMergeLocators(altMatch2, altMatch); break } if (isSubsetOf(altMatch, altMatch2)) { setMergeLocators(altMatch, altMatch2) && (dropMatch = !0, malternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch)); break } if (isSubsetOf(altMatch2, altMatch)) { setMergeLocators(altMatch2, altMatch); break } if (staticCanMatchDefinition(altMatch, altMatch2)) { isSameLevel(altMatch, altMatch2) || void 0 !== el.inputmask.userOptions.keepStatic ? setMergeLocators(altMatch, altMatch2) && (dropMatch = !0, malternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch)) : opts.keepStatic = !0; break } } } dropMatch || malternateMatches.push(altMatch) } } matches = currentMatches.concat(malternateMatches), testPos = pos, insertStop = 0 < matches.length, match = 0 < malternateMatches.length, ndxInitializer = ndxInitializerClone.slice() } else match = handleMatch(alternateToken.matches[altIndex] || maskToken.matches[altIndex], [altIndex].concat(loopNdx), quantifierRecurse); if (match) return !0 } else if (match.isQuantifier && quantifierRecurse !== maskToken.matches[$.inArray(match, maskToken.matches) - 1]) for (var qt = match, qndx = 0 < ndxInitializer.length ? ndxInitializer.shift() : 0; qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max) && testPos <= pos; qndx++) { var tokenGroup = maskToken.matches[$.inArray(qt, maskToken.matches) - 1]; if (match = handleMatch(tokenGroup, [qndx].concat(loopNdx), tokenGroup), match) { if (latestMatch = matches[matches.length - 1].match, latestMatch.optionalQuantifier = qndx >= qt.quantifier.min, latestMatch.jit = (qndx || 1) * tokenGroup.matches.indexOf(latestMatch) >= qt.quantifier.jit, latestMatch.optionalQuantifier && isFirstMatch(latestMatch, tokenGroup)) { insertStop = !0, testPos = pos; break } return latestMatch.jit && (maskset.jitOffset[pos] = tokenGroup.matches.length - tokenGroup.matches.indexOf(latestMatch)), !0 } } else if (match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse), match) return !0 } else testPos++ } for (var tndx = 0 < ndxInitializer.length ? ndxInitializer.shift() : 0; tndx < maskToken.matches.length; tndx++)if (!0 !== maskToken.matches[tndx].isQuantifier) { var match = handleMatch(maskToken.matches[tndx], [tndx].concat(loopNdx), quantifierRecurse); if (match && testPos === pos) return match; if (pos < testPos) break } } function mergeLocators(pos, tests) { var locator = []; return $.isArray(tests) || (tests = [tests]), 0 < tests.length && (void 0 === tests[0].alternation || !0 === opts.keepStatic ? (locator = determineTestTemplate(pos, tests.slice()).locator.slice(), 0 === locator.length && (locator = tests[0].locator.slice())) : $.each(tests, function (ndx, tst) { if (\"\" !== tst.def) if (0 === locator.length) locator = tst.locator.slice(); else for (var i = 0; i < locator.length; i++)tst.locator[i] && -1 === locator[i].toString().indexOf(tst.locator[i]) && (locator[i] += \",\" + tst.locator[i]) })), locator } if (-1 < pos && (void 0 === maxLength || pos < maxLength)) { if (void 0 === ndxIntlzr) { for (var previousPos = pos - 1, test; void 0 === (test = maskset.validPositions[previousPos] || maskset.tests[previousPos]) && -1 < previousPos;)previousPos--; void 0 !== test && -1 < previousPos && (ndxInitializer = mergeLocators(previousPos, test), cacheDependency = ndxInitializer.join(\"\"), testPos = previousPos) } if (maskset.tests[pos] && maskset.tests[pos][0].cd === cacheDependency) return maskset.tests[pos]; for (var mtndx = ndxInitializer.shift(); mtndx < maskTokens.length; mtndx++) { var match = resolveTestFromToken(maskTokens[mtndx], ndxInitializer, [mtndx]); if (match && testPos === pos || pos < testPos) break } } return 0 !== matches.length && !insertStop || matches.push({ match: { fn: null, static: !0, optionality: !1, casing: null, def: \"\", placeholder: \"\" }, locator: [], mloc: {}, cd: cacheDependency }), void 0 !== ndxIntlzr && maskset.tests[pos] ? $.extend(!0, [], matches) : (maskset.tests[pos] = $.extend(!0, [], matches), maskset.tests[pos]) } function getBufferTemplate() { return void 0 === maskset._buffer && (maskset._buffer = getMaskTemplate(!1, 1), void 0 === maskset.buffer && (maskset.buffer = maskset._buffer.slice())), maskset._buffer } function getBuffer(noCache) { return void 0 !== maskset.buffer && !0 !== noCache || (maskset.buffer = getMaskTemplate(!0, getLastValidPosition(), !0), void 0 === maskset._buffer && (maskset._buffer = maskset.buffer.slice())), maskset.buffer } function refreshFromBuffer(start, end, buffer) { var i, p, skipOptionalPartCharacter = opts.skipOptionalPartCharacter, bffr = isRTL ? buffer.slice().reverse() : buffer; if (opts.skipOptionalPartCharacter = \"\", !0 === start) resetMaskSet(), maskset.tests = {}, start = 0, end = buffer.length, p = determineNewCaretPosition({ begin: 0, end: 0 }, !1).begin; else { for (i = start; i < end; i++)delete maskset.validPositions[i]; p = start } var keypress = new $.Event(\"keypress\"); for (i = start; i < end; i++) { keypress.which = bffr[i].toString().charCodeAt(0), ignorable = !1; var valResult = EventHandlers.keypressEvent.call(el, keypress, !0, !1, !1, p); !1 !== valResult && (p = valResult.forwardPosition) } opts.skipOptionalPartCharacter = skipOptionalPartCharacter } function casing(elem, test, pos) { switch (opts.casing || test.casing) { case \"upper\": elem = elem.toUpperCase(); break; case \"lower\": elem = elem.toLowerCase(); break; case \"title\": var posBefore = maskset.validPositions[pos - 1]; elem = 0 === pos || posBefore && posBefore.input === String.fromCharCode(keyCode.SPACE) ? elem.toUpperCase() : elem.toLowerCase(); break; default: if ($.isFunction(opts.casing)) { var args = Array.prototype.slice.call(arguments); args.push(maskset.validPositions), elem = opts.casing.apply(this, args) } }return elem } function checkAlternationMatch(altArr1, altArr2, na) { for (var altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1), isMatch = !1, naArr = void 0 !== na ? na.split(\",\") : [], naNdx, i = 0; i < naArr.length; i++)-1 !== (naNdx = altArr1.indexOf(naArr[i])) && altArr1.splice(naNdx, 1); for (var alndx = 0; alndx < altArr1.length; alndx++)if (-1 !== $.inArray(altArr1[alndx], altArrC)) { isMatch = !0; break } return isMatch } function alternate(maskPos, c, strict, fromIsValid, rAltPos, selection) { var validPsClone = $.extend(!0, {}, maskset.validPositions), tstClone = $.extend(!0, {}, maskset.tests), lastAlt, alternation, isValidRslt = !1, returnRslt = !1, altPos, prevAltPos, i, validPos, decisionPos, lAltPos = void 0 !== rAltPos ? rAltPos : getLastValidPosition(), nextPos, input, begin, end; if (selection && (begin = selection.begin, end = selection.end, selection.begin > selection.end && (begin = selection.end, end = selection.begin)), -1 === lAltPos && void 0 === rAltPos) lastAlt = 0, prevAltPos = getTest(lastAlt), alternation = prevAltPos.alternation; else for (; 0 <= lAltPos; lAltPos--)if (altPos = maskset.validPositions[lAltPos], altPos && void 0 !== altPos.alternation) { if (prevAltPos && prevAltPos.locator[altPos.alternation] !== altPos.locator[altPos.alternation]) break; lastAlt = lAltPos, alternation = maskset.validPositions[lastAlt].alternation, prevAltPos = altPos } if (void 0 !== alternation) { decisionPos = parseInt(lastAlt), maskset.excludes[decisionPos] = maskset.excludes[decisionPos] || [], !0 !== maskPos && maskset.excludes[decisionPos].push(getDecisionTaker(prevAltPos) + \":\" + prevAltPos.alternation); var validInputs = [], resultPos = -1; for (i = decisionPos; i < getLastValidPosition(void 0, !0) + 1; i++)-1 === resultPos && maskPos <= i && void 0 !== c && (validInputs.push(c), resultPos = validInputs.length - 1), validPos = maskset.validPositions[i], validPos && !0 !== validPos.generatedInput && (void 0 === selection || i < begin || end <= i) && validInputs.push(validPos.input), delete maskset.validPositions[i]; for (-1 === resultPos && void 0 !== c && (validInputs.push(c), resultPos = validInputs.length - 1); void 0 !== maskset.excludes[decisionPos] && maskset.excludes[decisionPos].length < 10;) { for (maskset.tests = {}, resetMaskSet(!0), isValidRslt = !0, i = 0; i < validInputs.length && (nextPos = isValidRslt.caret || getLastValidPosition(void 0, !0) + 1, input = validInputs[i], isValidRslt = isValid(nextPos, input, !1, fromIsValid, !0)); i++)i === resultPos && (returnRslt = isValidRslt), 1 == maskPos && isValidRslt && (returnRslt = { caretPos: i }); if (isValidRslt) break; if (resetMaskSet(), prevAltPos = getTest(decisionPos), maskset.validPositions = $.extend(!0, {}, validPsClone), maskset.tests = $.extend(!0, {}, tstClone), !maskset.excludes[decisionPos]) { returnRslt = alternate(maskPos, c, strict, fromIsValid, decisionPos - 1, selection); break } var decisionTaker = getDecisionTaker(prevAltPos); if (-1 !== maskset.excludes[decisionPos].indexOf(decisionTaker + \":\" + prevAltPos.alternation)) { returnRslt = alternate(maskPos, c, strict, fromIsValid, decisionPos - 1, selection); break } for (maskset.excludes[decisionPos].push(decisionTaker + \":\" + prevAltPos.alternation), i = decisionPos; i < getLastValidPosition(void 0, !0) + 1; i++)delete maskset.validPositions[i] } } return returnRslt && !1 === opts.keepStatic || delete maskset.excludes[decisionPos], returnRslt } function isValid(pos, c, strict, fromIsValid, fromAlternate, validateOnly) { function isSelection(posObj) { return isRTL ? 1 < posObj.begin - posObj.end || posObj.begin - posObj.end == 1 : 1 < posObj.end - posObj.begin || posObj.end - posObj.begin == 1 } strict = !0 === strict; var maskPos = pos; function processCommandObject(commandObj) { if (void 0 !== commandObj) { if (void 0 !== commandObj.remove && ($.isArray(commandObj.remove) || (commandObj.remove = [commandObj.remove]), $.each(commandObj.remove.sort(function (a, b) { return b.pos - a.pos }), function (ndx, lmnt) { revalidateMask({ begin: lmnt, end: lmnt + 1 }) }), commandObj.remove = void 0), void 0 !== commandObj.insert && ($.isArray(commandObj.insert) || (commandObj.insert = [commandObj.insert]), $.each(commandObj.insert.sort(function (a, b) { return a.pos - b.pos }), function (ndx, lmnt) { \"\" !== lmnt.c && isValid(lmnt.pos, lmnt.c, void 0 === lmnt.strict || lmnt.strict, void 0 !== lmnt.fromIsValid ? lmnt.fromIsValid : fromIsValid) }), commandObj.insert = void 0), commandObj.refreshFromBuffer && commandObj.buffer) { var refresh = commandObj.refreshFromBuffer; refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, commandObj.buffer), commandObj.refreshFromBuffer = void 0 } void 0 !== commandObj.rewritePosition && (maskPos = commandObj.rewritePosition, commandObj = !0) } return commandObj } function _isValid(position, c, strict) { var rslt = !1; return $.each(getTests(position), function (ndx, tst) { var test = tst.match; if (getBuffer(!0), rslt = null != test.fn ? test.fn.test(c, maskset, position, strict, opts, isSelection(pos)) : (c === test.def || c === opts.skipOptionalPartCharacter) && \"\" !== test.def && { c: getPlaceholder(position, test, !0) || test.def, pos: position }, !1 !== rslt) { var elem = void 0 !== rslt.c ? rslt.c : c, validatedPos = position; return elem = elem === opts.skipOptionalPartCharacter && !0 === test.static ? getPlaceholder(position, test, !0) || test.def : elem, rslt = processCommandObject(rslt), !0 !== rslt && void 0 !== rslt.pos && rslt.pos !== position && (validatedPos = rslt.pos), !0 !== rslt && void 0 === rslt.pos && void 0 === rslt.c ? !1 : (!1 === revalidateMask(pos, $.extend({}, tst, { input: casing(elem, test, validatedPos) }), fromIsValid, validatedPos) && (rslt = !1), !1) } }), rslt } void 0 !== pos.begin && (maskPos = isRTL ? pos.end : pos.begin); var result = !0, positionsClone = $.extend(!0, {}, maskset.validPositions); if (!1 === opts.keepStatic && void 0 !== maskset.excludes[maskPos] && !0 !== fromAlternate && !0 !== fromIsValid) for (var i = maskPos; i < (isRTL ? pos.begin : pos.end); i++)void 0 !== maskset.excludes[i] && (maskset.excludes[i] = void 0, delete maskset.tests[i]); if ($.isFunction(opts.preValidation) && !0 !== fromIsValid && !0 !== validateOnly && (result = opts.preValidation.call(el, getBuffer(), maskPos, c, isSelection(pos), opts, maskset, pos, strict || fromAlternate), result = processCommandObject(result)), !0 === result) { if (void 0 === maxLength || maskPos < maxLength) { if (result = _isValid(maskPos, c, strict), (!strict || !0 === fromIsValid) && !1 === result && !0 !== validateOnly) { var currentPosValid = maskset.validPositions[maskPos]; if (!currentPosValid || !0 !== currentPosValid.match.static || currentPosValid.match.def !== c && c !== opts.skipOptionalPartCharacter) { if (opts.insertMode || void 0 === maskset.validPositions[seekNext(maskPos)] || pos.end > maskPos) { var skip = !1; if (maskset.jitOffset[maskPos] && void 0 === maskset.validPositions[seekNext(maskPos)] && (result = isValid(maskPos + maskset.jitOffset[maskPos], c, !0), !1 !== result && (!0 !== fromAlternate && (result.caret = maskPos), skip = !0)), pos.end > maskPos && (maskset.validPositions[maskPos] = void 0), !skip && !isMask(maskPos, opts.keepStatic)) for (var nPos = maskPos + 1, snPos = seekNext(maskPos); nPos <= snPos; nPos++)if (result = _isValid(nPos, c, strict), !1 !== result) { result = trackbackPositions(maskPos, void 0 !== result.pos ? result.pos : nPos) || result, maskPos = nPos; break } } } else result = { caret: seekNext(maskPos) } } } else result = !1; !1 !== result || !opts.keepStatic || !isComplete(getBuffer()) && 0 !== maskPos || strict || !0 === fromAlternate ? isSelection(pos) && maskset.tests[maskPos] && 1 < maskset.tests[maskPos].length && opts.keepStatic && !strict && !0 !== fromAlternate && (result = alternate(!0)) : result = alternate(maskPos, c, strict, fromIsValid, void 0, pos), !0 === result && (result = { pos: maskPos }) } if ($.isFunction(opts.postValidation) && !0 !== fromIsValid && !0 !== validateOnly) { var postResult = opts.postValidation.call(el, getBuffer(!0), void 0 !== pos.begin ? isRTL ? pos.end : pos.begin : pos, c, result, opts, maskset, strict); void 0 !== postResult && (result = !0 === postResult ? result : postResult) } result && void 0 === result.pos && (result.pos = maskPos), !1 === result || !0 === validateOnly ? (resetMaskSet(!0), maskset.validPositions = $.extend(!0, {}, positionsClone)) : trackbackPositions(void 0, maskPos, !0); var endResult = processCommandObject(result); return endResult } function trackbackPositions(originalPos, newPos, fillOnly) { if (void 0 === originalPos) for (originalPos = newPos - 1; 0 < originalPos && !maskset.validPositions[originalPos]; originalPos--); for (var ps = originalPos; ps < newPos; ps++)if (void 0 === maskset.validPositions[ps] && !isMask(ps, !0)) { var vp = 0 == ps ? getTest(ps) : maskset.validPositions[ps - 1]; if (vp) { var tests = getTests(ps).slice(); \"\" === tests[tests.length - 1].match.def && tests.pop(); var bestMatch = determineTestTemplate(ps, tests), np; if (bestMatch && (!0 !== bestMatch.match.jit || \"master\" === bestMatch.match.newBlockMarker && (np = maskset.validPositions[ps + 1]) && !0 === np.match.optionalQuantifier) && (bestMatch = $.extend({}, bestMatch, { input: getPlaceholder(ps, bestMatch.match, !0) || bestMatch.match.def }), bestMatch.generatedInput = !0, revalidateMask(ps, bestMatch, !0), !0 !== fillOnly)) { var cvpInput = maskset.validPositions[newPos].input; return maskset.validPositions[newPos] = void 0, isValid(newPos, cvpInput, !0, !0) } } } } function revalidateMask(pos, validTest, fromIsValid, validatedPos) { function IsEnclosedStatic(pos, valids, selection) { var posMatch = valids[pos]; if (void 0 === posMatch || !0 !== posMatch.match.static || !0 === posMatch.match.optionality || void 0 !== valids[0] && void 0 !== valids[0].alternation) return !1; var prevMatch = selection.begin <= pos - 1 ? valids[pos - 1] && !0 === valids[pos - 1].match.static && valids[pos - 1] : valids[pos - 1], nextMatch = selection.end > pos + 1 ? valids[pos + 1] && !0 === valids[pos + 1].match.static && valids[pos + 1] : valids[pos + 1]; return prevMatch && nextMatch } var offset = 0, begin = void 0 !== pos.begin ? pos.begin : pos, end = void 0 !== pos.end ? pos.end : pos; if (pos.begin > pos.end && (begin = pos.end, end = pos.begin), validatedPos = void 0 !== validatedPos ? validatedPos : begin, begin !== end || opts.insertMode && void 0 !== maskset.validPositions[validatedPos] && void 0 === fromIsValid || void 0 === validTest) { var positionsClone = $.extend(!0, {}, maskset.validPositions), lvp = getLastValidPosition(void 0, !0), i; for (maskset.p = begin, i = lvp; begin <= i; i--)delete maskset.validPositions[i], void 0 === validTest && delete maskset.tests[i + 1]; var valid = !0, j = validatedPos, posMatch = j, t, canMatch; for (validTest && (maskset.validPositions[validatedPos] = $.extend(!0, {}, validTest), posMatch++, j++), i = validTest ? end : end - 1; i <= lvp; i++) { if (void 0 !== (t = positionsClone[i]) && !0 !== t.generatedInput && (end <= i || begin <= i && IsEnclosedStatic(i, positionsClone, { begin: begin, end: end }))) { for (; \"\" !== getTest(posMatch).match.def;) { if (!1 !== (canMatch = positionCanMatchDefinition(posMatch, t, opts)) || \"+\" === t.match.def) { \"+\" === t.match.def && getBuffer(!0); var result = isValid(posMatch, t.input, \"+\" !== t.match.def, \"+\" !== t.match.def); if (valid = !1 !== result, j = (result.pos || posMatch) + 1, !valid && canMatch) break } else valid = !1; if (valid) { void 0 === validTest && t.match.static && i === pos.begin && offset++; break } if (!valid && posMatch > maskset.maskLength) break; posMatch++ } \"\" == getTest(posMatch).match.def && (valid = !1), posMatch = j } if (!valid) break } if (!valid) return maskset.validPositions = $.extend(!0, {}, positionsClone), resetMaskSet(!0), !1 } else validTest && getTest(validatedPos).match.cd === validTest.match.cd && (maskset.validPositions[validatedPos] = $.extend(!0, {}, validTest)); return resetMaskSet(!0), offset } function isMask(pos, strict, fuzzy) { var test = getTestTemplate(pos).match; if (\"\" === test.def && (test = getTest(pos).match), !0 !== test.static) return test.fn; if (!0 === fuzzy && void 0 !== maskset.validPositions[pos] && !0 !== maskset.validPositions[pos].generatedInput) return !0; if (!0 !== strict && -1 < pos) { if (fuzzy) { var tests = getTests(pos); return tests.length > 1 + (\"\" === tests[tests.length - 1].match.def ? 1 : 0) } var testTemplate = determineTestTemplate(pos, getTests(pos)), testPlaceHolder = getPlaceholder(pos, testTemplate.match); return testTemplate.match.def !== testPlaceHolder } return !1 } function seekNext(pos, newBlock, fuzzy) { void 0 === fuzzy && (fuzzy = !0); for (var position = pos + 1; \"\" !== getTest(position).match.def && (!0 === newBlock && (!0 !== getTest(position).match.newBlockMarker || !isMask(position, void 0, !0)) || !0 !== newBlock && !isMask(position, void 0, fuzzy));)position++; return position } function seekPrevious(pos, newBlock) { var position = pos, tests; if (position <= 0) return 0; for (; 0 < --position && (!0 === newBlock && !0 !== getTest(position).match.newBlockMarker || !0 !== newBlock && !isMask(position, void 0, !0) && (tests = getTests(position), tests.length < 2 || 2 === tests.length && \"\" === tests[1].match.def));); return position } function writeBuffer(input, buffer, caretPos, event, triggerEvents) { if (event && $.isFunction(opts.onBeforeWrite)) { var result = opts.onBeforeWrite.call(inputmask, event, buffer, caretPos, opts); if (result) { if (result.refreshFromBuffer) { var refresh = result.refreshFromBuffer; refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, result.buffer || buffer), buffer = getBuffer(!0) } void 0 !== caretPos && (caretPos = void 0 !== result.caret ? result.caret : caretPos) } } if (void 0 !== input && (input.inputmask._valueSet(buffer.join(\"\")), void 0 === caretPos || void 0 !== event && \"blur\" === event.type || caret(input, caretPos, void 0, void 0, void 0 !== event && \"keydown\" === event.type && (event.keyCode === keyCode.DELETE || event.keyCode === keyCode.BACKSPACE)), !0 === triggerEvents)) { var $input = $(input), nptVal = input.inputmask._valueGet(); skipInputEvent = !0, $input.trigger(\"input\"), setTimeout(function () { nptVal === getBufferTemplate().join(\"\") ? $input.trigger(\"cleared\") : !0 === isComplete(buffer) && $input.trigger(\"complete\") }, 0) } } function getPlaceholder(pos, test, returnPL) { if (test = test || getTest(pos).match, void 0 !== test.placeholder || !0 === returnPL) return $.isFunction(test.placeholder) ? test.placeholder(opts) : test.placeholder; if (!0 !== test.static) return opts.placeholder.charAt(pos % opts.placeholder.length); if (-1 < pos && void 0 === maskset.validPositions[pos]) { var tests = getTests(pos), staticAlternations = [], prevTest; if (tests.length > 1 + (\"\" === tests[tests.length - 1].match.def ? 1 : 0)) for (var i = 0; i < tests.length; i++)if (\"\" !== tests[i].match.def && !0 !== tests[i].match.optionality && !0 !== tests[i].match.optionalQuantifier && (!0 === tests[i].match.static || void 0 === prevTest || !1 !== tests[i].match.fn.test(prevTest.match.def, maskset, pos, !0, opts)) && (staticAlternations.push(tests[i]), !0 === tests[i].match.static && (prevTest = tests[i]), 1 < staticAlternations.length && /[0-9a-bA-Z]/.test(staticAlternations[0].match.def))) return opts.placeholder.charAt(pos % opts.placeholder.length) } return test.def } function HandleNativePlaceholder(npt, value) { if (ie) { if (npt.inputmask._valueGet() !== value && (npt.placeholder !== value || \"\" === npt.placeholder)) { var buffer = getBuffer().slice(), nptValue = npt.inputmask._valueGet(); if (nptValue !== value) { var lvp = getLastValidPosition(); -1 === lvp && nptValue === getBufferTemplate().join(\"\") ? buffer = [] : -1 !== lvp && clearOptionalTail(buffer), writeBuffer(npt, buffer) } } } else npt.placeholder !== value && (npt.placeholder = value, \"\" === npt.placeholder && npt.removeAttribute(\"placeholder\")) } function determineNewCaretPosition(selectedCaret, tabbed) { function doRadixFocus(clickPos) { if (\"\" !== opts.radixPoint && 0 !== opts.digits) { var vps = maskset.validPositions; if (void 0 === vps[clickPos] || vps[clickPos].input === getPlaceholder(clickPos)) { if (clickPos < seekNext(-1)) return !0; var radixPos = $.inArray(opts.radixPoint, getBuffer()); if (-1 !== radixPos) { for (var vp in vps) if (vps[vp] && radixPos < vp && vps[vp].input !== getPlaceholder(vp)) return !1; return !0 } } } return !1 } if (tabbed && (isRTL ? selectedCaret.end = selectedCaret.begin : selectedCaret.begin = selectedCaret.end), selectedCaret.begin === selectedCaret.end) { switch (opts.positionCaretOnClick) { case \"none\": break; case \"select\": selectedCaret = { begin: 0, end: getBuffer().length }; break; case \"ignore\": selectedCaret.end = selectedCaret.begin = seekNext(getLastValidPosition()); break; case \"radixFocus\": if (doRadixFocus(selectedCaret.begin)) { var radixPos = getBuffer().join(\"\").indexOf(opts.radixPoint); selectedCaret.end = selectedCaret.begin = opts.numericInput ? seekNext(radixPos) : radixPos; break } default: var clickPosition = selectedCaret.begin, lvclickPosition = getLastValidPosition(clickPosition, !0), lastPosition = seekNext(-1 !== lvclickPosition || isMask(0) ? lvclickPosition : 0); if (clickPosition < lastPosition) selectedCaret.end = selectedCaret.begin = isMask(clickPosition, !0) || isMask(clickPosition - 1, !0) ? clickPosition : seekNext(clickPosition); else { var lvp = maskset.validPositions[lvclickPosition], tt = getTestTemplate(lastPosition, lvp ? lvp.match.locator : void 0, lvp), placeholder = getPlaceholder(lastPosition, tt.match); if (\"\" !== placeholder && getBuffer()[lastPosition] !== placeholder && !0 !== tt.match.optionalQuantifier && !0 !== tt.match.newBlockMarker || !isMask(lastPosition, opts.keepStatic) && tt.match.def === placeholder) { var newPos = seekNext(lastPosition); (newPos <= clickPosition || clickPosition === lastPosition) && (lastPosition = newPos) } selectedCaret.end = selectedCaret.begin = lastPosition } }return selectedCaret } } var EventRuler = { on: function on(input, eventName, eventHandler) { var ev = function ev(e) { e.originalEvent && (e = e.originalEvent || e, arguments[0] = e); var that = this, args; if (void 0 === that.inputmask && \"FORM\" !== this.nodeName) { var imOpts = $.data(that, \"_inputmask_opts\"); imOpts ? new Inputmask(imOpts).mask(that) : EventRuler.off(that) } else { if (\"setvalue\" === e.type || \"FORM\" === this.nodeName || !(that.disabled || that.readOnly && !(\"keydown\" === e.type && e.ctrlKey && 67 === e.keyCode || !1 === opts.tabThrough && e.keyCode === keyCode.TAB))) { switch (e.type) { case \"input\": if (!0 === skipInputEvent || e.inputType && \"insertCompositionText\" === e.inputType) return skipInputEvent = !1, e.preventDefault(); break; case \"keydown\": skipKeyPressEvent = !1, skipInputEvent = !1; break; case \"keypress\": if (!0 === skipKeyPressEvent) return e.preventDefault(); skipKeyPressEvent = !0; break; case \"click\": case \"focus\": return validationEvent ? (validationEvent = !1, input.blur(), HandleNativePlaceholder(input, (isRTL ? getBufferTemplate().slice().reverse() : getBufferTemplate()).join(\"\")), setTimeout(function () { input.focus() }, 3e3)) : (args = arguments, setTimeout(function () { input.inputmask && eventHandler.apply(that, args) }, 0)), !1 }var returnVal = eventHandler.apply(that, arguments); return !1 === returnVal && (e.preventDefault(), e.stopPropagation()), returnVal } e.preventDefault() } }; input.inputmask.events[eventName] = input.inputmask.events[eventName] || [], input.inputmask.events[eventName].push(ev), -1 !== $.inArray(eventName, [\"submit\", \"reset\"]) ? null !== input.form && $(input.form).on(eventName, ev) : $(input).on(eventName, ev) }, off: function off(input, event) { var events; input.inputmask && input.inputmask.events && (event ? (events = [], events[event] = input.inputmask.events[event]) : events = input.inputmask.events, $.each(events, function (eventName, evArr) { for (; 0 < evArr.length;) { var ev = evArr.pop(); -1 !== $.inArray(eventName, [\"submit\", \"reset\"]) ? null !== input.form && $(input.form).off(eventName, ev) : $(input).off(eventName, ev) } delete input.inputmask.events[eventName] })) } }, EventHandlers = { keydownEvent: function keydownEvent(e) { var input = this, $input = $(input), k = e.keyCode, pos = caret(input), kdResult = opts.onKeyDown.call(this, e, getBuffer(), pos, opts); if (void 0 !== kdResult) return kdResult; if (k === keyCode.BACKSPACE || k === keyCode.DELETE || iphone && k === keyCode.BACKSPACE_SAFARI || e.ctrlKey && k === keyCode.X && !(\"oncut\" in input)) e.preventDefault(), handleRemove(input, k, pos), writeBuffer(input, getBuffer(!0), maskset.p, e, input.inputmask._valueGet() !== getBuffer().join(\"\")); else if (k === keyCode.END || k === keyCode.PAGE_DOWN) { e.preventDefault(); var caretPos = seekNext(getLastValidPosition()); caret(input, e.shiftKey ? pos.begin : caretPos, caretPos, !0) } else k === keyCode.HOME && !e.shiftKey || k === keyCode.PAGE_UP ? (e.preventDefault(), caret(input, 0, e.shiftKey ? pos.begin : 0, !0)) : (opts.undoOnEscape && k === keyCode.ESCAPE || 90 === k && e.ctrlKey) && !0 !== e.altKey ? (checkVal(input, !0, !1, undoValue.split(\"\")), $input.trigger(\"click\")) : !0 === opts.tabThrough && k === keyCode.TAB ? (!0 === e.shiftKey ? (!0 === getTest(pos.begin).match.static && (pos.begin = seekNext(pos.begin)), pos.end = seekPrevious(pos.begin, !0), pos.begin = seekPrevious(pos.end, !0)) : (pos.begin = seekNext(pos.begin, !0), pos.end = seekNext(pos.begin, !0), pos.end < maskset.maskLength && pos.end--), pos.begin < maskset.maskLength && (e.preventDefault(), caret(input, pos.begin, pos.end))) : e.shiftKey || opts.insertModeVisual && !1 === opts.insertMode && (k === keyCode.RIGHT ? setTimeout(function () { var caretPos = caret(input); caret(input, caretPos.begin) }, 0) : k === keyCode.LEFT && setTimeout(function () { var caretPos_begin = translatePosition(input.inputmask.caretPos.begin), caretPos_end = translatePosition(input.inputmask.caretPos.end); caret(input, isRTL ? caretPos_begin + (caretPos_begin === maskset.maskLength ? 0 : 1) : caretPos_begin - (0 === caretPos_begin ? 0 : 1)) }, 0)); ignorable = -1 !== $.inArray(k, opts.ignorables) }, keypressEvent: function keypressEvent(e, checkval, writeOut, strict, ndx) { var input = this, $input = $(input), k = e.which || e.charCode || e.keyCode; if (!(!0 === checkval || e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable)) return k === keyCode.ENTER && undoValue !== getBuffer().join(\"\") && (undoValue = getBuffer().join(\"\"), setTimeout(function () { $input.trigger(\"change\") }, 0)), skipInputEvent = !0, !0; if (k) { 44 !== k && 46 !== k || 3 !== e.location || \"\" === opts.radixPoint || (k = opts.radixPoint.charCodeAt(0)); var pos = checkval ? { begin: ndx, end: ndx } : caret(input), forwardPosition, c = String.fromCharCode(k); maskset.writeOutBuffer = !0; var valResult = isValid(pos, c, strict); if (!1 !== valResult && (resetMaskSet(!0), forwardPosition = void 0 !== valResult.caret ? valResult.caret : seekNext(valResult.pos.begin ? valResult.pos.begin : valResult.pos), maskset.p = forwardPosition), forwardPosition = opts.numericInput && void 0 === valResult.caret ? seekPrevious(forwardPosition) : forwardPosition, !1 !== writeOut && (setTimeout(function () { opts.onKeyValidation.call(input, k, valResult) }, 0), maskset.writeOutBuffer && !1 !== valResult)) { var buffer = getBuffer(); writeBuffer(input, buffer, forwardPosition, e, !0 !== checkval) } if (e.preventDefault(), checkval) return !1 !== valResult && (valResult.forwardPosition = forwardPosition), valResult } }, pasteEvent: function pasteEvent(e) { var input = this, inputValue = this.inputmask._valueGet(!0), caretPos = caret(this), tempValue; isRTL && (tempValue = caretPos.end, caretPos.end = caretPos.begin, caretPos.begin = tempValue); var valueBeforeCaret = inputValue.substr(0, caretPos.begin), valueAfterCaret = inputValue.substr(caretPos.end, inputValue.length); if (valueBeforeCaret == (isRTL ? getBufferTemplate().slice().reverse() : getBufferTemplate()).slice(0, caretPos.begin).join(\"\") && (valueBeforeCaret = \"\"), valueAfterCaret == (isRTL ? getBufferTemplate().slice().reverse() : getBufferTemplate()).slice(caretPos.end).join(\"\") && (valueAfterCaret = \"\"), window.clipboardData && window.clipboardData.getData) inputValue = valueBeforeCaret + window.clipboardData.getData(\"Text\") + valueAfterCaret; else { if (!e.clipboardData || !e.clipboardData.getData) return !0; inputValue = valueBeforeCaret + e.clipboardData.getData(\"text/plain\") + valueAfterCaret } var pasteValue = inputValue; if ($.isFunction(opts.onBeforePaste)) { if (pasteValue = opts.onBeforePaste.call(inputmask, inputValue, opts), !1 === pasteValue) return e.preventDefault(); pasteValue = pasteValue || inputValue } return checkVal(this, !1, !1, pasteValue.toString().split(\"\")), writeBuffer(this, getBuffer(), seekNext(getLastValidPosition()), e, undoValue !== getBuffer().join(\"\")), e.preventDefault() }, inputFallBackEvent: function inputFallBackEvent(e) { function ieMobileHandler(input, inputValue, caretPos) { if (iemobile) { var inputChar = inputValue.replace(getBuffer().join(\"\"), \"\"); if (1 === inputChar.length) { var iv = inputValue.split(\"\"); iv.splice(caretPos.begin, 0, inputChar), inputValue = iv.join(\"\") } } return inputValue } function analyseChanges(inputValue, buffer, caretPos) { for (var frontPart = inputValue.substr(0, caretPos.begin).split(\"\"), backPart = inputValue.substr(caretPos.begin).split(\"\"), frontBufferPart = buffer.substr(0, caretPos.begin).split(\"\"), backBufferPart = buffer.substr(caretPos.begin).split(\"\"), fpl = frontPart.length >= frontBufferPart.length ? frontPart.length : frontBufferPart.length, bpl = backPart.length >= backBufferPart.length ? backPart.length : backBufferPart.length, bl, i, action = \"\", data = [], marker = \"~\", placeholder; frontPart.length < fpl;)frontPart.push(\"~\"); for (; frontBufferPart.length < fpl;)frontBufferPart.push(\"~\"); for (; backPart.length < bpl;)backPart.unshift(\"~\"); for (; backBufferPart.length < bpl;)backBufferPart.unshift(\"~\"); var newBuffer = frontPart.concat(backPart), oldBuffer = frontBufferPart.concat(backBufferPart); for (i = 0, bl = newBuffer.length; i < bl; i++)switch (placeholder = getPlaceholder(translatePosition(i)), action) { case \"insertText\": oldBuffer[i - 1] === newBuffer[i] && caretPos.begin == newBuffer.length - 1 && data.push(newBuffer[i]), i = bl; break; case \"insertReplacementText\": \"~\" === newBuffer[i] ? caretPos.end++ : i = bl; break; case \"deleteContentBackward\": \"~\" === newBuffer[i] ? caretPos.end++ : i = bl; break; default: newBuffer[i] !== oldBuffer[i] && (\"~\" !== newBuffer[i + 1] && newBuffer[i + 1] !== placeholder && void 0 !== newBuffer[i + 1] || (oldBuffer[i] !== placeholder || \"~\" !== oldBuffer[i + 1]) && \"~\" !== oldBuffer[i] ? \"~\" === oldBuffer[i + 1] && oldBuffer[i] === newBuffer[i + 1] ? (action = \"insertText\", data.push(newBuffer[i]), caretPos.begin--, caretPos.end--) : newBuffer[i] !== placeholder && \"~\" !== newBuffer[i] && (\"~\" === newBuffer[i + 1] || oldBuffer[i] !== newBuffer[i] && oldBuffer[i + 1] === newBuffer[i + 1]) ? (action = \"insertReplacementText\", data.push(newBuffer[i]), caretPos.begin--) : \"~\" === newBuffer[i] ? (action = \"deleteContentBackward\", !isMask(translatePosition(i), !0) && oldBuffer[i] !== opts.radixPoint || caretPos.end++) : i = bl : (action = \"insertText\", data.push(newBuffer[i]), caretPos.begin--, caretPos.end--)); break }return { action: action, data: data, caret: caretPos } } var input = this, inputValue = input.inputmask._valueGet(!0), buffer = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join(\"\"), caretPos = caret(input, void 0, void 0, !0); if (buffer !== inputValue) { inputValue = ieMobileHandler(input, inputValue, caretPos); var changes = analyseChanges(inputValue, buffer, caretPos); switch ((input.inputmask.shadowRoot || document).activeElement !== input && input.focus(), writeBuffer(input, getBuffer()), caret(input, caretPos.begin, caretPos.end, !0), changes.action) { case \"insertText\": case \"insertReplacementText\": $.each(changes.data, function (ndx, entry) { var keypress = new $.Event(\"keypress\"); keypress.which = entry.charCodeAt(0), ignorable = !1, EventHandlers.keypressEvent.call(input, keypress) }), setTimeout(function () { $el.trigger(\"keyup\") }, 0); break; case \"deleteContentBackward\": var keydown = new $.Event(\"keydown\"); keydown.keyCode = keyCode.BACKSPACE, EventHandlers.keydownEvent.call(input, keydown); break; default: applyInputValue(input, inputValue); break }e.preventDefault() } }, compositionendEvent: function compositionendEvent(e) { $el.trigger(\"input\") }, setValueEvent: function setValueEvent(e, argument_1, argument_2) { var input = this, value = e && e.detail ? e.detail[0] : argument_1; void 0 === value && (value = this.inputmask._valueGet(!0)), applyInputValue(this, value), (e.detail && void 0 !== e.detail[1] || void 0 !== argument_2) && caret(this, e.detail ? e.detail[1] : argument_2) }, focusEvent: function focusEvent(e) { var input = this, nptValue = this.inputmask._valueGet(); opts.showMaskOnFocus && nptValue !== getBuffer().join(\"\") && writeBuffer(this, getBuffer(), seekNext(getLastValidPosition())), !0 !== opts.positionCaretOnTab || !1 !== mouseEnter || isComplete(getBuffer()) && -1 !== getLastValidPosition() || EventHandlers.clickEvent.apply(this, [e, !0]), undoValue = getBuffer().join(\"\") }, invalidEvent: function invalidEvent(e) { validationEvent = !0 }, mouseleaveEvent: function mouseleaveEvent() { var input = this; mouseEnter = !1, opts.clearMaskOnLostFocus && (this.inputmask.shadowRoot || document).activeElement !== this && HandleNativePlaceholder(this, originalPlaceholder) }, clickEvent: function clickEvent(e, tabbed) { var input = this; if ((this.inputmask.shadowRoot || document).activeElement === this) { var newCaretPosition = determineNewCaretPosition(caret(this), tabbed); void 0 !== newCaretPosition && caret(this, newCaretPosition) } }, cutEvent: function cutEvent(e) { var input = this, pos = caret(this), clipboardData = window.clipboardData || e.clipboardData, clipData = isRTL ? getBuffer().slice(pos.end, pos.begin) : getBuffer().slice(pos.begin, pos.end); clipboardData.setData(\"text\", isRTL ? clipData.reverse().join(\"\") : clipData.join(\"\")), document.execCommand && document.execCommand(\"copy\"), handleRemove(this, keyCode.DELETE, pos), writeBuffer(this, getBuffer(), maskset.p, e, undoValue !== getBuffer().join(\"\")) }, blurEvent: function blurEvent(e) { var $input = $(this), input = this; if (this.inputmask) { HandleNativePlaceholder(this, originalPlaceholder); var nptValue = this.inputmask._valueGet(), buffer = getBuffer().slice(); \"\" !== nptValue && (opts.clearMaskOnLostFocus && (-1 === getLastValidPosition() && nptValue === getBufferTemplate().join(\"\") ? buffer = [] : clearOptionalTail(buffer)), !1 === isComplete(buffer) && (setTimeout(function () { $input.trigger(\"incomplete\") }, 0), opts.clearIncomplete && (resetMaskSet(), buffer = opts.clearMaskOnLostFocus ? [] : getBufferTemplate().slice())), writeBuffer(this, buffer, void 0, e)), undoValue !== getBuffer().join(\"\") && (undoValue = getBuffer().join(\"\"), $input.trigger(\"change\")) } }, mouseenterEvent: function mouseenterEvent() { var input = this; mouseEnter = !0, (this.inputmask.shadowRoot || document).activeElement !== this && (null == originalPlaceholder && this.placeholder !== originalPlaceholder && (originalPlaceholder = this.placeholder), opts.showMaskOnHover && HandleNativePlaceholder(this, (isRTL ? getBufferTemplate().slice().reverse() : getBufferTemplate()).join(\"\"))) }, submitEvent: function submitEvent() { undoValue !== getBuffer().join(\"\") && $el.trigger(\"change\"), opts.clearMaskOnLostFocus && -1 === getLastValidPosition() && el.inputmask._valueGet && el.inputmask._valueGet() === getBufferTemplate().join(\"\") && el.inputmask._valueSet(\"\"), opts.clearIncomplete && !1 === isComplete(getBuffer()) && el.inputmask._valueSet(\"\"), opts.removeMaskOnSubmit && (el.inputmask._valueSet(el.inputmask.unmaskedvalue(), !0), setTimeout(function () { writeBuffer(el, getBuffer()) }, 0)) }, resetEvent: function resetEvent() { el.inputmask.refreshValue = !0, setTimeout(function () { applyInputValue(el, el.inputmask._valueGet(!0)) }, 0) } }, valueBuffer; function checkVal(input, writeOut, strict, nptvl, initiatingEvent) { var inputmask = this || input.inputmask, inputValue = nptvl.slice(), charCodes = \"\", initialNdx = -1, result = void 0; function isTemplateMatch(ndx, charCodes) { for (var targetTemplate = getMaskTemplate(!0, 0).slice(ndx, seekNext(ndx)).join(\"\").replace(/'/g, \"\"), charCodeNdx = targetTemplate.indexOf(charCodes); 0 < charCodeNdx && \" \" === targetTemplate[charCodeNdx - 1];)charCodeNdx--; var match = 0 === charCodeNdx && !isMask(ndx) && (getTest(ndx).match.nativeDef === charCodes.charAt(0) || !0 === getTest(ndx).match.static && getTest(ndx).match.nativeDef === \"'\" + charCodes.charAt(0) || \" \" === getTest(ndx).match.nativeDef && (getTest(ndx + 1).match.nativeDef === charCodes.charAt(0) || !0 === getTest(ndx + 1).match.static && getTest(ndx + 1).match.nativeDef === \"'\" + charCodes.charAt(0))); if (!match && 0 < charCodeNdx && !isMask(ndx, !1, !0)) { var nextPos = seekNext(ndx); inputmask.caretPos.begin < nextPos && (inputmask.caretPos = { begin: nextPos }) } return match } resetMaskSet(), maskset.tests = {}, initialNdx = opts.radixPoint ? determineNewCaretPosition({ begin: 0, end: 0 }).begin : 0, maskset.p = initialNdx, inputmask.caretPos = { begin: initialNdx }; var staticMatches = [], prevCaretPos = inputmask.caretPos; if ($.each(inputValue, function (ndx, charCode) { if (void 0 !== charCode) if (void 0 === maskset.validPositions[ndx] && inputValue[ndx] === getPlaceholder(ndx) && isMask(ndx, !0) && !1 === isValid(ndx, inputValue[ndx], !0, void 0, void 0, !0)) maskset.p++; else { var keypress = new $.Event(\"_checkval\"); keypress.which = charCode.toString().charCodeAt(0), charCodes += charCode; var lvp = getLastValidPosition(void 0, !0); isTemplateMatch(initialNdx, charCodes) ? result = EventHandlers.keypressEvent.call(input, keypress, !0, !1, strict, lvp + 1) : (result = EventHandlers.keypressEvent.call(input, keypress, !0, !1, strict, inputmask.caretPos.begin), result && (initialNdx = inputmask.caretPos.begin + 1, charCodes = \"\")), result ? (void 0 !== result.pos && maskset.validPositions[result.pos] && !0 === maskset.validPositions[result.pos].match.static && void 0 === maskset.validPositions[result.pos].alternation && (staticMatches.push(result.pos), isRTL || (result.forwardPosition = result.pos + 1)), writeBuffer(void 0, getBuffer(), result.forwardPosition, keypress, !1), inputmask.caretPos = { begin: result.forwardPosition, end: result.forwardPosition }, prevCaretPos = inputmask.caretPos) : inputmask.caretPos = prevCaretPos } }), 0 < staticMatches.length) { var sndx, validPos, nextValid = seekNext(-1, void 0, !1); if (!isComplete(getBuffer()) && staticMatches.length <= nextValid || isComplete(getBuffer()) && 0 < staticMatches.length && staticMatches.length !== nextValid && 0 === staticMatches[0]) for (var nextSndx = nextValid; void 0 !== (sndx = staticMatches.shift());) { var keypress = new $.Event(\"_checkval\"); if (validPos = maskset.validPositions[sndx], validPos.generatedInput = !0, keypress.which = validPos.input.charCodeAt(0), result = EventHandlers.keypressEvent.call(input, keypress, !0, !1, strict, nextSndx), result && void 0 !== result.pos && result.pos !== sndx && maskset.validPositions[result.pos] && !0 === maskset.validPositions[result.pos].match.static) staticMatches.push(result.pos); else if (!result) break; nextSndx++ } else for (; sndx = staticMatches.pop();)validPos = maskset.validPositions[sndx], validPos && (validPos.generatedInput = !0) } if (writeOut) for (var vndx in writeBuffer(input, getBuffer(), result ? result.forwardPosition : void 0, initiatingEvent || new $.Event(\"checkval\"), initiatingEvent && \"input\" === initiatingEvent.type), maskset.validPositions) !0 !== maskset.validPositions[vndx].match.generated && delete maskset.validPositions[vndx].generatedInput } function unmaskedvalue(input) { if (input) { if (void 0 === input.inputmask) return input.value; input.inputmask && input.inputmask.refreshValue && applyInputValue(input, input.inputmask._valueGet(!0)) } var umValue = [], vps = maskset.validPositions; for (var pndx in vps) vps[pndx] && vps[pndx].match && (1 != vps[pndx].match.static || !0 !== vps[pndx].generatedInput) && umValue.push(vps[pndx].input); var unmaskedValue = 0 === umValue.length ? \"\" : (isRTL ? umValue.reverse() : umValue).join(\"\"); if ($.isFunction(opts.onUnMask)) { var bufferValue = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join(\"\"); unmaskedValue = opts.onUnMask.call(inputmask, bufferValue, unmaskedValue, opts) } return unmaskedValue } function translatePosition(pos) { return !isRTL || \"number\" != typeof pos || opts.greedy && \"\" === opts.placeholder || !el || (pos = el.inputmask._valueGet().length - pos), pos } function caret(input, begin, end, notranslate, isDelete) { var range; if (void 0 === begin) return \"selectionStart\" in input && \"selectionEnd\" in input ? (begin = input.selectionStart, end = input.selectionEnd) : window.getSelection ? (range = window.getSelection().getRangeAt(0), range.commonAncestorContainer.parentNode !== input && range.commonAncestorContainer !== input || (begin = range.startOffset, end = range.endOffset)) : document.selection && document.selection.createRange && (range = document.selection.createRange(), begin = 0 - range.duplicate().moveStart(\"character\", -input.inputmask._valueGet().length), end = begin + range.text.length), { begin: notranslate ? begin : translatePosition(begin), end: notranslate ? end : translatePosition(end) }; if ($.isArray(begin) && (end = isRTL ? begin[0] : begin[1], begin = isRTL ? begin[1] : begin[0]), void 0 !== begin.begin && (end = isRTL ? begin.begin : begin.end, begin = isRTL ? begin.end : begin.begin), \"number\" == typeof begin) { begin = notranslate ? begin : translatePosition(begin), end = notranslate ? end : translatePosition(end), end = \"number\" == typeof end ? end : begin; var scrollCalc = parseInt(((input.ownerDocument.defaultView || window).getComputedStyle ? (input.ownerDocument.defaultView || window).getComputedStyle(input, null) : input.currentStyle).fontSize) * end; if (input.scrollLeft = scrollCalc > input.scrollWidth ? scrollCalc : 0, input.inputmask.caretPos = { begin: begin, end: end }, opts.insertModeVisual && !1 === opts.insertMode && begin === end && (isDelete || end++), input === (input.inputmask.shadowRoot || document).activeElement) if (\"setSelectionRange\" in input) input.setSelectionRange(begin, end); else if (window.getSelection) { if (range = document.createRange(), void 0 === input.firstChild || null === input.firstChild) { var textNode = document.createTextNode(\"\"); input.appendChild(textNode) } range.setStart(input.firstChild, begin < input.inputmask._valueGet().length ? begin : input.inputmask._valueGet().length), range.setEnd(input.firstChild, end < input.inputmask._valueGet().length ? end : input.inputmask._valueGet().length), range.collapse(!0); var sel = window.getSelection(); sel.removeAllRanges(), sel.addRange(range) } else input.createTextRange && (range = input.createTextRange(), range.collapse(!0), range.moveEnd(\"character\", end), range.moveStart(\"character\", begin), range.select()) } } function determineLastRequiredPosition(returnDefinition) { var buffer = getMaskTemplate(!0, getLastValidPosition(), !0, !0), bl = buffer.length, pos, lvp = getLastValidPosition(), positions = {}, lvTest = maskset.validPositions[lvp], ndxIntlzr = void 0 !== lvTest ? lvTest.locator.slice() : void 0, testPos; for (pos = lvp + 1; pos < buffer.length; pos++)testPos = getTestTemplate(pos, ndxIntlzr, pos - 1), ndxIntlzr = testPos.locator.slice(), positions[pos] = $.extend(!0, {}, testPos); var lvTestAlt = lvTest && void 0 !== lvTest.alternation ? lvTest.locator[lvTest.alternation] : void 0; for (pos = bl - 1; lvp < pos && (testPos = positions[pos], (testPos.match.optionality || testPos.match.optionalQuantifier && testPos.match.newBlockMarker || lvTestAlt && (lvTestAlt !== positions[pos].locator[lvTest.alternation] && 1 != testPos.match.static || !0 === testPos.match.static && testPos.locator[lvTest.alternation] && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(\",\"), lvTestAlt.toString().split(\",\")) && \"\" !== getTests(pos)[0].def)) && buffer[pos] === getPlaceholder(pos, testPos.match)); pos--)bl--; return returnDefinition ? { l: bl, def: positions[bl] ? positions[bl].match : void 0 } : bl } function clearOptionalTail(buffer) { buffer.length = 0; for (var template = getMaskTemplate(!0, 0, !0, void 0, !0), lmnt; void 0 !== (lmnt = template.shift());)buffer.push(lmnt); return buffer } function isComplete(buffer) { if ($.isFunction(opts.isComplete)) return opts.isComplete(buffer, opts); if (\"*\" !== opts.repeat) { var complete = !1, lrp = determineLastRequiredPosition(!0), aml = seekPrevious(lrp.l); if (void 0 === lrp.def || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) { complete = !0; for (var i = 0; i <= aml; i++) { var test = getTestTemplate(i).match; if (!0 !== test.static && void 0 === maskset.validPositions[i] && !0 !== test.optionality && !0 !== test.optionalQuantifier || !0 === test.static && buffer[i] !== getPlaceholder(i, test)) { complete = !1; break } } } return complete } } function handleRemove(input, k, pos, strict, fromIsValid) { if ((opts.numericInput || isRTL) && (k === keyCode.BACKSPACE ? k = keyCode.DELETE : k === keyCode.DELETE && (k = keyCode.BACKSPACE), isRTL)) { var pend = pos.end; pos.end = pos.begin, pos.begin = pend } var lvp = getLastValidPosition(void 0, !0), offset; if (pos.end >= getBuffer().length && lvp >= pos.end && (pos.end = lvp + 1), k === keyCode.BACKSPACE ? pos.end - pos.begin < 1 && (pos.begin = seekPrevious(pos.begin)) : k === keyCode.DELETE && pos.begin === pos.end && (pos.end = isMask(pos.end, !0, !0) ? pos.end + 1 : seekNext(pos.end) + 1), !1 !== (offset = revalidateMask(pos))) { if (!0 !== strict && !1 !== opts.keepStatic || null !== opts.regex && -1 !== getTest(pos.begin).match.def.indexOf(\"|\")) { var result = alternate(!0); if (result) { var newPos = void 0 !== result.caret ? result.caret : result.pos ? seekNext(result.pos.begin ? result.pos.begin : result.pos) : getLastValidPosition(-1, !0); (k !== keyCode.DELETE || pos.begin > newPos) && pos.begin } } !0 !== strict && (maskset.p = k === keyCode.DELETE ? pos.begin + offset : pos.begin) } } function applyInputValue(input, value) { input.inputmask.refreshValue = !1, $.isFunction(opts.onBeforeMask) && (value = opts.onBeforeMask.call(inputmask, value, opts) || value), value = value.toString().split(\"\"), checkVal(input, !0, !1, value), undoValue = getBuffer().join(\"\"), (opts.clearMaskOnLostFocus || opts.clearIncomplete) && input.inputmask._valueGet() === getBufferTemplate().join(\"\") && -1 === getLastValidPosition() && input.inputmask._valueSet(\"\") } function mask(elem) { function isElementTypeSupported(input, opts) { function patchValueProperty(npt) { var valueGet, valueSet; function patchValhook(type) { if ($.valHooks && (void 0 === $.valHooks[type] || !0 !== $.valHooks[type].inputmaskpatch)) { var valhookGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function (elem) { return elem.value }, valhookSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function (elem, value) { return elem.value = value, elem }; $.valHooks[type] = { get: function get(elem) { if (elem.inputmask) { if (elem.inputmask.opts.autoUnmask) return elem.inputmask.unmaskedvalue(); var result = valhookGet(elem); return -1 !== getLastValidPosition(void 0, void 0, elem.inputmask.maskset.validPositions) || !0 !== opts.nullable ? result : \"\" } return valhookGet(elem) }, set: function set(elem, value) { var result = valhookSet(elem, value); return elem.inputmask && applyInputValue(elem, value), result }, inputmaskpatch: !0 } } } function getter() { return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : -1 !== getLastValidPosition() || !0 !== opts.nullable ? (this.inputmask.shadowRoot || document.activeElement) === this && opts.clearMaskOnLostFocus ? (isRTL ? clearOptionalTail(getBuffer().slice()).reverse() : clearOptionalTail(getBuffer().slice())).join(\"\") : valueGet.call(this) : \"\" : valueGet.call(this) } function setter(value) { valueSet.call(this, value), this.inputmask && applyInputValue(this, value) } function installNativeValueSetFallback(npt) { EventRuler.on(npt, \"mouseenter\", function () { var input = this, value = this.inputmask._valueGet(!0); value !== (isRTL ? getBuffer().reverse() : getBuffer()).join(\"\") && applyInputValue(this, value) }) } if (!npt.inputmask.__valueGet) { if (!0 !== opts.noValuePatching) { if (Object.getOwnPropertyDescriptor) { \"function\" != typeof Object.getPrototypeOf && (Object.getPrototypeOf = \"object\" === _typeof(\"test\".__proto__) ? function (object) { return object.__proto__ } : function (object) { return object.constructor.prototype }); var valueProperty = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(npt), \"value\") : void 0; valueProperty && valueProperty.get && valueProperty.set ? (valueGet = valueProperty.get, valueSet = valueProperty.set, Object.defineProperty(npt, \"value\", { get: getter, set: setter, configurable: !0 })) : \"input\" !== npt.tagName.toLowerCase() && (valueGet = function valueGet() { return this.textContent }, valueSet = function valueSet(value) { this.textContent = value }, Object.defineProperty(npt, \"value\", { get: getter, set: setter, configurable: !0 })) } else document.__lookupGetter__ && npt.__lookupGetter__(\"value\") && (valueGet = npt.__lookupGetter__(\"value\"), valueSet = npt.__lookupSetter__(\"value\"), npt.__defineGetter__(\"value\", getter), npt.__defineSetter__(\"value\", setter)); npt.inputmask.__valueGet = valueGet, npt.inputmask.__valueSet = valueSet } npt.inputmask._valueGet = function (overruleRTL) { return isRTL && !0 !== overruleRTL ? valueGet.call(this.el).split(\"\").reverse().join(\"\") : valueGet.call(this.el) }, npt.inputmask._valueSet = function (value, overruleRTL) { valueSet.call(this.el, null == value ? \"\" : !0 !== overruleRTL && isRTL ? value.split(\"\").reverse().join(\"\") : value) }, void 0 === valueGet && (valueGet = function valueGet() { return this.value }, valueSet = function valueSet(value) { this.value = value }, patchValhook(npt.type), installNativeValueSetFallback(npt)) } } \"textarea\" !== input.tagName.toLowerCase() && opts.ignorables.push(keyCode.ENTER); var elementType = input.getAttribute(\"type\"), isSupported = \"input\" === input.tagName.toLowerCase() && -1 !== $.inArray(elementType, opts.supportsInputType) || input.isContentEditable || \"textarea\" === input.tagName.toLowerCase(); if (!isSupported) if (\"input\" === input.tagName.toLowerCase()) { var el = document.createElement(\"input\"); el.setAttribute(\"type\", elementType), isSupported = \"text\" === el.type, el = null } else isSupported = \"partial\"; return !1 !== isSupported ? patchValueProperty(input) : input.inputmask = void 0, isSupported } EventRuler.off(elem); var isSupported = isElementTypeSupported(elem, opts); if (!1 !== isSupported) { el = elem, $el = $(el), originalPlaceholder = el.placeholder, maxLength = void 0 !== el ? el.maxLength : void 0, -1 === maxLength && (maxLength = void 0), \"inputMode\" in el && null === el.getAttribute(\"inputmode\") && (el.inputMode = opts.inputmode, el.setAttribute(\"inputmode\", opts.inputmode)), !0 === isSupported && (opts.showMaskOnFocus = opts.showMaskOnFocus && -1 === [\"cc-number\", \"cc-exp\"].indexOf(el.autocomplete), iphone && (opts.insertModeVisual = !1), EventRuler.on(el, \"submit\", EventHandlers.submitEvent), EventRuler.on(el, \"reset\", EventHandlers.resetEvent), EventRuler.on(el, \"blur\", EventHandlers.blurEvent), EventRuler.on(el, \"focus\", EventHandlers.focusEvent), EventRuler.on(el, \"invalid\", EventHandlers.invalidEvent), EventRuler.on(el, \"click\", EventHandlers.clickEvent), EventRuler.on(el, \"mouseleave\", EventHandlers.mouseleaveEvent), EventRuler.on(el, \"mouseenter\", EventHandlers.mouseenterEvent), EventRuler.on(el, \"paste\", EventHandlers.pasteEvent), EventRuler.on(el, \"cut\", EventHandlers.cutEvent), EventRuler.on(el, \"complete\", opts.oncomplete), EventRuler.on(el, \"incomplete\", opts.onincomplete), EventRuler.on(el, \"cleared\", opts.oncleared), mobile || !0 === opts.inputEventOnly ? el.removeAttribute(\"maxLength\") : (EventRuler.on(el, \"keydown\", EventHandlers.keydownEvent), EventRuler.on(el, \"keypress\", EventHandlers.keypressEvent)), EventRuler.on(el, \"input\", EventHandlers.inputFallBackEvent), EventRuler.on(el, \"compositionend\", EventHandlers.compositionendEvent)), EventRuler.on(el, \"setvalue\", EventHandlers.setValueEvent), undoValue = getBufferTemplate().join(\"\"); var activeElement = (el.inputmask.shadowRoot || document).activeElement; if (\"\" !== el.inputmask._valueGet(!0) || !1 === opts.clearMaskOnLostFocus || activeElement === el) { applyInputValue(el, el.inputmask._valueGet(!0), opts); var buffer = getBuffer().slice(); !1 === isComplete(buffer) && opts.clearIncomplete && resetMaskSet(), opts.clearMaskOnLostFocus && activeElement !== el && (-1 === getLastValidPosition() ? buffer = [] : clearOptionalTail(buffer)), (!1 === opts.clearMaskOnLostFocus || opts.showMaskOnFocus && activeElement === el || \"\" !== el.inputmask._valueGet(!0)) && writeBuffer(el, buffer), activeElement === el && caret(el, seekNext(getLastValidPosition())) } } } if (void 0 !== actionObj) switch (actionObj.action) { case \"isComplete\": return el = actionObj.el, isComplete(getBuffer()); case \"unmaskedvalue\": return void 0 !== el && void 0 === actionObj.value || (valueBuffer = actionObj.value, valueBuffer = ($.isFunction(opts.onBeforeMask) && opts.onBeforeMask.call(inputmask, valueBuffer, opts) || valueBuffer).split(\"\"), checkVal.call(this, void 0, !1, !1, valueBuffer), $.isFunction(opts.onBeforeWrite) && opts.onBeforeWrite.call(inputmask, void 0, getBuffer(), 0, opts)), unmaskedvalue(el); case \"mask\": mask(el); break; case \"format\": return valueBuffer = ($.isFunction(opts.onBeforeMask) && opts.onBeforeMask.call(inputmask, actionObj.value, opts) || actionObj.value).split(\"\"), checkVal.call(this, void 0, !0, !1, valueBuffer), actionObj.metadata ? { value: isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\"), metadata: maskScope.call(this, { action: \"getmetadata\" }, maskset, opts) } : isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\"); case \"isValid\": actionObj.value ? (valueBuffer = ($.isFunction(opts.onBeforeMask) && opts.onBeforeMask.call(inputmask, actionObj.value, opts) || actionObj.value).split(\"\"), checkVal.call(this, void 0, !0, !1, valueBuffer)) : actionObj.value = isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\"); for (var buffer = getBuffer(), rl = determineLastRequiredPosition(), lmib = buffer.length - 1; rl < lmib && !isMask(lmib); lmib--); return buffer.splice(rl, lmib + 1 - rl), isComplete(buffer) && actionObj.value === (isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\")); case \"getemptymask\": return getBufferTemplate().join(\"\"); case \"remove\": if (el && el.inputmask) { $.data(el, \"_inputmask_opts\", null), $el = $(el); var cv = opts.autoUnmask ? unmaskedvalue(el) : el.inputmask._valueGet(opts.autoUnmask), valueProperty; cv !== getBufferTemplate().join(\"\") ? el.inputmask._valueSet(cv, opts.autoUnmask) : el.inputmask._valueSet(\"\"), EventRuler.off(el), Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? (valueProperty = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(el), \"value\"), valueProperty && el.inputmask.__valueGet && Object.defineProperty(el, \"value\", { get: el.inputmask.__valueGet, set: el.inputmask.__valueSet, configurable: !0 })) : document.__lookupGetter__ && el.__lookupGetter__(\"value\") && el.inputmask.__valueGet && (el.__defineGetter__(\"value\", el.inputmask.__valueGet), el.__defineSetter__(\"value\", el.inputmask.__valueSet)), el.inputmask = void 0 } return el; case \"getmetadata\": if ($.isArray(maskset.metadata)) { var maskTarget = getMaskTemplate(!0, 0, !1).join(\"\"); return $.each(maskset.metadata, function (ndx, mtdt) { if (mtdt.mask === maskTarget) return maskTarget = mtdt, !1 }), maskTarget } return maskset.metadata } } }, function (module, exports, __nested_webpack_require_103900__) { \"use strict\"; function _typeof(obj) { return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function _typeof(obj) { return typeof obj } : function _typeof(obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj }, _typeof(obj) } var Inputmask = __nested_webpack_require_103900__(1), $ = Inputmask.dependencyLib, keyCode = __nested_webpack_require_103900__(0), formatCode = { d: [\"[1-9]|[12][0-9]|3[01]\", Date.prototype.setDate, \"day\", Date.prototype.getDate], dd: [\"0[1-9]|[12][0-9]|3[01]\", Date.prototype.setDate, \"day\", function () { return pad(Date.prototype.getDate.call(this), 2) }], ddd: [\"\"], dddd: [\"\"], m: [\"[1-9]|1[012]\", Date.prototype.setMonth, \"month\", function () { return Date.prototype.getMonth.call(this) + 1 }], mm: [\"0[1-9]|1[012]\", Date.prototype.setMonth, \"month\", function () { return pad(Date.prototype.getMonth.call(this) + 1, 2) }], mmm: [\"\"], mmmm: [\"\"], yy: [\"[0-9]{2}\", Date.prototype.setFullYear, \"year\", function () { return pad(Date.prototype.getFullYear.call(this), 2) }], yyyy: [\"[0-9]{4}\", Date.prototype.setFullYear, \"year\", function () { return pad(Date.prototype.getFullYear.call(this), 4) }], h: [\"[1-9]|1[0-2]\", Date.prototype.setHours, \"hours\", Date.prototype.getHours], hh: [\"0[1-9]|1[0-2]\", Date.prototype.setHours, \"hours\", function () { return pad(Date.prototype.getHours.call(this), 2) }], hx: [function (x) { return \"[0-9]{\".concat(x, \"}\") }, Date.prototype.setHours, \"hours\", function (x) { return Date.prototype.getHours }], H: [\"1?[0-9]|2[0-3]\", Date.prototype.setHours, \"hours\", Date.prototype.getHours], HH: [\"0[0-9]|1[0-9]|2[0-3]\", Date.prototype.setHours, \"hours\", function () { return pad(Date.prototype.getHours.call(this), 2) }], Hx: [function (x) { return \"[0-9]{\".concat(x, \"}\") }, Date.prototype.setHours, \"hours\", function (x) { return function () { return pad(Date.prototype.getHours.call(this), x) } }], M: [\"[1-5]?[0-9]\", Date.prototype.setMinutes, \"minutes\", Date.prototype.getMinutes], MM: [\"0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]\", Date.prototype.setMinutes, \"minutes\", function () { return pad(Date.prototype.getMinutes.call(this), 2) }], s: [\"[1-5]?[0-9]\", Date.prototype.setSeconds, \"seconds\", Date.prototype.getSeconds], ss: [\"0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]\", Date.prototype.setSeconds, \"seconds\", function () { return pad(Date.prototype.getSeconds.call(this), 2) }], l: [\"[0-9]{3}\", Date.prototype.setMilliseconds, \"milliseconds\", function () { return pad(Date.prototype.getMilliseconds.call(this), 3) }], L: [\"[0-9]{2}\", Date.prototype.setMilliseconds, \"milliseconds\", function () { return pad(Date.prototype.getMilliseconds.call(this), 2) }], t: [\"[ap]\"], tt: [\"[ap]m\"], T: [\"[AP]\"], TT: [\"[AP]M\"], Z: [\"\"], o: [\"\"], S: [\"\"] }, formatAlias = { isoDate: \"yyyy-mm-dd\", isoTime: \"HH:MM:ss\", isoDateTime: \"yyyy-mm-dd'T'HH:MM:ss\", isoUtcDateTime: \"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'\" }; function formatcode(match) { var dynMatches = new RegExp(\"\\\\d+$\").exec(match[0]); if (dynMatches && void 0 !== dynMatches[0]) { var fcode = formatCode[match[0][0] + \"x\"].slice(\"\"); return fcode[0] = fcode[0](dynMatches[0]), fcode[3] = fcode[3](dynMatches[0]), fcode } if (formatCode[match[0]]) return formatCode[match[0]] } function getTokenizer(opts) { if (!opts.tokenizer) { var tokens = [], dyntokens = []; for (var ndx in formatCode) if (/\\.*x$/.test(ndx)) { var dynToken = ndx[0] + \"\\\\d+\"; -1 === dyntokens.indexOf(dynToken) && dyntokens.push(dynToken) } else -1 === tokens.indexOf(ndx[0]) && tokens.push(ndx[0]); opts.tokenizer = \"(\" + (0 < dyntokens.length ? dyntokens.join(\"|\") + \"|\" : \"\") + tokens.join(\"+|\") + \")+?|.\", opts.tokenizer = new RegExp(opts.tokenizer, \"g\") } return opts.tokenizer } function isValidDate(dateParts, currentResult) { return (!isFinite(dateParts.rawday) || \"29\" == dateParts.day && !isFinite(dateParts.rawyear) || new Date(dateParts.date.getFullYear(), isFinite(dateParts.rawmonth) ? dateParts.month : dateParts.date.getMonth() + 1, 0).getDate() >= dateParts.day) && currentResult } function isDateInRange(dateParts, opts) { var result = !0; if (opts.min) { if (dateParts.rawyear) { var rawYear = dateParts.rawyear.replace(/[^0-9]/g, \"\"), minYear = opts.min.year.substr(0, rawYear.length); result = minYear <= rawYear } dateParts.year === dateParts.rawyear && opts.min.date.getTime() == opts.min.date.getTime() && (result = opts.min.date.getTime() <= dateParts.date.getTime()) } return result && opts.max && opts.max.date.getTime() == opts.max.date.getTime() && (result = opts.max.date.getTime() >= dateParts.date.getTime()), result } function parse(format, dateObjValue, opts, raw) { var mask = \"\", match, fcode; for (getTokenizer(opts).lastIndex = 0; match = getTokenizer(opts).exec(format);)if (void 0 === dateObjValue) if (fcode = formatcode(match)) mask += \"(\" + fcode[0] + \")\"; else switch (match[0]) { case \"[\": mask += \"(\"; break; case \"]\": mask += \")?\"; break; default: mask += Inputmask.escapeRegex(match[0]) } else if (fcode = formatcode(match)) if (!0 !== raw && fcode[3]) { var getFn = fcode[3]; mask += getFn.call(dateObjValue.date) } else fcode[2] ? mask += dateObjValue[\"raw\" + fcode[2]] : mask += match[0]; else mask += match[0]; return mask } function pad(val, len) { for (val = String(val), len = len || 2; val.length < len;)val = \"0\" + val; return val } function analyseMask(maskString, format, opts) { var dateObj = { date: new Date(1, 0, 1) }, targetProp, mask = maskString, match, dateOperation; function extendProperty(value) { var correctedValue = value.replace(/[^0-9]/g, \"0\"); return correctedValue } function setValue(dateObj, value, opts) { dateObj[targetProp] = extendProperty(value), dateObj[\"raw\" + targetProp] = value, void 0 !== dateOperation && dateOperation.call(dateObj.date, \"month\" == targetProp ? parseInt(dateObj[targetProp]) - 1 : dateObj[targetProp]) } if (\"string\" == typeof mask) { for (getTokenizer(opts).lastIndex = 0; match = getTokenizer(opts).exec(format);) { var value = mask.slice(0, match[0].length); formatCode.hasOwnProperty(match[0]) && (targetProp = formatCode[match[0]][2], dateOperation = formatCode[match[0]][1], setValue(dateObj, value, opts)), mask = mask.slice(value.length) } return dateObj } if (mask && \"object\" === _typeof(mask) && mask.hasOwnProperty(\"date\")) return mask } function importDate(dateObj, opts) { var match, date = \"\"; for (getTokenizer(opts).lastIndex = 0; match = getTokenizer(opts).exec(opts.inputFormat);)\"d\" === match[0].charAt(0) ? date += pad(dateObj.getDate(), match[0].length) : \"m\" === match[0].charAt(0) ? date += pad(dateObj.getMonth() + 1, match[0].length) : \"yyyy\" === match[0] ? date += dateObj.getFullYear().toString() : \"y\" === match[0].charAt(0) && (date += pad(dateObj.getYear(), match[0].length)); return date } function getTokenMatch(pos, opts) { var calcPos = 0, targetMatch, match, matchLength = 0; for (getTokenizer(opts).lastIndex = 0; match = getTokenizer(opts).exec(opts.inputFormat);) { var dynMatches = new RegExp(\"\\\\d+$\").exec(match[0]); if (matchLength = dynMatches ? parseInt(dynMatches[0]) : match[0].length, calcPos += matchLength, pos <= calcPos) { targetMatch = match, match = getTokenizer(opts).exec(opts.inputFormat); break } } return { targetMatchIndex: calcPos - matchLength, nextMatch: match, targetMatch: targetMatch } } Inputmask.extendAliases({ datetime: { mask: function mask(opts) { return opts.numericInput = !1, formatCode.S = opts.i18n.ordinalSuffix.join(\"|\"), opts.inputFormat = formatAlias[opts.inputFormat] || opts.inputFormat, opts.displayFormat = formatAlias[opts.displayFormat] || opts.displayFormat || opts.inputFormat, opts.outputFormat = formatAlias[opts.outputFormat] || opts.outputFormat || opts.inputFormat, opts.placeholder = \"\" !== opts.placeholder ? opts.placeholder : opts.inputFormat.replace(/[[\\]]/, \"\"), opts.regex = parse(opts.inputFormat, void 0, opts), opts.min = analyseMask(opts.min, opts.inputFormat, opts), opts.max = analyseMask(opts.max, opts.inputFormat, opts), null }, placeholder: \"\", inputFormat: \"isoDateTime\", displayFormat: void 0, outputFormat: void 0, min: null, max: null, skipOptionalPartCharacter: \"\", i18n: { dayNames: [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"], monthNames: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"], ordinalSuffix: [\"st\", \"nd\", \"rd\", \"th\"] }, preValidation: function preValidation(buffer, pos, c, isSelection, opts, maskset, caretPos, strict) { if (strict) return !0; if (isNaN(c) && buffer[pos] !== c) { var tokenMatch = getTokenMatch(pos, opts); if (tokenMatch.nextMatch && tokenMatch.nextMatch[0] === c && 1 < tokenMatch.targetMatch[0].length) { var validator = formatCode[tokenMatch.targetMatch[0]][0]; if (new RegExp(validator).test(\"0\" + buffer[pos - 1])) return buffer[pos] = buffer[pos - 1], buffer[pos - 1] = \"0\", { fuzzy: !0, buffer: buffer, refreshFromBuffer: { start: pos - 1, end: pos + 1 }, pos: pos + 1 } } } return !0 }, postValidation: function postValidation(buffer, pos, c, currentResult, opts, maskset, strict) { if (strict) return !0; var tokenMatch, validator; if (!1 === currentResult) return tokenMatch = getTokenMatch(pos + 1, opts), tokenMatch.targetMatch && tokenMatch.targetMatchIndex === pos && 1 < tokenMatch.targetMatch[0].length && void 0 !== formatCode[tokenMatch.targetMatch[0]] && (validator = formatCode[tokenMatch.targetMatch[0]][0], new RegExp(validator).test(\"0\" + c)) ? { insert: [{ pos: pos, c: \"0\" }, { pos: pos + 1, c: c }], pos: pos + 1 } : currentResult; if (currentResult.fuzzy && (buffer = currentResult.buffer, pos = currentResult.pos), tokenMatch = getTokenMatch(pos, opts), tokenMatch.targetMatch && tokenMatch.targetMatch[0] && void 0 !== formatCode[tokenMatch.targetMatch[0]]) { validator = formatCode[tokenMatch.targetMatch[0]][0]; var part = buffer.slice(tokenMatch.targetMatchIndex, tokenMatch.targetMatchIndex + tokenMatch.targetMatch[0].length); !1 === new RegExp(validator).test(part.join(\"\")) && 2 === tokenMatch.targetMatch[0].length && maskset.validPositions[tokenMatch.targetMatchIndex] && maskset.validPositions[tokenMatch.targetMatchIndex + 1] && (maskset.validPositions[tokenMatch.targetMatchIndex + 1].input = \"0\") } var result = currentResult, dateParts = analyseMask(buffer.join(\"\"), opts.inputFormat, opts); return result && dateParts.date.getTime() == dateParts.date.getTime() && (result = isValidDate(dateParts, result), result = result && isDateInRange(dateParts, opts)), pos && result && currentResult.pos !== pos ? { buffer: parse(opts.inputFormat, dateParts, opts).split(\"\"), refreshFromBuffer: { start: pos, end: currentResult.pos } } : result }, onKeyDown: function onKeyDown(e, buffer, caretPos, opts) { var input = this; e.ctrlKey && e.keyCode === keyCode.RIGHT && (this.inputmask._valueSet(importDate(new Date, opts)), $(this).trigger(\"setvalue\")) }, onUnMask: function onUnMask(maskedValue, unmaskedValue, opts) { return unmaskedValue ? parse(opts.outputFormat, analyseMask(maskedValue, opts.inputFormat, opts), opts, !0) : unmaskedValue }, casing: function casing(elem, test, pos, validPositions) { return 0 == test.nativeDef.indexOf(\"[ap]\") ? elem.toLowerCase() : 0 == test.nativeDef.indexOf(\"[AP]\") ? elem.toUpperCase() : elem }, onBeforeMask: function onBeforeMask(initialValue, opts) { return \"[object Date]\" === Object.prototype.toString.call(initialValue) && (initialValue = importDate(initialValue, opts)), initialValue }, insertMode: !1, shiftPositions: !1, keepStatic: !1, inputmode: \"numeric\" } }), module.exports = Inputmask }, function (module, exports, __nested_webpack_require_115687__) { \"use strict\"; var Inputmask = __nested_webpack_require_115687__(1), $ = Inputmask.dependencyLib, keyCode = __nested_webpack_require_115687__(0); function autoEscape(txt, opts) { for (var escapedTxt = \"\", i = 0; i < txt.length; i++)Inputmask.prototype.definitions[txt.charAt(i)] || opts.definitions[txt.charAt(i)] || opts.optionalmarker[0] === txt.charAt(i) || opts.optionalmarker[1] === txt.charAt(i) || opts.quantifiermarker[0] === txt.charAt(i) || opts.quantifiermarker[1] === txt.charAt(i) || opts.groupmarker[0] === txt.charAt(i) || opts.groupmarker[1] === txt.charAt(i) || opts.alternatormarker === txt.charAt(i) ? escapedTxt += \"\\\\\" + txt.charAt(i) : escapedTxt += txt.charAt(i); return escapedTxt } function alignDigits(buffer, digits, opts, force) { if (0 < buffer.length && 0 < digits && (!opts.digitsOptional || force)) { var radixPosition = $.inArray(opts.radixPoint, buffer); -1 === radixPosition && (buffer.push(opts.radixPoint), radixPosition = buffer.length - 1); for (var i = 1; i <= digits; i++)isFinite(buffer[radixPosition + i]) || (buffer[radixPosition + i] = \"0\") } return buffer } function findValidator(symbol, maskset) { var posNdx = 0; if (\"+\" === symbol) { for (posNdx in maskset.validPositions); posNdx = parseInt(posNdx) } for (var tstNdx in maskset.tests) if (tstNdx = parseInt(tstNdx), posNdx <= tstNdx) for (var ndx = 0, ndxl = maskset.tests[tstNdx].length; ndx < ndxl; ndx++)if ((void 0 === maskset.validPositions[tstNdx] || \"-\" === symbol) && maskset.tests[tstNdx][ndx].match.def === symbol) return tstNdx + (void 0 !== maskset.validPositions[tstNdx] && \"-\" !== symbol ? 1 : 0); return posNdx } function findValid(symbol, maskset) { var ret = -1; return $.each(maskset.validPositions, function (ndx, tst) { if (tst && tst.match.def === symbol) return ret = parseInt(ndx), !1 }), ret } function parseMinMaxOptions(opts) { void 0 === opts.parseMinMaxOptions && (null !== opts.min && (opts.min = opts.min.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\"), \",\" === opts.radixPoint && (opts.min = opts.min.replace(opts.radixPoint, \".\")), opts.min = isFinite(opts.min) ? parseFloat(opts.min) : NaN, isNaN(opts.min) && (opts.min = Number.MIN_VALUE)), null !== opts.max && (opts.max = opts.max.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\"), \",\" === opts.radixPoint && (opts.max = opts.max.replace(opts.radixPoint, \".\")), opts.max = isFinite(opts.max) ? parseFloat(opts.max) : NaN, isNaN(opts.max) && (opts.max = Number.MAX_VALUE)), opts.parseMinMaxOptions = \"done\") } function genMask(opts) { opts.repeat = 0, opts.groupSeparator === opts.radixPoint && opts.digits && \"0\" !== opts.digits && (\".\" === opts.radixPoint ? opts.groupSeparator = \",\" : \",\" === opts.radixPoint ? opts.groupSeparator = \".\" : opts.groupSeparator = \"\"), \" \" === opts.groupSeparator && (opts.skipOptionalPartCharacter = void 0), 1 < opts.placeholder.length && (opts.placeholder = opts.placeholder.charAt(0)), \"radixFocus\" === opts.positionCaretOnClick && \"\" === opts.placeholder && (opts.positionCaretOnClick = \"lvp\"); var decimalDef = \"0\", radixPointDef = opts.radixPoint; !0 === opts.numericInput && void 0 === opts.__financeInput ? (decimalDef = \"1\", opts.positionCaretOnClick = \"radixFocus\" === opts.positionCaretOnClick ? \"lvp\" : opts.positionCaretOnClick, opts.digitsOptional = !1, isNaN(opts.digits) && (opts.digits = 2), opts._radixDance = !1, radixPointDef = \",\" === opts.radixPoint ? \"?\" : \"!\", \"\" !== opts.radixPoint && void 0 === opts.definitions[radixPointDef] && (opts.definitions[radixPointDef] = {}, opts.definitions[radixPointDef].validator = \"[\" + opts.radixPoint + \"]\", opts.definitions[radixPointDef].placeholder = opts.radixPoint, opts.definitions[radixPointDef].static = !0, opts.definitions[radixPointDef].generated = !0)) : (opts.__financeInput = !1, opts.numericInput = !0); var mask = \"[+]\", altMask; if (mask += autoEscape(opts.prefix, opts), \"\" !== opts.groupSeparator ? (void 0 === opts.definitions[opts.groupSeparator] && (opts.definitions[opts.groupSeparator] = {}, opts.definitions[opts.groupSeparator].validator = \"[\" + opts.groupSeparator + \"]\", opts.definitions[opts.groupSeparator].placeholder = opts.groupSeparator, opts.definitions[opts.groupSeparator].static = !0, opts.definitions[opts.groupSeparator].generated = !0), mask += opts._mask(opts)) : mask += \"9{+}\", void 0 !== opts.digits && 0 !== opts.digits) { var dq = opts.digits.toString().split(\",\"); isFinite(dq[0]) && dq[1] && isFinite(dq[1]) ? mask += radixPointDef + decimalDef + \"{\" + opts.digits + \"}\" : (isNaN(opts.digits) || 0 < parseInt(opts.digits)) && (opts.digitsOptional ? (altMask = mask + radixPointDef + decimalDef + \"{0,\" + opts.digits + \"}\", opts.keepStatic = !0) : mask += radixPointDef + decimalDef + \"{\" + opts.digits + \"}\") } return mask += autoEscape(opts.suffix, opts), mask += \"[-]\", altMask && (mask = [altMask + autoEscape(opts.suffix, opts) + \"[-]\", mask]), opts.greedy = !1, parseMinMaxOptions(opts), mask } function hanndleRadixDance(pos, c, radixPos, maskset, opts) { return opts._radixDance && opts.numericInput && c !== opts.negationSymbol.back && pos <= radixPos && (0 < radixPos || c == opts.radixPoint) && (void 0 === maskset.validPositions[pos - 1] || maskset.validPositions[pos - 1].input !== opts.negationSymbol.back) && (pos -= 1), pos } function decimalValidator(chrs, maskset, pos, strict, opts) { var radixPos = maskset.buffer ? maskset.buffer.indexOf(opts.radixPoint) : -1, result = -1 !== radixPos && new RegExp(\"[0-9\\uff11-\\uff19]\").test(chrs); return opts._radixDance && result && null == maskset.validPositions[radixPos] ? { insert: { pos: radixPos === pos ? radixPos + 1 : radixPos, c: opts.radixPoint }, pos: pos } : result } function checkForLeadingZeroes(buffer, opts) { var numberMatches = new RegExp(\"(^\" + (\"\" !== opts.negationSymbol.front ? Inputmask.escapeRegex(opts.negationSymbol.front) + \"?\" : \"\") + Inputmask.escapeRegex(opts.prefix) + \")(.*)(\" + Inputmask.escapeRegex(opts.suffix) + (\"\" != opts.negationSymbol.back ? Inputmask.escapeRegex(opts.negationSymbol.back) + \"?\" : \"\") + \"$)\").exec(buffer.slice().reverse().join(\"\")), number = numberMatches ? numberMatches[2] : \"\", leadingzeroes = !1; return number && (number = number.split(opts.radixPoint.charAt(0))[0], leadingzeroes = new RegExp(\"^[0\" + opts.groupSeparator + \"]*\").exec(number)), !(!leadingzeroes || !(1 < leadingzeroes[0].length || 0 < leadingzeroes[0].length && leadingzeroes[0].length < number.length)) && leadingzeroes } Inputmask.extendAliases({ numeric: { mask: genMask, _mask: function _mask(opts) { return \"(\" + opts.groupSeparator + \"999){+|1}\" }, digits: \"*\", digitsOptional: !0, enforceDigitsOnBlur: !1, radixPoint: \".\", positionCaretOnClick: \"radixFocus\", _radixDance: !0, groupSeparator: \"\", allowMinus: !0, negationSymbol: { front: \"-\", back: \"\" }, prefix: \"\", suffix: \"\", min: null, max: null, step: 1, unmaskAsNumber: !1, roundingFN: Math.round, inputmode: \"numeric\", shortcuts: { k: \"000\", m: \"000000\" }, placeholder: \"0\", greedy: !1, rightAlign: !0, insertMode: !0, autoUnmask: !1, skipOptionalPartCharacter: \"\", definitions: { 0: { validator: decimalValidator }, 1: { validator: decimalValidator, definitionSymbol: \"9\" }, \"+\": { validator: function validator(chrs, maskset, pos, strict, opts) { return opts.allowMinus && (\"-\" === chrs || chrs === opts.negationSymbol.front) } }, \"-\": { validator: function validator(chrs, maskset, pos, strict, opts) { return opts.allowMinus && chrs === opts.negationSymbol.back } } }, preValidation: function preValidation(buffer, pos, c, isSelection, opts, maskset, caretPos, strict) { if (!1 !== opts.__financeInput && c === opts.radixPoint) return !1; var pattern; if (pattern = opts.shortcuts && opts.shortcuts[c]) { if (1 < pattern.length) for (var inserts = [], i = 0; i < pattern.length; i++)inserts.push({ pos: pos + i, c: pattern[i], strict: !1 }); return { insert: inserts } } var radixPos = $.inArray(opts.radixPoint, buffer), initPos = pos; if (pos = hanndleRadixDance(pos, c, radixPos, maskset, opts), \"-\" === c || c === opts.negationSymbol.front) { if (!0 !== opts.allowMinus) return !1; var isNegative = !1, front = findValid(\"+\", maskset), back = findValid(\"-\", maskset); return -1 !== front && (isNegative = [front, back]), !1 !== isNegative ? { remove: isNegative, caret: initPos } : { insert: [{ pos: findValidator(\"+\", maskset), c: opts.negationSymbol.front, fromIsValid: !0 }, { pos: findValidator(\"-\", maskset), c: opts.negationSymbol.back, fromIsValid: void 0 }], caret: initPos + opts.negationSymbol.back.length } } if (strict) return !0; if (-1 !== radixPos && !0 === opts._radixDance && !1 === isSelection && c === opts.radixPoint && void 0 !== opts.digits && (isNaN(opts.digits) || 0 < parseInt(opts.digits)) && radixPos !== pos) return { caret: opts._radixDance && pos === radixPos - 1 ? radixPos + 1 : radixPos }; if (!1 === opts.__financeInput) if (isSelection) { if (opts.digitsOptional) return { rewritePosition: caretPos.end }; if (!opts.digitsOptional) { if (caretPos.begin > radixPos && caretPos.end <= radixPos) return c === opts.radixPoint ? { insert: { pos: radixPos + 1, c: \"0\", fromIsValid: !0 }, rewritePosition: radixPos } : { rewritePosition: radixPos + 1 }; if (caretPos.begin < radixPos) return { rewritePosition: caretPos.begin - 1 } } } else if (!opts.showMaskOnHover && !opts.showMaskOnFocus && !opts.digitsOptional && 0 < opts.digits && \"\" === this.inputmask.__valueGet.call(this)) return { rewritePosition: radixPos }; return { rewritePosition: pos } }, postValidation: function postValidation(buffer, pos, c, currentResult, opts, maskset, strict) { if (!1 === currentResult) return currentResult; if (strict) return !0; if (null !== opts.min || null !== opts.max) { var unmasked = opts.onUnMask(buffer.slice().reverse().join(\"\"), void 0, $.extend({}, opts, { unmaskAsNumber: !0 })); if (null !== opts.min && unmasked < opts.min && (unmasked.toString().length >= opts.min.toString().length || unmasked < 0)) return !1; if (null !== opts.max && unmasked > opts.max) return !1 } return currentResult }, onUnMask: function onUnMask(maskedValue, unmaskedValue, opts) { if (\"\" === unmaskedValue && !0 === opts.nullable) return unmaskedValue; var processValue = maskedValue.replace(opts.prefix, \"\"); return processValue = processValue.replace(opts.suffix, \"\"), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\"), \"\" !== opts.placeholder.charAt(0) && (processValue = processValue.replace(new RegExp(opts.placeholder.charAt(0), \"g\"), \"0\")), opts.unmaskAsNumber ? (\"\" !== opts.radixPoint && -1 !== processValue.indexOf(opts.radixPoint) && (processValue = processValue.replace(Inputmask.escapeRegex.call(this, opts.radixPoint), \".\")), processValue = processValue.replace(new RegExp(\"^\" + Inputmask.escapeRegex(opts.negationSymbol.front)), \"-\"), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\"), Number(processValue)) : processValue }, isComplete: function isComplete(buffer, opts) { var maskedValue = (opts.numericInput ? buffer.slice().reverse() : buffer).join(\"\"); return maskedValue = maskedValue.replace(new RegExp(\"^\" + Inputmask.escapeRegex(opts.negationSymbol.front)), \"-\"), maskedValue = maskedValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\"), maskedValue = maskedValue.replace(opts.prefix, \"\"), maskedValue = maskedValue.replace(opts.suffix, \"\"), maskedValue = maskedValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator) + \"([0-9]{3})\", \"g\"), \"$1\"), \",\" === opts.radixPoint && (maskedValue = maskedValue.replace(Inputmask.escapeRegex(opts.radixPoint), \".\")), isFinite(maskedValue) }, onBeforeMask: function onBeforeMask(initialValue, opts) { var radixPoint = opts.radixPoint || \",\"; isFinite(opts.digits) && (opts.digits = parseInt(opts.digits)), \"number\" != typeof initialValue && \"number\" !== opts.inputType || \"\" === radixPoint || (initialValue = initialValue.toString().replace(\".\", radixPoint)); var valueParts = initialValue.split(radixPoint), integerPart = valueParts[0].replace(/[^\\-0-9]/g, \"\"), decimalPart = 1 < valueParts.length ? valueParts[1].replace(/[^0-9]/g, \"\") : \"\", forceDigits = 1 < valueParts.length; initialValue = integerPart + (\"\" !== decimalPart ? radixPoint + decimalPart : decimalPart); var digits = 0; if (\"\" !== radixPoint && (digits = opts.digitsOptional ? opts.digits < decimalPart.length ? opts.digits : decimalPart.length : opts.digits, \"\" !== decimalPart || !opts.digitsOptional)) { var digitsFactor = Math.pow(10, digits || 1); initialValue = initialValue.replace(Inputmask.escapeRegex(radixPoint), \".\"), isNaN(parseFloat(initialValue)) || (initialValue = (opts.roundingFN(parseFloat(initialValue) * digitsFactor) / digitsFactor).toFixed(digits)), initialValue = initialValue.toString().replace(\".\", radixPoint) } if (0 === opts.digits && -1 !== initialValue.indexOf(radixPoint) && (initialValue = initialValue.substring(0, initialValue.indexOf(radixPoint))), null !== opts.min || null !== opts.max) { var numberValue = initialValue.toString().replace(radixPoint, \".\"); null !== opts.min && numberValue < opts.min ? initialValue = opts.min.toString().replace(\".\", radixPoint) : null !== opts.max && numberValue > opts.max && (initialValue = opts.max.toString().replace(\".\", radixPoint)) } return alignDigits(initialValue.toString().split(\"\"), digits, opts, forceDigits).join(\"\") }, onBeforeWrite: function onBeforeWrite(e, buffer, caretPos, opts) { function stripBuffer(buffer, stripRadix) { if (!1 !== opts.__financeInput || stripRadix) { var position = $.inArray(opts.radixPoint, buffer); -1 !== position && buffer.splice(position, 1) } if (\"\" !== opts.groupSeparator) for (; -1 !== (position = buffer.indexOf(opts.groupSeparator));)buffer.splice(position, 1); return buffer } var result, leadingzeroes = checkForLeadingZeroes(buffer, opts); if (leadingzeroes) { var buf = buffer.slice().reverse(), caretNdx = buf.join(\"\").indexOf(leadingzeroes[0]); buf.splice(caretNdx, leadingzeroes[0].length); var newCaretPos = buf.length - caretNdx; stripBuffer(buf), result = { refreshFromBuffer: !0, buffer: buf.reverse(), caret: caretPos < newCaretPos ? caretPos : newCaretPos } } if (e) switch (e.type) { case \"blur\": case \"checkval\": if (null !== opts.min) { var unmasked = opts.onUnMask(buffer.slice().reverse().join(\"\"), void 0, $.extend({}, opts, { unmaskAsNumber: !0 })); if (null !== opts.min && unmasked < opts.min) return { refreshFromBuffer: !0, buffer: alignDigits(opts.min.toString().replace(\".\", opts.radixPoint).split(\"\"), opts.digits, opts).reverse() } } if (buffer[buffer.length - 1] === opts.negationSymbol.front) { var nmbrMtchs = new RegExp(\"(^\" + (\"\" != opts.negationSymbol.front ? Inputmask.escapeRegex(opts.negationSymbol.front) + \"?\" : \"\") + Inputmask.escapeRegex(opts.prefix) + \")(.*)(\" + Inputmask.escapeRegex(opts.suffix) + (\"\" != opts.negationSymbol.back ? Inputmask.escapeRegex(opts.negationSymbol.back) + \"?\" : \"\") + \"$)\").exec(stripBuffer(buffer.slice(), !0).reverse().join(\"\")), number = nmbrMtchs ? nmbrMtchs[2] : \"\"; 0 == number && (result = { refreshFromBuffer: !0, buffer: [0] }) } else \"\" !== opts.radixPoint && buffer[0] === opts.radixPoint && (result && result.buffer ? result.buffer.shift() : (buffer.shift(), result = { refreshFromBuffer: !0, buffer: stripBuffer(buffer) })); if (opts.enforceDigitsOnBlur) { result = result || {}; var bffr = result && result.buffer || buffer.slice().reverse(); result.refreshFromBuffer = !0, result.buffer = alignDigits(bffr, opts.digits, opts, !0).reverse() } }return result }, onKeyDown: function onKeyDown(e, buffer, caretPos, opts) { var $input = $(this), bffr; if (e.ctrlKey) switch (e.keyCode) { case keyCode.UP: return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) + parseInt(opts.step)), $input.trigger(\"setvalue\"), !1; case keyCode.DOWN: return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) - parseInt(opts.step)), $input.trigger(\"setvalue\"), !1 }if (!e.shiftKey && (e.keyCode === keyCode.DELETE || e.keyCode === keyCode.BACKSPACE || e.keyCode === keyCode.BACKSPACE_SAFARI) && caretPos.begin !== buffer.length) { if (buffer[e.keyCode === keyCode.DELETE ? caretPos.begin - 1 : caretPos.end] === opts.negationSymbol.front) return bffr = buffer.slice().reverse(), \"\" !== opts.negationSymbol.front && bffr.shift(), \"\" !== opts.negationSymbol.back && bffr.pop(), $input.trigger(\"setvalue\", [bffr.join(\"\"), caretPos.begin]), !1; if (!0 === opts._radixDance) { var radixPos = $.inArray(opts.radixPoint, buffer); if (opts.digitsOptional) { if (0 === radixPos) return bffr = buffer.slice().reverse(), bffr.pop(), $input.trigger(\"setvalue\", [bffr.join(\"\"), caretPos.begin >= bffr.length ? bffr.length : caretPos.begin]), !1 } else if (-1 !== radixPos && (caretPos.begin < radixPos || caretPos.end < radixPos || e.keyCode === keyCode.DELETE && caretPos.begin === radixPos)) return caretPos.begin !== caretPos.end || e.keyCode !== keyCode.BACKSPACE && e.keyCode !== keyCode.BACKSPACE_SAFARI || caretPos.begin++, bffr = buffer.slice().reverse(), bffr.splice(bffr.length - caretPos.begin, caretPos.begin - caretPos.end + 1), bffr = alignDigits(bffr, opts.digits, opts).join(\"\"), $input.trigger(\"setvalue\", [bffr, caretPos.begin >= bffr.length ? radixPos + 1 : caretPos.begin]), !1 } } } }, currency: { prefix: \"\", groupSeparator: \",\", alias: \"numeric\", digits: 2, digitsOptional: !1 }, decimal: { alias: \"numeric\" }, integer: { alias: \"numeric\", digits: 0 }, percentage: { alias: \"numeric\", min: 0, max: 100, suffix: \" %\", digits: 0, allowMinus: !1 }, indianns: { alias: \"numeric\", _mask: function _mask(opts) { return \"(\" + opts.groupSeparator + \"99){*|1}(\" + opts.groupSeparator + \"999){1|1}\" }, groupSeparator: \",\", radixPoint: \".\", placeholder: \"0\", digits: 2, digitsOptional: !1 } }), module.exports = Inputmask }, function (module, exports, __nested_webpack_require_133641__) { \"use strict\"; var _inputmask = _interopRequireDefault(__nested_webpack_require_133641__(1)); function _typeof(obj) { return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function _typeof(obj) { return typeof obj } : function _typeof(obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj }, _typeof(obj) } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) throw new TypeError(\"Cannot call a class as a function\") } function _possibleConstructorReturn(self, call) { return !call || \"object\" !== _typeof(call) && \"function\" != typeof call ? _assertThisInitialized(self) : call } function _assertThisInitialized(self) { if (void 0 === self) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return self } function _inherits(subClass, superClass) { if (\"function\" != typeof superClass && null !== superClass) throw new TypeError(\"Super expression must either be null or a function\"); subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass) } function _wrapNativeSuper(Class) { var _cache = \"function\" == typeof Map ? new Map : void 0; return _wrapNativeSuper = function _wrapNativeSuper(Class) { if (null === Class || !_isNativeFunction(Class)) return Class; if (\"function\" != typeof Class) throw new TypeError(\"Super expression must either be null or a function\"); if (\"undefined\" != typeof _cache) { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper) } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor) } return Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, Class) }, _wrapNativeSuper(Class) } function isNativeReflectConstruct() { if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (\"function\" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], function () { })), !0 } catch (e) { return !1 } } function _construct(Parent, args, Class) { return _construct = isNativeReflectConstruct() ? Reflect.construct : function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a), instance = new Constructor; return Class && _setPrototypeOf(instance, Class.prototype), instance }, _construct.apply(null, arguments) } function _isNativeFunction(fn) { return -1 !== Function.toString.call(fn).indexOf(\"[native code]\") } function _setPrototypeOf(o, p) { return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { return o.__proto__ = p, o }, _setPrototypeOf(o, p) } function _getPrototypeOf(o) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o) }, _getPrototypeOf(o) } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj } } if (document.head.createShadowRoot || document.head.attachShadow) { var InputmaskElement = function (_HTMLElement) { function InputmaskElement() { var _this; _classCallCheck(this, InputmaskElement), _this = _possibleConstructorReturn(this, _getPrototypeOf(InputmaskElement).call(this)); var attributeNames = _this.getAttributeNames(), shadow = _this.attachShadow({ mode: \"closed\" }), input = document.createElement(\"input\"); for (var attr in input.type = \"text\", shadow.appendChild(input), attributeNames) Object.prototype.hasOwnProperty.call(attributeNames, attr) && input.setAttribute(\"data-inputmask-\" + attributeNames[attr], _this.getAttribute(attributeNames[attr])); return (new _inputmask.default).mask(input), input.inputmask.shadowRoot = shadow, _this } return _inherits(InputmaskElement, _HTMLElement), InputmaskElement }(_wrapNativeSuper(HTMLElement)); customElements.define(\"input-mask\", InputmaskElement) } }], installedModules = {}, __nested_webpack_require_139278__.m = modules, __nested_webpack_require_139278__.c = installedModules, __nested_webpack_require_139278__.d = function (exports, name, getter) { __nested_webpack_require_139278__.o(exports, name) || Object.defineProperty(exports, name, { enumerable: !0, get: getter }) }, __nested_webpack_require_139278__.r = function (exports) { \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(exports, \"__esModule\", { value: !0 }) }, __nested_webpack_require_139278__.t = function (value, mode) { if (1 & mode && (value = __nested_webpack_require_139278__(value)), 8 & mode) return value; if (4 & mode && \"object\" == typeof value && value && value.__esModule) return value; var ns = Object.create(null); if (__nested_webpack_require_139278__.r(ns), Object.defineProperty(ns, \"default\", { enumerable: !0, value: value }), 2 & mode && \"string\" != typeof value) for (var key in value) __nested_webpack_require_139278__.d(ns, key, function (key) { return value[key] }.bind(null, key)); return ns }, __nested_webpack_require_139278__.n = function (module) { var getter = module && module.__esModule ? function getDefault() { return module.default } : function getModuleExports() { return module }; return __nested_webpack_require_139278__.d(getter, \"a\", getter), getter }, __nested_webpack_require_139278__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property) }, __nested_webpack_require_139278__.p = \"\", __nested_webpack_require_139278__(__nested_webpack_require_139278__.s = 5); function __nested_webpack_require_139278__(moduleId) { if (installedModules[moduleId]) return installedModules[moduleId].exports; var module = installedModules[moduleId] = { i: moduleId, l: !1, exports: {} }; return modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_139278__), module.l = !0, module.exports } var modules, installedModules });\n\nAOS.init();\n\nconst showHideMenuBtn = document.getElementById(\"show-hide-menu\")\n\nif (showHideMenuBtn) {\n    showHideMenuBtn.addEventListener(\"click\", () => {\n        document.documentElement.classList.toggle(\"_menu-active\")\n    })\n}\n\nconst mobileConsultationBtn = document.getElementById(\"consultation-button\")\n\nif (mobileConsultationBtn) {\n    mobileConsultationBtn.addEventListener(\"click\", function (e) {\n        document.documentElement.classList.remove(\"_menu-active\")\n    })\n}\n\nconst consultationForm = document.getElementById(\"consultation-form\")\n\nif (consultationForm) {\n    consultationForm.addEventListener(\"submit\", function (e) {\n        e.preventDefault()\n        document.getElementById(\"consultation\").classList.add(\"_form-sent\")\n    })\n}\n\nconst spoilers = document.querySelectorAll(\".spoiler\")\n\nif (spoilers.length) {\n    spoilers.forEach(spoiler => {\n        spoiler.addEventListener(\"click\", () => {\n            spoiler.classList.toggle(\"_spoiler-open\")\n        })\n    });\n}\n\n// работа с селектами\n\nconst selects = document.querySelectorAll(\".select\")\n\nif (selects.length) {\n\n    // console.log(selects)\n\n    selects.forEach(select => {\n        let openSelect = select.querySelector(\".open-select\")\n        let selectOptions = select.querySelectorAll(\"li.select__item[data-value]\")\n        const elementsForFilterWrapper = document.querySelector(\".filter-list\")\n\n        // console.log(openSelect, openSelect.parentNode)\n\n        openSelect.addEventListener(\"click\", () => {\n            openSelect.parentNode.classList.toggle(\"_open-select\")\n        })\n\n        selectOptions.forEach(option => {\n            option.addEventListener(\"click\", () => {\n                selectOptions.forEach(el => {\n                    el.classList.remove(\"_selected\")\n                })\n\n                let currentValue = select.querySelector(\".current-value\")\n                const currentSelectValue = option.dataset.value\n\n                currentValue.dataset.current = currentSelectValue\n                currentValue.textContent = currentSelectValue\n                openSelect.parentNode.classList.remove(\"_open-select\")\n                option.classList.add(\"_selected\")\n\n                if (elementsForFilterWrapper) {\n                    const elements = elementsForFilterWrapper.querySelectorAll(\"[data-category]\")\n\n                    if (elements.length) {\n                        elements.forEach(element => {\n                            element.classList.remove(\"_hidden\")\n                            if (option.getAttribute(\"data-category\") != 0) {\n                                if (element.getAttribute(\"data-category\") != option.getAttribute(\"data-category\")) {\n                                    element.classList.add(\"_hidden\")\n                                }\n                            }\n                        });\n                    }\n                }\n            })\n        });\n\n    });\n}\n\n// const filterItems = function(data) {\n//     const elements = document.querySelectorAll(\"[data-category]\")\n//     elements.forEach(element => {\n//         element.style.display.none\n//     });\n// }\n\n// инициализация маски ввода телефона\n\nconst phoneInputs = document.querySelectorAll(\"input[type='tel']\")\n\nif (phoneInputs.length) {\n\n    phoneInputs.forEach(input => {\n        Inputmask({ mask: \"+7 (999) 999-99-99\" }).mask(input);\n    });\n}\n\nfunction isWebp() {\n    // Проверка поддержки webp\n    function testWebP(callback) {\n        let webP = new Image();\n        webP.onload = webP.onerror = function () {\n            callback(webP.height == 2);\n        };\n        webP.src = \"data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA\";\n    }\n    // Добавление класса _webp или _no-webp для HTML\n    testWebP(function (support) {\n        let className = support === true ? 'webp' : 'no-webp';\n        document.documentElement.classList.add(className);\n    });\n}\n\nisWebp()\n\n// отображение таблицы тарифов\n\nconst plansBlock = document.getElementById(\"plans\")\nconst calculatePlan = document.getElementById(\"calculatePlan\")\n\nif (calculatePlan) {\n    calculatePlan.addEventListener(\"click\", function (event) {\n        event.preventDefault()\n        document.documentElement.classList.add(\"_plans-visible\")\n        if (plansBlock) {\n            plans.scrollIntoView({\n                behavior: 'smooth'\n            });\n        }\n    })\n\n    const plansItems = plansBlock.querySelectorAll(\".plan\")\n\n    if (plansItems.length) {\n        plansItems.forEach(item => {\n            const plansHeader = item.querySelector(\".plan__header\")\n            plansHeader.addEventListener(\"click\", () => {\n                item.classList.toggle(\"_plan-open\")\n            })\n        })\n    }\n}\n\n\n// скролл наверх\n\n// Получаем элемент кнопки \"наверх\"\nconst toTopButton = document.getElementById('to-top');\n\n// Функция для управления видимостью кнопки\nfunction toggleButtonVisibility() {\n    if (window.scrollY > 200) {\n        toTopButton.style.display = 'block'; // Показываем кнопку\n    } else {\n        toTopButton.style.display = 'none'; // Скрываем кнопку\n    }\n}\n\n// Добавляем обработчик события прокрутки\nwindow.addEventListener('scroll', toggleButtonVisibility);\n\n// Обработчик клика по кнопке \"наверх\"\ntoTopButton.addEventListener('click', function () {\n    window.scrollTo({\n        top: 0,\n        behavior: 'smooth'\n    });\n});\n\n// Изначально скрываем кнопку\ntoTopButton.style.display = 'none';\n\n// Range Slider Properties.\n\nconst sliderProps = {\n    fill: \"#95C11F\",\n    background: \"#DADADA\",\n};\n\nconst sliders = document.querySelectorAll(\".range-wrapper\");\n\nsliders.forEach(slider => {\n    const sliderNumber = slider.querySelector(\".slider-count\");\n    const sliderRangeInput = slider.querySelector(\"input[type='range']\")\n\n    sliderRangeInput.addEventListener(\"input\", event => {\n        sliderNumber.value = event.target.value;\n\n        setRangeLine(sliderRangeInput)\n    });\n\n    sliderNumber.addEventListener(\"input\", event => {\n        sliderRangeInput.value = +event.target.value;\n        setRangeLine(sliderRangeInput)\n    })\n\n    function setRangeLine(slider) {\n        const percentage = (100 * (sliderRangeInput.value - sliderRangeInput.min)) / (sliderRangeInput.max - sliderRangeInput.min);\n        const bg = `linear-gradient(90deg, ${sliderProps.fill} ${percentage}%, ${sliderProps.background} ${percentage + 0.1}%)`;\n        sliderRangeInput.style.background = bg;\n    }\n\n});\n\nconst header = document.querySelector('header');\nconst body = document.body;\nconst headerHeight = header.offsetHeight;\nbody.style.paddingTop = `${headerHeight}px`;\n\n\n\n// function updateBodyPadding() {\n//     // Проверяем, есть ли у заголовка класс _header-scroll\n//     if (header.classList.contains('_header-scroll')) {\n//         // Получаем высоту заголовка\n//         const headerHeight = header.offsetHeight;\n//         // Устанавливаем отступ верхней части для body\n//         body.style.paddingTop = `${headerHeight}px`;\n//     } else {\n//         // Если класс отсутствует, сбрасываем отступ\n//         body.style.paddingTop = '0';\n//     }\n// }\n\n// // Запускаем функцию при изменении размера окна\n// window.addEventListener('scroll', updateBodyPadding);\n\n\n//# sourceURL=webpack://gulp-2022/./src/js/files/script.js?");

/***/ }),

/***/ "./src/js/files/scroll/gotoblock.js":
/*!******************************************!*\
  !*** ./src/js/files/scroll/gotoblock.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"gotoBlock\": () => (/* binding */ gotoBlock)\n/* harmony export */ });\n/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions.js */ \"./src/js/files/functions.js\");\n/* harmony import */ var smooth_scroll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! smooth-scroll */ \"./node_modules/smooth-scroll/dist/smooth-scroll.polyfills.min.js\");\n// Подключение функционала \"Чертогов Фрилансера\"\n\n// Подключение дополнения для увеличения возможностей\n// Документация: https://github.com/cferdinandi/smooth-scroll\n\n//==============================================================================================================================================================================================================================================================================================================================\n\n// Модуль плавной проктутки к блоку\nlet gotoBlock = (targetBlock, noHeader = false, speed = 500, offsetTop = 0) => {\n\tconst targetBlockElement = document.querySelector(targetBlock);\n\tif (targetBlockElement) {\n\t\tlet headerItem = '';\n\t\tlet headerItemHeight = 0;\n\t\tif (noHeader) {\n\t\t\theaderItem = 'header.header';\n\t\t\theaderItemHeight = document.querySelector(headerItem).offsetHeight;\n\t\t}\n\t\tlet options = {\n\t\t\tspeedAsDuration: true,\n\t\t\tspeed: speed,\n\t\t\theader: headerItem,\n\t\t\toffset: offsetTop,\n\t\t\teasing: 'easeOutQuad',\n\t\t};\n\t\t// Закрываем меню, если оно открыто\n\t\tdocument.documentElement.classList.contains(\"menu-open\") ? (0,_functions_js__WEBPACK_IMPORTED_MODULE_0__.menuClose)() : null;\n\n\t\tif (typeof smooth_scroll__WEBPACK_IMPORTED_MODULE_1__ !== 'undefined') {\n\t\t\t// Прокрутка с использованием дополнения\n\t\t\tnew smooth_scroll__WEBPACK_IMPORTED_MODULE_1__().animateScroll(targetBlockElement, '', options);\n\t\t} else {\n\t\t\t// Прокрутка стандартными средствами\n\t\t\tlet targetBlockElementPosition = targetBlockElement.getBoundingClientRect().top + scrollY;\n\t\t\ttargetBlockElementPosition = headerItemHeight ? targetBlockElementPosition - headerItemHeight : targetBlockElementPosition;\n\t\t\ttargetBlockElementPosition = offsetTop ? targetBlockElementPosition - offsetTop : targetBlockElementPosition;\n\t\t\twindow.scrollTo({\n\t\t\t\ttop: targetBlockElementPosition,\n\t\t\t\tbehavior: \"smooth\"\n\t\t\t});\n\t\t}\n\t\t(0,_functions_js__WEBPACK_IMPORTED_MODULE_0__.FLS)(`[gotoBlock]: Юхуу...едем к ${targetBlock}`);\n\t} else {\n\t\t(0,_functions_js__WEBPACK_IMPORTED_MODULE_0__.FLS)(`[gotoBlock]: Ой ой..Такого блока нет на странице: ${targetBlock}`);\n\t}\n};\n\n//# sourceURL=webpack://gulp-2022/./src/js/files/scroll/gotoblock.js?");

/***/ }),

/***/ "./src/js/files/scroll/scroll.js":
/*!***************************************!*\
  !*** ./src/js/files/scroll/scroll.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"headerScroll\": () => (/* binding */ headerScroll),\n/* harmony export */   \"pageNavigation\": () => (/* binding */ pageNavigation),\n/* harmony export */   \"stickyBlock\": () => (/* binding */ stickyBlock)\n/* harmony export */ });\n/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions.js */ \"./src/js/files/functions.js\");\n/* harmony import */ var _gotoblock_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gotoblock.js */ \"./src/js/files/scroll/gotoblock.js\");\n// Подключение функционала \"Чертогов Фрилансера\"\n\n// Модуль прокрутки к блоку\n\n// Переменная контроля добавления события window scroll.\nlet addWindowScrollEvent = false;\n//====================================================================================================================================================================================================================================================================================================\n// Плавная навигация по странице\nfunction pageNavigation() {\n\t// data-goto - указать ID блока\n\t// data-goto-header - учитывать header\n\t// data-goto-top - недокрутить на указанный размер\n\t// data-goto-speed - скорость (только если используется доп плагин)\n\t// Работаем при клике на пункт\n\tdocument.addEventListener(\"click\", pageNavigationAction);\n\t// Если подключен scrollWatcher, подсвечиваем текущий пукт меню\n\tdocument.addEventListener(\"watcherCallback\", pageNavigationAction);\n\t// Основная функция\n\tfunction pageNavigationAction(e) {\n\t\tif (e.type === \"click\") {\n\t\t\tconst targetElement = e.target;\n\t\t\tif (targetElement.closest('[data-goto]')) {\n\t\t\t\tconst gotoLink = targetElement.closest('[data-goto]');\n\t\t\t\tconst gotoLinkSelector = gotoLink.dataset.goto ? gotoLink.dataset.goto : '';\n\t\t\t\tconst noHeader = gotoLink.hasAttribute('data-goto-header') ? true : false;\n\t\t\t\tconst gotoSpeed = gotoLink.dataset.gotoSpeed ? gotoLink.dataset.gotoSpeed : 500;\n\t\t\t\tconst offsetTop = gotoLink.dataset.gotoTop ? parseInt(gotoLink.dataset.gotoTop) : 0;\n\t\t\t\t(0,_gotoblock_js__WEBPACK_IMPORTED_MODULE_1__.gotoBlock)(gotoLinkSelector, noHeader, gotoSpeed, offsetTop);\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t} else if (e.type === \"watcherCallback\" && e.detail) {\n\t\t\tconst entry = e.detail.entry;\n\t\t\tconst targetElement = entry.target;\n\t\t\t// Обработка пунктов навигации, если указано значение navigator подсвечиваем текущий пукт меню\n\t\t\tif (targetElement.dataset.watch === 'navigator') {\n\t\t\t\tconst navigatorActiveItem = document.querySelector(`[data-goto]._navigator-active`);\n\t\t\t\tlet navigatorCurrentItem;\n\t\t\t\tif (targetElement.id && document.querySelector(`[data-goto=\"#${targetElement.id}\"]`)) {\n\t\t\t\t\tnavigatorCurrentItem = document.querySelector(`[data-goto=\"#${targetElement.id}\"]`);\n\t\t\t\t} else if (targetElement.classList.length) {\n\t\t\t\t\tfor (let index = 0; index < targetElement.classList.length; index++) {\n\t\t\t\t\t\tconst element = targetElement.classList[index];\n\t\t\t\t\t\tif (document.querySelector(`[data-goto=\".${element}\"]`)) {\n\t\t\t\t\t\t\tnavigatorCurrentItem = document.querySelector(`[data-goto=\".${element}\"]`);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (entry.isIntersecting) {\n\t\t\t\t\t// Видим объект\n\t\t\t\t\t// navigatorActiveItem ? navigatorActiveItem.classList.remove('_navigator-active') : null;\n\t\t\t\t\tnavigatorCurrentItem ? navigatorCurrentItem.classList.add('_navigator-active') : null;\n\t\t\t\t} else {\n\t\t\t\t\t// Не видим объект\n\t\t\t\t\tnavigatorCurrentItem ? navigatorCurrentItem.classList.remove('_navigator-active') : null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Прокрутка по хешу\n\tif ((0,_functions_js__WEBPACK_IMPORTED_MODULE_0__.getHash)()) {\n\t\tlet goToHash;\n\t\tif (document.querySelector(`#${(0,_functions_js__WEBPACK_IMPORTED_MODULE_0__.getHash)()}`)) {\n\t\t\tgoToHash = `#${(0,_functions_js__WEBPACK_IMPORTED_MODULE_0__.getHash)()}`;\n\t\t} else if (document.querySelector(`.${(0,_functions_js__WEBPACK_IMPORTED_MODULE_0__.getHash)()}`)) {\n\t\t\tgoToHash = `.${(0,_functions_js__WEBPACK_IMPORTED_MODULE_0__.getHash)()}`;\n\t\t}\n\t\tgoToHash ? (0,_gotoblock_js__WEBPACK_IMPORTED_MODULE_1__.gotoBlock)(goToHash, true, 500, 20) : null;\n\t}\n}\n// Работа с шапкой при скроле\nfunction headerScroll() {\n\taddWindowScrollEvent = true;\n\tconst header = document.querySelector('header.header');\n\tconst headerShow = header.hasAttribute('data-scroll-show');\n\tconst headerShowTimer = header.dataset.scrollShow ? header.dataset.scrollShow : 500;\n\tconst startPoint = header.dataset.scroll ? header.dataset.scroll : 1;\n\tlet scrollDirection = 0;\n\tlet timer;\n\tdocument.addEventListener(\"windowScroll\", function (e) {\n\t\tconst scrollTop = window.scrollY;\n\t\tclearTimeout(timer);\n\t\tif (scrollTop >= startPoint) {\n\t\t\t!header.classList.contains('_header-scroll') ? header.classList.add('_header-scroll') : null;\n\t\t\tif (headerShow) {\n\t\t\t\tif (scrollTop > scrollDirection) {\n\t\t\t\t\t// downscroll code\n\t\t\t\t\theader.classList.contains('_header-show') ? header.classList.remove('_header-show') : null;\n\t\t\t\t} else {\n\t\t\t\t\t// upscroll code\n\t\t\t\t\t!header.classList.contains('_header-show') ? header.classList.add('_header-show') : null;\n\t\t\t\t}\n\t\t\t\ttimer = setTimeout(() => {\n\t\t\t\t\t!header.classList.contains('_header-show') ? header.classList.add('_header-show') : null;\n\t\t\t\t}, headerShowTimer);\n\t\t\t}\n\t\t} else {\n\t\t\theader.classList.contains('_header-scroll') ? header.classList.remove('_header-scroll') : null;\n\t\t\tif (headerShow) {\n\t\t\t\theader.classList.contains('_header-show') ? header.classList.remove('_header-show') : null;\n\t\t\t}\n\t\t}\n\t\tscrollDirection = scrollTop <= 0 ? 0 : scrollTop;\n\t});\n}\n// Прилипающий блок\nfunction stickyBlock() {\n\taddWindowScrollEvent = true;\n\t// data-sticky для родителя внутри которого прилипает блок *\n\t// data-sticky-header для родителя, учитываем высоту хедера\n\t// data-sticky-top=\"\" для родителя, можно указать отступ сверху\n\t// data-sticky-bottom=\"\" для родителя, можно указать отступ снизу\n\t// data-sticky-item для прилипающего блока *\n\tfunction stickyBlockInit() {\n\t\tconst stickyParents = document.querySelectorAll('[data-sticky]');\n\t\tif (stickyParents.length) {\n\t\t\tstickyParents.forEach(stickyParent => {\n\t\t\t\tlet stickyConfig = {\n\t\t\t\t\tmedia: stickyParent.dataset.sticky ? parseInt(stickyParent.dataset.sticky) : null,\n\t\t\t\t\ttop: stickyParent.dataset.stickyTop ? parseInt(stickyParent.dataset.stickyTop) : 0,\n\t\t\t\t\tbottom: stickyParent.dataset.stickyBottom ? parseInt(stickyParent.dataset.stickyBottom) : 0,\n\t\t\t\t\theader: stickyParent.hasAttribute('data-sticky-header') ? document.querySelector('header.header').offsetHeight : 0\n\t\t\t\t}\n\t\t\t\tstickyBlockItem(stickyParent, stickyConfig);\n\t\t\t});\n\t\t}\n\t}\n\tfunction stickyBlockItem(stickyParent, stickyConfig) {\n\t\tconst stickyBlockItem = stickyParent.querySelector('[data-sticky-item]');\n\t\tconst headerHeight = stickyConfig.header;\n\t\tconst offsetTop = headerHeight + stickyConfig.top;\n\t\tconst startPoint = stickyBlockItem.getBoundingClientRect().top + scrollY - offsetTop;\n\n\t\tdocument.addEventListener(\"windowScroll\", stickyBlockActions);\n\t\t//window.addEventListener(\"resize\", stickyBlockActions);\n\n\t\tfunction stickyBlockActions(e) {\n\t\t\tconst endPoint = (stickyParent.offsetHeight + stickyParent.getBoundingClientRect().top + scrollY) - (offsetTop + stickyBlockItem.offsetHeight + stickyConfig.bottom);\n\t\t\tlet stickyItemValues = {\n\t\t\t\tposition: \"relative\",\n\t\t\t\tbottom: \"auto\",\n\t\t\t\ttop: \"0px\",\n\t\t\t\tleft: \"0px\",\n\t\t\t\twidth: \"auto\"\n\t\t\t}\n\t\t\tif (!stickyConfig.media || stickyConfig.media < window.innerWidth) {\n\t\t\t\tif (offsetTop + stickyConfig.bottom + stickyBlockItem.offsetHeight < window.innerHeight) {\n\t\t\t\t\tif (scrollY >= startPoint && scrollY <= endPoint) {\n\t\t\t\t\t\tstickyItemValues.position = `fixed`;\n\t\t\t\t\t\tstickyItemValues.bottom = `auto`;\n\t\t\t\t\t\tstickyItemValues.top = `${offsetTop}px`;\n\t\t\t\t\t\tstickyItemValues.left = `${stickyBlockItem.getBoundingClientRect().left}px`; // Учесть разницу в ширине экрана?\n\t\t\t\t\t\tstickyItemValues.width = `${stickyBlockItem.offsetWidth}px`;\n\t\t\t\t\t} else if (scrollY >= endPoint) {\n\t\t\t\t\t\tstickyItemValues.position = `absolute`;\n\t\t\t\t\t\tstickyItemValues.bottom = `${stickyConfig.bottom}px`;\n\t\t\t\t\t\tstickyItemValues.top = `auto`;\n\t\t\t\t\t\tstickyItemValues.left = `0px`;\n\t\t\t\t\t\tstickyItemValues.width = `${stickyBlockItem.offsetWidth}px`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstickyBlockType(stickyBlockItem, stickyItemValues);\n\t\t}\n\t}\n\tfunction stickyBlockType(stickyBlockItem, stickyItemValues) {\n\t\tstickyBlockItem.style.cssText = `position:${stickyItemValues.position};bottom:${stickyItemValues.bottom};top:${stickyItemValues.top};left:${stickyItemValues.left};width:${stickyItemValues.width};`;\n\t}\n\tstickyBlockInit();\n}\n// При подключении модуля обработчик события запустится автоматически\nsetTimeout(() => {\n\tif (addWindowScrollEvent) {\n\t\tlet windowScroll = new Event(\"windowScroll\");\n\t\twindow.addEventListener(\"scroll\", function (e) {\n\t\t\tdocument.dispatchEvent(windowScroll);\n\t\t});\n\t}\n}, 0);\n\n//# sourceURL=webpack://gulp-2022/./src/js/files/scroll/scroll.js?");

/***/ }),

/***/ "./src/js/files/sliders.js":
/*!*********************************!*\
  !*** ./src/js/files/sliders.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * Swiper 11.1.1\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2024 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: April 9, 2024\n */\n\nvar Swiper = function () { \"use strict\"; function e(e) { return null !== e && \"object\" == typeof e && \"constructor\" in e && e.constructor === Object } function t(s, a) { void 0 === s && (s = {}), void 0 === a && (a = {}), Object.keys(a).forEach((i => { void 0 === s[i] ? s[i] = a[i] : e(a[i]) && e(s[i]) && Object.keys(a[i]).length > 0 && t(s[i], a[i]) })) } const s = { body: {}, addEventListener() { }, removeEventListener() { }, activeElement: { blur() { }, nodeName: \"\" }, querySelector: () => null, querySelectorAll: () => [], getElementById: () => null, createEvent: () => ({ initEvent() { } }), createElement: () => ({ children: [], childNodes: [], style: {}, setAttribute() { }, getElementsByTagName: () => [] }), createElementNS: () => ({}), importNode: () => null, location: { hash: \"\", host: \"\", hostname: \"\", href: \"\", origin: \"\", pathname: \"\", protocol: \"\", search: \"\" } }; function a() { const e = \"undefined\" != typeof document ? document : {}; return t(e, s), e } const i = { document: s, navigator: { userAgent: \"\" }, location: { hash: \"\", host: \"\", hostname: \"\", href: \"\", origin: \"\", pathname: \"\", protocol: \"\", search: \"\" }, history: { replaceState() { }, pushState() { }, go() { }, back() { } }, CustomEvent: function () { return this }, addEventListener() { }, removeEventListener() { }, getComputedStyle: () => ({ getPropertyValue: () => \"\" }), Image() { }, Date() { }, screen: {}, setTimeout() { }, clearTimeout() { }, matchMedia: () => ({}), requestAnimationFrame: e => \"undefined\" == typeof setTimeout ? (e(), null) : setTimeout(e, 0), cancelAnimationFrame(e) { \"undefined\" != typeof setTimeout && clearTimeout(e) } }; function r() { const e = \"undefined\" != typeof window ? window : {}; return t(e, i), e } function n(e) { return void 0 === e && (e = \"\"), e.trim().split(\" \").filter((e => !!e.trim())) } function l(e, t) { return void 0 === t && (t = 0), setTimeout(e, t) } function o() { return Date.now() } function d(e, t) { void 0 === t && (t = \"x\"); const s = r(); let a, i, n; const l = function (e) { const t = r(); let s; return t.getComputedStyle && (s = t.getComputedStyle(e, null)), !s && e.currentStyle && (s = e.currentStyle), s || (s = e.style), s }(e); return s.WebKitCSSMatrix ? (i = l.transform || l.webkitTransform, i.split(\",\").length > 6 && (i = i.split(\", \").map((e => e.replace(\",\", \".\"))).join(\", \")), n = new s.WebKitCSSMatrix(\"none\" === i ? \"\" : i)) : (n = l.MozTransform || l.OTransform || l.MsTransform || l.msTransform || l.transform || l.getPropertyValue(\"transform\").replace(\"translate(\", \"matrix(1, 0, 0, 1,\"), a = n.toString().split(\",\")), \"x\" === t && (i = s.WebKitCSSMatrix ? n.m41 : 16 === a.length ? parseFloat(a[12]) : parseFloat(a[4])), \"y\" === t && (i = s.WebKitCSSMatrix ? n.m42 : 16 === a.length ? parseFloat(a[13]) : parseFloat(a[5])), i || 0 } function c(e) { return \"object\" == typeof e && null !== e && e.constructor && \"Object\" === Object.prototype.toString.call(e).slice(8, -1) } function p() { const e = Object(arguments.length <= 0 ? void 0 : arguments[0]), t = [\"__proto__\", \"constructor\", \"prototype\"]; for (let a = 1; a < arguments.length; a += 1) { const i = a < 0 || arguments.length <= a ? void 0 : arguments[a]; if (null != i && (s = i, !(\"undefined\" != typeof window && void 0 !== window.HTMLElement ? s instanceof HTMLElement : s && (1 === s.nodeType || 11 === s.nodeType)))) { const s = Object.keys(Object(i)).filter((e => t.indexOf(e) < 0)); for (let t = 0, a = s.length; t < a; t += 1) { const a = s[t], r = Object.getOwnPropertyDescriptor(i, a); void 0 !== r && r.enumerable && (c(e[a]) && c(i[a]) ? i[a].__swiper__ ? e[a] = i[a] : p(e[a], i[a]) : !c(e[a]) && c(i[a]) ? (e[a] = {}, i[a].__swiper__ ? e[a] = i[a] : p(e[a], i[a])) : e[a] = i[a]) } } } var s; return e } function u(e, t, s) { e.style.setProperty(t, s) } function m(e) { let { swiper: t, targetPosition: s, side: a } = e; const i = r(), n = -t.translate; let l, o = null; const d = t.params.speed; t.wrapperEl.style.scrollSnapType = \"none\", i.cancelAnimationFrame(t.cssModeFrameID); const c = s > n ? \"next\" : \"prev\", p = (e, t) => \"next\" === c && e >= t || \"prev\" === c && e <= t, u = () => { l = (new Date).getTime(), null === o && (o = l); const e = Math.max(Math.min((l - o) / d, 1), 0), r = .5 - Math.cos(e * Math.PI) / 2; let c = n + r * (s - n); if (p(c, s) && (c = s), t.wrapperEl.scrollTo({ [a]: c }), p(c, s)) return t.wrapperEl.style.overflow = \"hidden\", t.wrapperEl.style.scrollSnapType = \"\", setTimeout((() => { t.wrapperEl.style.overflow = \"\", t.wrapperEl.scrollTo({ [a]: c }) })), void i.cancelAnimationFrame(t.cssModeFrameID); t.cssModeFrameID = i.requestAnimationFrame(u) }; u() } function h(e) { return e.querySelector(\".swiper-slide-transform\") || e.shadowRoot && e.shadowRoot.querySelector(\".swiper-slide-transform\") || e } function f(e, t) { return void 0 === t && (t = \"\"), [...e.children].filter((e => e.matches(t))) } function g(e) { try { return void console.warn(e) } catch (e) { } } function v(e, t) { void 0 === t && (t = []); const s = document.createElement(e); return s.classList.add(...Array.isArray(t) ? t : n(t)), s } function w(e) { const t = r(), s = a(), i = e.getBoundingClientRect(), n = s.body, l = e.clientTop || n.clientTop || 0, o = e.clientLeft || n.clientLeft || 0, d = e === t ? t.scrollY : e.scrollTop, c = e === t ? t.scrollX : e.scrollLeft; return { top: i.top + d - l, left: i.left + c - o } } function b(e, t) { return r().getComputedStyle(e, null).getPropertyValue(t) } function y(e) { let t, s = e; if (s) { for (t = 0; null !== (s = s.previousSibling);)1 === s.nodeType && (t += 1); return t } } function E(e, t) { const s = []; let a = e.parentElement; for (; a;)t ? a.matches(t) && s.push(a) : s.push(a), a = a.parentElement; return s } function x(e, t) { t && e.addEventListener(\"transitionend\", (function s(a) { a.target === e && (t.call(e, a), e.removeEventListener(\"transitionend\", s)) })) } function S(e, t, s) { const a = r(); return s ? e[\"width\" === t ? \"offsetWidth\" : \"offsetHeight\"] + parseFloat(a.getComputedStyle(e, null).getPropertyValue(\"width\" === t ? \"margin-right\" : \"margin-top\")) + parseFloat(a.getComputedStyle(e, null).getPropertyValue(\"width\" === t ? \"margin-left\" : \"margin-bottom\")) : e.offsetWidth } function T(e) { return (Array.isArray(e) ? e : [e]).filter((e => !!e)) } let M, C, P; function L() { return M || (M = function () { const e = r(), t = a(); return { smoothScroll: t.documentElement && t.documentElement.style && \"scrollBehavior\" in t.documentElement.style, touch: !!(\"ontouchstart\" in e || e.DocumentTouch && t instanceof e.DocumentTouch) } }()), M } function I(e) { return void 0 === e && (e = {}), C || (C = function (e) { let { userAgent: t } = void 0 === e ? {} : e; const s = L(), a = r(), i = a.navigator.platform, n = t || a.navigator.userAgent, l = { ios: !1, android: !1 }, o = a.screen.width, d = a.screen.height, c = n.match(/(Android);?[\\s\\/]+([\\d.]+)?/); let p = n.match(/(iPad).*OS\\s([\\d_]+)/); const u = n.match(/(iPod)(.*OS\\s([\\d_]+))?/), m = !p && n.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/), h = \"Win32\" === i; let f = \"MacIntel\" === i; return !p && f && s.touch && [\"1024x1366\", \"1366x1024\", \"834x1194\", \"1194x834\", \"834x1112\", \"1112x834\", \"768x1024\", \"1024x768\", \"820x1180\", \"1180x820\", \"810x1080\", \"1080x810\"].indexOf(`${o}x${d}`) >= 0 && (p = n.match(/(Version)\\/([\\d.]+)/), p || (p = [0, 1, \"13_0_0\"]), f = !1), c && !h && (l.os = \"android\", l.android = !0), (p || m || u) && (l.os = \"ios\", l.ios = !0), l }(e)), C } function z() { return P || (P = function () { const e = r(), t = I(); let s = !1; function a() { const t = e.navigator.userAgent.toLowerCase(); return t.indexOf(\"safari\") >= 0 && t.indexOf(\"chrome\") < 0 && t.indexOf(\"android\") < 0 } if (a()) { const t = String(e.navigator.userAgent); if (t.includes(\"Version/\")) { const [e, a] = t.split(\"Version/\")[1].split(\" \")[0].split(\".\").map((e => Number(e))); s = e < 16 || 16 === e && a < 2 } } const i = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent), n = a(); return { isSafari: s || n, needPerspectiveFix: s, need3dFix: n || i && t.ios, isWebView: i } }()), P } var A = { on(e, t, s) { const a = this; if (!a.eventsListeners || a.destroyed) return a; if (\"function\" != typeof t) return a; const i = s ? \"unshift\" : \"push\"; return e.split(\" \").forEach((e => { a.eventsListeners[e] || (a.eventsListeners[e] = []), a.eventsListeners[e][i](t) })), a }, once(e, t, s) { const a = this; if (!a.eventsListeners || a.destroyed) return a; if (\"function\" != typeof t) return a; function i() { a.off(e, i), i.__emitterProxy && delete i.__emitterProxy; for (var s = arguments.length, r = new Array(s), n = 0; n < s; n++)r[n] = arguments[n]; t.apply(a, r) } return i.__emitterProxy = t, a.on(e, i, s) }, onAny(e, t) { const s = this; if (!s.eventsListeners || s.destroyed) return s; if (\"function\" != typeof e) return s; const a = t ? \"unshift\" : \"push\"; return s.eventsAnyListeners.indexOf(e) < 0 && s.eventsAnyListeners[a](e), s }, offAny(e) { const t = this; if (!t.eventsListeners || t.destroyed) return t; if (!t.eventsAnyListeners) return t; const s = t.eventsAnyListeners.indexOf(e); return s >= 0 && t.eventsAnyListeners.splice(s, 1), t }, off(e, t) { const s = this; return !s.eventsListeners || s.destroyed ? s : s.eventsListeners ? (e.split(\" \").forEach((e => { void 0 === t ? s.eventsListeners[e] = [] : s.eventsListeners[e] && s.eventsListeners[e].forEach(((a, i) => { (a === t || a.__emitterProxy && a.__emitterProxy === t) && s.eventsListeners[e].splice(i, 1) })) })), s) : s }, emit() { const e = this; if (!e.eventsListeners || e.destroyed) return e; if (!e.eventsListeners) return e; let t, s, a; for (var i = arguments.length, r = new Array(i), n = 0; n < i; n++)r[n] = arguments[n]; \"string\" == typeof r[0] || Array.isArray(r[0]) ? (t = r[0], s = r.slice(1, r.length), a = e) : (t = r[0].events, s = r[0].data, a = r[0].context || e), s.unshift(a); return (Array.isArray(t) ? t : t.split(\" \")).forEach((t => { e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach((e => { e.apply(a, [t, ...s]) })), e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach((e => { e.apply(a, s) })) })), e } }; const $ = (e, t, s) => { t && !e.classList.contains(s) ? e.classList.add(s) : !t && e.classList.contains(s) && e.classList.remove(s) }; const k = (e, t) => { if (!e || e.destroyed || !e.params) return; const s = t.closest(e.isElement ? \"swiper-slide\" : `.${e.params.slideClass}`); if (s) { let t = s.querySelector(`.${e.params.lazyPreloaderClass}`); !t && e.isElement && (s.shadowRoot ? t = s.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`) : requestAnimationFrame((() => { s.shadowRoot && (t = s.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`), t && t.remove()) }))), t && t.remove() } }, O = (e, t) => { if (!e.slides[t]) return; const s = e.slides[t].querySelector('[loading=\"lazy\"]'); s && s.removeAttribute(\"loading\") }, D = e => { if (!e || e.destroyed || !e.params) return; let t = e.params.lazyPreloadPrevNext; const s = e.slides.length; if (!s || !t || t < 0) return; t = Math.min(t, s); const a = \"auto\" === e.params.slidesPerView ? e.slidesPerViewDynamic() : Math.ceil(e.params.slidesPerView), i = e.activeIndex; if (e.params.grid && e.params.grid.rows > 1) { const s = i, r = [s - t]; return r.push(...Array.from({ length: t }).map(((e, t) => s + a + t))), void e.slides.forEach(((t, s) => { r.includes(t.column) && O(e, s) })) } const r = i + a - 1; if (e.params.rewind || e.params.loop) for (let a = i - t; a <= r + t; a += 1) { const t = (a % s + s) % s; (t < i || t > r) && O(e, t) } else for (let a = Math.max(i - t, 0); a <= Math.min(r + t, s - 1); a += 1)a !== i && (a > r || a < i) && O(e, a) }; var G = { updateSize: function () { const e = this; let t, s; const a = e.el; t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : a.clientWidth, s = void 0 !== e.params.height && null !== e.params.height ? e.params.height : a.clientHeight, 0 === t && e.isHorizontal() || 0 === s && e.isVertical() || (t = t - parseInt(b(a, \"padding-left\") || 0, 10) - parseInt(b(a, \"padding-right\") || 0, 10), s = s - parseInt(b(a, \"padding-top\") || 0, 10) - parseInt(b(a, \"padding-bottom\") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(s) && (s = 0), Object.assign(e, { width: t, height: s, size: e.isHorizontal() ? t : s })) }, updateSlides: function () { const e = this; function t(t, s) { return parseFloat(t.getPropertyValue(e.getDirectionLabel(s)) || 0) } const s = e.params, { wrapperEl: a, slidesEl: i, size: r, rtlTranslate: n, wrongRTL: l } = e, o = e.virtual && s.virtual.enabled, d = o ? e.virtual.slides.length : e.slides.length, c = f(i, `.${e.params.slideClass}, swiper-slide`), p = o ? e.virtual.slides.length : c.length; let m = []; const h = [], g = []; let v = s.slidesOffsetBefore; \"function\" == typeof v && (v = s.slidesOffsetBefore.call(e)); let w = s.slidesOffsetAfter; \"function\" == typeof w && (w = s.slidesOffsetAfter.call(e)); const y = e.snapGrid.length, E = e.slidesGrid.length; let x = s.spaceBetween, T = -v, M = 0, C = 0; if (void 0 === r) return; \"string\" == typeof x && x.indexOf(\"%\") >= 0 ? x = parseFloat(x.replace(\"%\", \"\")) / 100 * r : \"string\" == typeof x && (x = parseFloat(x)), e.virtualSize = -x, c.forEach((e => { n ? e.style.marginLeft = \"\" : e.style.marginRight = \"\", e.style.marginBottom = \"\", e.style.marginTop = \"\" })), s.centeredSlides && s.cssMode && (u(a, \"--swiper-centered-offset-before\", \"\"), u(a, \"--swiper-centered-offset-after\", \"\")); const P = s.grid && s.grid.rows > 1 && e.grid; let L; P ? e.grid.initSlides(c) : e.grid && e.grid.unsetSlides(); const I = \"auto\" === s.slidesPerView && s.breakpoints && Object.keys(s.breakpoints).filter((e => void 0 !== s.breakpoints[e].slidesPerView)).length > 0; for (let a = 0; a < p; a += 1) { let i; if (L = 0, c[a] && (i = c[a]), P && e.grid.updateSlide(a, i, c), !c[a] || \"none\" !== b(i, \"display\")) { if (\"auto\" === s.slidesPerView) { I && (c[a].style[e.getDirectionLabel(\"width\")] = \"\"); const r = getComputedStyle(i), n = i.style.transform, l = i.style.webkitTransform; if (n && (i.style.transform = \"none\"), l && (i.style.webkitTransform = \"none\"), s.roundLengths) L = e.isHorizontal() ? S(i, \"width\", !0) : S(i, \"height\", !0); else { const e = t(r, \"width\"), s = t(r, \"padding-left\"), a = t(r, \"padding-right\"), n = t(r, \"margin-left\"), l = t(r, \"margin-right\"), o = r.getPropertyValue(\"box-sizing\"); if (o && \"border-box\" === o) L = e + n + l; else { const { clientWidth: t, offsetWidth: r } = i; L = e + s + a + n + l + (r - t) } } n && (i.style.transform = n), l && (i.style.webkitTransform = l), s.roundLengths && (L = Math.floor(L)) } else L = (r - (s.slidesPerView - 1) * x) / s.slidesPerView, s.roundLengths && (L = Math.floor(L)), c[a] && (c[a].style[e.getDirectionLabel(\"width\")] = `${L}px`); c[a] && (c[a].swiperSlideSize = L), g.push(L), s.centeredSlides ? (T = T + L / 2 + M / 2 + x, 0 === M && 0 !== a && (T = T - r / 2 - x), 0 === a && (T = T - r / 2 - x), Math.abs(T) < .001 && (T = 0), s.roundLengths && (T = Math.floor(T)), C % s.slidesPerGroup == 0 && m.push(T), h.push(T)) : (s.roundLengths && (T = Math.floor(T)), (C - Math.min(e.params.slidesPerGroupSkip, C)) % e.params.slidesPerGroup == 0 && m.push(T), h.push(T), T = T + L + x), e.virtualSize += L + x, M = L, C += 1 } } if (e.virtualSize = Math.max(e.virtualSize, r) + w, n && l && (\"slide\" === s.effect || \"coverflow\" === s.effect) && (a.style.width = `${e.virtualSize + x}px`), s.setWrapperSize && (a.style[e.getDirectionLabel(\"width\")] = `${e.virtualSize + x}px`), P && e.grid.updateWrapperSize(L, m), !s.centeredSlides) { const t = []; for (let a = 0; a < m.length; a += 1) { let i = m[a]; s.roundLengths && (i = Math.floor(i)), m[a] <= e.virtualSize - r && t.push(i) } m = t, Math.floor(e.virtualSize - r) - Math.floor(m[m.length - 1]) > 1 && m.push(e.virtualSize - r) } if (o && s.loop) { const t = g[0] + x; if (s.slidesPerGroup > 1) { const a = Math.ceil((e.virtual.slidesBefore + e.virtual.slidesAfter) / s.slidesPerGroup), i = t * s.slidesPerGroup; for (let e = 0; e < a; e += 1)m.push(m[m.length - 1] + i) } for (let a = 0; a < e.virtual.slidesBefore + e.virtual.slidesAfter; a += 1)1 === s.slidesPerGroup && m.push(m[m.length - 1] + t), h.push(h[h.length - 1] + t), e.virtualSize += t } if (0 === m.length && (m = [0]), 0 !== x) { const t = e.isHorizontal() && n ? \"marginLeft\" : e.getDirectionLabel(\"marginRight\"); c.filter(((e, t) => !(s.cssMode && !s.loop) || t !== c.length - 1)).forEach((e => { e.style[t] = `${x}px` })) } if (s.centeredSlides && s.centeredSlidesBounds) { let e = 0; g.forEach((t => { e += t + (x || 0) })), e -= x; const t = e - r; m = m.map((e => e <= 0 ? -v : e > t ? t + w : e)) } if (s.centerInsufficientSlides) { let e = 0; if (g.forEach((t => { e += t + (x || 0) })), e -= x, e < r) { const t = (r - e) / 2; m.forEach(((e, s) => { m[s] = e - t })), h.forEach(((e, s) => { h[s] = e + t })) } } if (Object.assign(e, { slides: c, snapGrid: m, slidesGrid: h, slidesSizesGrid: g }), s.centeredSlides && s.cssMode && !s.centeredSlidesBounds) { u(a, \"--swiper-centered-offset-before\", -m[0] + \"px\"), u(a, \"--swiper-centered-offset-after\", e.size / 2 - g[g.length - 1] / 2 + \"px\"); const t = -e.snapGrid[0], s = -e.slidesGrid[0]; e.snapGrid = e.snapGrid.map((e => e + t)), e.slidesGrid = e.slidesGrid.map((e => e + s)) } if (p !== d && e.emit(\"slidesLengthChange\"), m.length !== y && (e.params.watchOverflow && e.checkOverflow(), e.emit(\"snapGridLengthChange\")), h.length !== E && e.emit(\"slidesGridLengthChange\"), s.watchSlidesProgress && e.updateSlidesOffset(), e.emit(\"slidesUpdated\"), !(o || s.cssMode || \"slide\" !== s.effect && \"fade\" !== s.effect)) { const t = `${s.containerModifierClass}backface-hidden`, a = e.el.classList.contains(t); p <= s.maxBackfaceHiddenSlides ? a || e.el.classList.add(t) : a && e.el.classList.remove(t) } }, updateAutoHeight: function (e) { const t = this, s = [], a = t.virtual && t.params.virtual.enabled; let i, r = 0; \"number\" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed); const n = e => a ? t.slides[t.getSlideIndexByData(e)] : t.slides[e]; if (\"auto\" !== t.params.slidesPerView && t.params.slidesPerView > 1) if (t.params.centeredSlides) (t.visibleSlides || []).forEach((e => { s.push(e) })); else for (i = 0; i < Math.ceil(t.params.slidesPerView); i += 1) { const e = t.activeIndex + i; if (e > t.slides.length && !a) break; s.push(n(e)) } else s.push(n(t.activeIndex)); for (i = 0; i < s.length; i += 1)if (void 0 !== s[i]) { const e = s[i].offsetHeight; r = e > r ? e : r } (r || 0 === r) && (t.wrapperEl.style.height = `${r}px`) }, updateSlidesOffset: function () { const e = this, t = e.slides, s = e.isElement ? e.isHorizontal() ? e.wrapperEl.offsetLeft : e.wrapperEl.offsetTop : 0; for (let a = 0; a < t.length; a += 1)t[a].swiperSlideOffset = (e.isHorizontal() ? t[a].offsetLeft : t[a].offsetTop) - s - e.cssOverflowAdjustment() }, updateSlidesProgress: function (e) { void 0 === e && (e = this && this.translate || 0); const t = this, s = t.params, { slides: a, rtlTranslate: i, snapGrid: r } = t; if (0 === a.length) return; void 0 === a[0].swiperSlideOffset && t.updateSlidesOffset(); let n = -e; i && (n = e), a.forEach((e => { e.classList.remove(s.slideVisibleClass, s.slideFullyVisibleClass) })), t.visibleSlidesIndexes = [], t.visibleSlides = []; let l = s.spaceBetween; \"string\" == typeof l && l.indexOf(\"%\") >= 0 ? l = parseFloat(l.replace(\"%\", \"\")) / 100 * t.size : \"string\" == typeof l && (l = parseFloat(l)); for (let e = 0; e < a.length; e += 1) { const o = a[e]; let d = o.swiperSlideOffset; s.cssMode && s.centeredSlides && (d -= a[0].swiperSlideOffset); const c = (n + (s.centeredSlides ? t.minTranslate() : 0) - d) / (o.swiperSlideSize + l), p = (n - r[0] + (s.centeredSlides ? t.minTranslate() : 0) - d) / (o.swiperSlideSize + l), u = -(n - d), m = u + t.slidesSizesGrid[e], h = u >= 0 && u <= t.size - t.slidesSizesGrid[e]; (u >= 0 && u < t.size - 1 || m > 1 && m <= t.size || u <= 0 && m >= t.size) && (t.visibleSlides.push(o), t.visibleSlidesIndexes.push(e), a[e].classList.add(s.slideVisibleClass)), h && a[e].classList.add(s.slideFullyVisibleClass), o.progress = i ? -c : c, o.originalProgress = i ? -p : p } }, updateProgress: function (e) { const t = this; if (void 0 === e) { const s = t.rtlTranslate ? -1 : 1; e = t && t.translate && t.translate * s || 0 } const s = t.params, a = t.maxTranslate() - t.minTranslate(); let { progress: i, isBeginning: r, isEnd: n, progressLoop: l } = t; const o = r, d = n; if (0 === a) i = 0, r = !0, n = !0; else { i = (e - t.minTranslate()) / a; const s = Math.abs(e - t.minTranslate()) < 1, l = Math.abs(e - t.maxTranslate()) < 1; r = s || i <= 0, n = l || i >= 1, s && (i = 0), l && (i = 1) } if (s.loop) { const s = t.getSlideIndexByData(0), a = t.getSlideIndexByData(t.slides.length - 1), i = t.slidesGrid[s], r = t.slidesGrid[a], n = t.slidesGrid[t.slidesGrid.length - 1], o = Math.abs(e); l = o >= i ? (o - i) / n : (o + n - r) / n, l > 1 && (l -= 1) } Object.assign(t, { progress: i, progressLoop: l, isBeginning: r, isEnd: n }), (s.watchSlidesProgress || s.centeredSlides && s.autoHeight) && t.updateSlidesProgress(e), r && !o && t.emit(\"reachBeginning toEdge\"), n && !d && t.emit(\"reachEnd toEdge\"), (o && !r || d && !n) && t.emit(\"fromEdge\"), t.emit(\"progress\", i) }, updateSlidesClasses: function () { const e = this, { slides: t, params: s, slidesEl: a, activeIndex: i } = e, r = e.virtual && s.virtual.enabled, n = e.grid && s.grid && s.grid.rows > 1, l = e => f(a, `.${s.slideClass}${e}, swiper-slide${e}`)[0]; let o, d, c; if (r) if (s.loop) { let t = i - e.virtual.slidesBefore; t < 0 && (t = e.virtual.slides.length + t), t >= e.virtual.slides.length && (t -= e.virtual.slides.length), o = l(`[data-swiper-slide-index=\"${t}\"]`) } else o = l(`[data-swiper-slide-index=\"${i}\"]`); else n ? (o = t.filter((e => e.column === i))[0], c = t.filter((e => e.column === i + 1))[0], d = t.filter((e => e.column === i - 1))[0]) : o = t[i]; o && (n || (c = function (e, t) { const s = []; for (; e.nextElementSibling;) { const a = e.nextElementSibling; t ? a.matches(t) && s.push(a) : s.push(a), e = a } return s }(o, `.${s.slideClass}, swiper-slide`)[0], s.loop && !c && (c = t[0]), d = function (e, t) { const s = []; for (; e.previousElementSibling;) { const a = e.previousElementSibling; t ? a.matches(t) && s.push(a) : s.push(a), e = a } return s }(o, `.${s.slideClass}, swiper-slide`)[0], s.loop && 0 === !d && (d = t[t.length - 1]))), t.forEach((e => { $(e, e === o, s.slideActiveClass), $(e, e === c, s.slideNextClass), $(e, e === d, s.slidePrevClass) })), e.emitSlidesClasses() }, updateActiveIndex: function (e) { const t = this, s = t.rtlTranslate ? t.translate : -t.translate, { snapGrid: a, params: i, activeIndex: r, realIndex: n, snapIndex: l } = t; let o, d = e; const c = e => { let s = e - t.virtual.slidesBefore; return s < 0 && (s = t.virtual.slides.length + s), s >= t.virtual.slides.length && (s -= t.virtual.slides.length), s }; if (void 0 === d && (d = function (e) { const { slidesGrid: t, params: s } = e, a = e.rtlTranslate ? e.translate : -e.translate; let i; for (let e = 0; e < t.length; e += 1)void 0 !== t[e + 1] ? a >= t[e] && a < t[e + 1] - (t[e + 1] - t[e]) / 2 ? i = e : a >= t[e] && a < t[e + 1] && (i = e + 1) : a >= t[e] && (i = e); return s.normalizeSlideIndex && (i < 0 || void 0 === i) && (i = 0), i }(t)), a.indexOf(s) >= 0) o = a.indexOf(s); else { const e = Math.min(i.slidesPerGroupSkip, d); o = e + Math.floor((d - e) / i.slidesPerGroup) } if (o >= a.length && (o = a.length - 1), d === r && !t.params.loop) return void (o !== l && (t.snapIndex = o, t.emit(\"snapIndexChange\"))); if (d === r && t.params.loop && t.virtual && t.params.virtual.enabled) return void (t.realIndex = c(d)); const p = t.grid && i.grid && i.grid.rows > 1; let u; if (t.virtual && i.virtual.enabled && i.loop) u = c(d); else if (p) { const e = t.slides.filter((e => e.column === d))[0]; let s = parseInt(e.getAttribute(\"data-swiper-slide-index\"), 10); Number.isNaN(s) && (s = Math.max(t.slides.indexOf(e), 0)), u = Math.floor(s / i.grid.rows) } else if (t.slides[d]) { const e = t.slides[d].getAttribute(\"data-swiper-slide-index\"); u = e ? parseInt(e, 10) : d } else u = d; Object.assign(t, { previousSnapIndex: l, snapIndex: o, previousRealIndex: n, realIndex: u, previousIndex: r, activeIndex: d }), t.initialized && D(t), t.emit(\"activeIndexChange\"), t.emit(\"snapIndexChange\"), (t.initialized || t.params.runCallbacksOnInit) && (n !== u && t.emit(\"realIndexChange\"), t.emit(\"slideChange\")) }, updateClickedSlide: function (e, t) { const s = this, a = s.params; let i = e.closest(`.${a.slideClass}, swiper-slide`); !i && s.isElement && t && t.length > 1 && t.includes(e) && [...t.slice(t.indexOf(e) + 1, t.length)].forEach((e => { !i && e.matches && e.matches(`.${a.slideClass}, swiper-slide`) && (i = e) })); let r, n = !1; if (i) for (let e = 0; e < s.slides.length; e += 1)if (s.slides[e] === i) { n = !0, r = e; break } if (!i || !n) return s.clickedSlide = void 0, void (s.clickedIndex = void 0); s.clickedSlide = i, s.virtual && s.params.virtual.enabled ? s.clickedIndex = parseInt(i.getAttribute(\"data-swiper-slide-index\"), 10) : s.clickedIndex = r, a.slideToClickedSlide && void 0 !== s.clickedIndex && s.clickedIndex !== s.activeIndex && s.slideToClickedSlide() } }; var H = { getTranslate: function (e) { void 0 === e && (e = this.isHorizontal() ? \"x\" : \"y\"); const { params: t, rtlTranslate: s, translate: a, wrapperEl: i } = this; if (t.virtualTranslate) return s ? -a : a; if (t.cssMode) return a; let r = d(i, e); return r += this.cssOverflowAdjustment(), s && (r = -r), r || 0 }, setTranslate: function (e, t) { const s = this, { rtlTranslate: a, params: i, wrapperEl: r, progress: n } = s; let l, o = 0, d = 0; s.isHorizontal() ? o = a ? -e : e : d = e, i.roundLengths && (o = Math.floor(o), d = Math.floor(d)), s.previousTranslate = s.translate, s.translate = s.isHorizontal() ? o : d, i.cssMode ? r[s.isHorizontal() ? \"scrollLeft\" : \"scrollTop\"] = s.isHorizontal() ? -o : -d : i.virtualTranslate || (s.isHorizontal() ? o -= s.cssOverflowAdjustment() : d -= s.cssOverflowAdjustment(), r.style.transform = `translate3d(${o}px, ${d}px, 0px)`); const c = s.maxTranslate() - s.minTranslate(); l = 0 === c ? 0 : (e - s.minTranslate()) / c, l !== n && s.updateProgress(e), s.emit(\"setTranslate\", s.translate, t) }, minTranslate: function () { return -this.snapGrid[0] }, maxTranslate: function () { return -this.snapGrid[this.snapGrid.length - 1] }, translateTo: function (e, t, s, a, i) { void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), void 0 === a && (a = !0); const r = this, { params: n, wrapperEl: l } = r; if (r.animating && n.preventInteractionOnTransition) return !1; const o = r.minTranslate(), d = r.maxTranslate(); let c; if (c = a && e > o ? o : a && e < d ? d : e, r.updateProgress(c), n.cssMode) { const e = r.isHorizontal(); if (0 === t) l[e ? \"scrollLeft\" : \"scrollTop\"] = -c; else { if (!r.support.smoothScroll) return m({ swiper: r, targetPosition: -c, side: e ? \"left\" : \"top\" }), !0; l.scrollTo({ [e ? \"left\" : \"top\"]: -c, behavior: \"smooth\" }) } return !0 } return 0 === t ? (r.setTransition(0), r.setTranslate(c), s && (r.emit(\"beforeTransitionStart\", t, i), r.emit(\"transitionEnd\"))) : (r.setTransition(t), r.setTranslate(c), s && (r.emit(\"beforeTransitionStart\", t, i), r.emit(\"transitionStart\")), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function (e) { r && !r.destroyed && e.target === this && (r.wrapperEl.removeEventListener(\"transitionend\", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, r.animating = !1, s && r.emit(\"transitionEnd\")) }), r.wrapperEl.addEventListener(\"transitionend\", r.onTranslateToWrapperTransitionEnd))), !0 } }; function N(e) { let { swiper: t, runCallbacks: s, direction: a, step: i } = e; const { activeIndex: r, previousIndex: n } = t; let l = a; if (l || (l = r > n ? \"next\" : r < n ? \"prev\" : \"reset\"), t.emit(`transition${i}`), s && r !== n) { if (\"reset\" === l) return void t.emit(`slideResetTransition${i}`); t.emit(`slideChangeTransition${i}`), \"next\" === l ? t.emit(`slideNextTransition${i}`) : t.emit(`slidePrevTransition${i}`) } } var X = { slideTo: function (e, t, s, a, i) { void 0 === e && (e = 0), void 0 === s && (s = !0), \"string\" == typeof e && (e = parseInt(e, 10)); const r = this; let n = e; n < 0 && (n = 0); const { params: l, snapGrid: o, slidesGrid: d, previousIndex: c, activeIndex: p, rtlTranslate: u, wrapperEl: h, enabled: f } = r; if (!f && !a && !i || r.destroyed || r.animating && l.preventInteractionOnTransition) return !1; void 0 === t && (t = r.params.speed); const g = Math.min(r.params.slidesPerGroupSkip, n); let v = g + Math.floor((n - g) / r.params.slidesPerGroup); v >= o.length && (v = o.length - 1); const w = -o[v]; if (l.normalizeSlideIndex) for (let e = 0; e < d.length; e += 1) { const t = -Math.floor(100 * w), s = Math.floor(100 * d[e]), a = Math.floor(100 * d[e + 1]); void 0 !== d[e + 1] ? t >= s && t < a - (a - s) / 2 ? n = e : t >= s && t < a && (n = e + 1) : t >= s && (n = e) } if (r.initialized && n !== p) { if (!r.allowSlideNext && (u ? w > r.translate && w > r.minTranslate() : w < r.translate && w < r.minTranslate())) return !1; if (!r.allowSlidePrev && w > r.translate && w > r.maxTranslate() && (p || 0) !== n) return !1 } let b; if (n !== (c || 0) && s && r.emit(\"beforeSlideChangeStart\"), r.updateProgress(w), b = n > p ? \"next\" : n < p ? \"prev\" : \"reset\", u && -w === r.translate || !u && w === r.translate) return r.updateActiveIndex(n), l.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), \"slide\" !== l.effect && r.setTranslate(w), \"reset\" !== b && (r.transitionStart(s, b), r.transitionEnd(s, b)), !1; if (l.cssMode) { const e = r.isHorizontal(), s = u ? w : -w; if (0 === t) { const t = r.virtual && r.params.virtual.enabled; t && (r.wrapperEl.style.scrollSnapType = \"none\", r._immediateVirtual = !0), t && !r._cssModeVirtualInitialSet && r.params.initialSlide > 0 ? (r._cssModeVirtualInitialSet = !0, requestAnimationFrame((() => { h[e ? \"scrollLeft\" : \"scrollTop\"] = s }))) : h[e ? \"scrollLeft\" : \"scrollTop\"] = s, t && requestAnimationFrame((() => { r.wrapperEl.style.scrollSnapType = \"\", r._immediateVirtual = !1 })) } else { if (!r.support.smoothScroll) return m({ swiper: r, targetPosition: s, side: e ? \"left\" : \"top\" }), !0; h.scrollTo({ [e ? \"left\" : \"top\"]: s, behavior: \"smooth\" }) } return !0 } return r.setTransition(t), r.setTranslate(w), r.updateActiveIndex(n), r.updateSlidesClasses(), r.emit(\"beforeTransitionStart\", t, a), r.transitionStart(s, b), 0 === t ? r.transitionEnd(s, b) : r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function (e) { r && !r.destroyed && e.target === this && (r.wrapperEl.removeEventListener(\"transitionend\", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(s, b)) }), r.wrapperEl.addEventListener(\"transitionend\", r.onSlideToWrapperTransitionEnd)), !0 }, slideToLoop: function (e, t, s, a) { if (void 0 === e && (e = 0), void 0 === s && (s = !0), \"string\" == typeof e) { e = parseInt(e, 10) } const i = this; if (i.destroyed) return; void 0 === t && (t = i.params.speed); const r = i.grid && i.params.grid && i.params.grid.rows > 1; let n = e; if (i.params.loop) if (i.virtual && i.params.virtual.enabled) n += i.virtual.slidesBefore; else { let e; if (r) { const t = n * i.params.grid.rows; e = i.slides.filter((e => 1 * e.getAttribute(\"data-swiper-slide-index\") === t))[0].column } else e = i.getSlideIndexByData(n); const t = r ? Math.ceil(i.slides.length / i.params.grid.rows) : i.slides.length, { centeredSlides: s } = i.params; let l = i.params.slidesPerView; \"auto\" === l ? l = i.slidesPerViewDynamic() : (l = Math.ceil(parseFloat(i.params.slidesPerView, 10)), s && l % 2 == 0 && (l += 1)); let o = t - e < l; if (s && (o = o || e < Math.ceil(l / 2)), a && s && \"auto\" !== i.params.slidesPerView && !r && (o = !1), o) { const a = s ? e < i.activeIndex ? \"prev\" : \"next\" : e - i.activeIndex - 1 < i.params.slidesPerView ? \"next\" : \"prev\"; i.loopFix({ direction: a, slideTo: !0, activeSlideIndex: \"next\" === a ? e + 1 : e - t + 1, slideRealIndex: \"next\" === a ? i.realIndex : void 0 }) } if (r) { const e = n * i.params.grid.rows; n = i.slides.filter((t => 1 * t.getAttribute(\"data-swiper-slide-index\") === e))[0].column } else n = i.getSlideIndexByData(n) } return requestAnimationFrame((() => { i.slideTo(n, t, s, a) })), i }, slideNext: function (e, t, s) { void 0 === t && (t = !0); const a = this, { enabled: i, params: r, animating: n } = a; if (!i || a.destroyed) return a; void 0 === e && (e = a.params.speed); let l = r.slidesPerGroup; \"auto\" === r.slidesPerView && 1 === r.slidesPerGroup && r.slidesPerGroupAuto && (l = Math.max(a.slidesPerViewDynamic(\"current\", !0), 1)); const o = a.activeIndex < r.slidesPerGroupSkip ? 1 : l, d = a.virtual && r.virtual.enabled; if (r.loop) { if (n && !d && r.loopPreventsSliding) return !1; if (a.loopFix({ direction: \"next\" }), a._clientLeft = a.wrapperEl.clientLeft, a.activeIndex === a.slides.length - 1 && r.cssMode) return requestAnimationFrame((() => { a.slideTo(a.activeIndex + o, e, t, s) })), !0 } return r.rewind && a.isEnd ? a.slideTo(0, e, t, s) : a.slideTo(a.activeIndex + o, e, t, s) }, slidePrev: function (e, t, s) { void 0 === t && (t = !0); const a = this, { params: i, snapGrid: r, slidesGrid: n, rtlTranslate: l, enabled: o, animating: d } = a; if (!o || a.destroyed) return a; void 0 === e && (e = a.params.speed); const c = a.virtual && i.virtual.enabled; if (i.loop) { if (d && !c && i.loopPreventsSliding) return !1; a.loopFix({ direction: \"prev\" }), a._clientLeft = a.wrapperEl.clientLeft } function p(e) { return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e) } const u = p(l ? a.translate : -a.translate), m = r.map((e => p(e))); let h = r[m.indexOf(u) - 1]; if (void 0 === h && i.cssMode) { let e; r.forEach(((t, s) => { u >= t && (e = s) })), void 0 !== e && (h = r[e > 0 ? e - 1 : e]) } let f = 0; if (void 0 !== h && (f = n.indexOf(h), f < 0 && (f = a.activeIndex - 1), \"auto\" === i.slidesPerView && 1 === i.slidesPerGroup && i.slidesPerGroupAuto && (f = f - a.slidesPerViewDynamic(\"previous\", !0) + 1, f = Math.max(f, 0))), i.rewind && a.isBeginning) { const i = a.params.virtual && a.params.virtual.enabled && a.virtual ? a.virtual.slides.length - 1 : a.slides.length - 1; return a.slideTo(i, e, t, s) } return i.loop && 0 === a.activeIndex && i.cssMode ? (requestAnimationFrame((() => { a.slideTo(f, e, t, s) })), !0) : a.slideTo(f, e, t, s) }, slideReset: function (e, t, s) { void 0 === t && (t = !0); const a = this; if (!a.destroyed) return void 0 === e && (e = a.params.speed), a.slideTo(a.activeIndex, e, t, s) }, slideToClosest: function (e, t, s, a) { void 0 === t && (t = !0), void 0 === a && (a = .5); const i = this; if (i.destroyed) return; void 0 === e && (e = i.params.speed); let r = i.activeIndex; const n = Math.min(i.params.slidesPerGroupSkip, r), l = n + Math.floor((r - n) / i.params.slidesPerGroup), o = i.rtlTranslate ? i.translate : -i.translate; if (o >= i.snapGrid[l]) { const e = i.snapGrid[l]; o - e > (i.snapGrid[l + 1] - e) * a && (r += i.params.slidesPerGroup) } else { const e = i.snapGrid[l - 1]; o - e <= (i.snapGrid[l] - e) * a && (r -= i.params.slidesPerGroup) } return r = Math.max(r, 0), r = Math.min(r, i.slidesGrid.length - 1), i.slideTo(r, e, t, s) }, slideToClickedSlide: function () { const e = this; if (e.destroyed) return; const { params: t, slidesEl: s } = e, a = \"auto\" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView; let i, r = e.clickedIndex; const n = e.isElement ? \"swiper-slide\" : `.${t.slideClass}`; if (t.loop) { if (e.animating) return; i = parseInt(e.clickedSlide.getAttribute(\"data-swiper-slide-index\"), 10), t.centeredSlides ? r < e.loopedSlides - a / 2 || r > e.slides.length - e.loopedSlides + a / 2 ? (e.loopFix(), r = e.getSlideIndex(f(s, `${n}[data-swiper-slide-index=\"${i}\"]`)[0]), l((() => { e.slideTo(r) }))) : e.slideTo(r) : r > e.slides.length - a ? (e.loopFix(), r = e.getSlideIndex(f(s, `${n}[data-swiper-slide-index=\"${i}\"]`)[0]), l((() => { e.slideTo(r) }))) : e.slideTo(r) } else e.slideTo(r) } }; var Y = { loopCreate: function (e) { const t = this, { params: s, slidesEl: a } = t; if (!s.loop || t.virtual && t.params.virtual.enabled) return; const i = () => { f(a, `.${s.slideClass}, swiper-slide`).forEach(((e, t) => { e.setAttribute(\"data-swiper-slide-index\", t) })) }, r = t.grid && s.grid && s.grid.rows > 1, n = s.slidesPerGroup * (r ? s.grid.rows : 1), l = t.slides.length % n != 0, o = r && t.slides.length % s.grid.rows != 0, d = e => { for (let a = 0; a < e; a += 1) { const e = t.isElement ? v(\"swiper-slide\", [s.slideBlankClass]) : v(\"div\", [s.slideClass, s.slideBlankClass]); t.slidesEl.append(e) } }; if (l) { if (s.loopAddBlankSlides) { d(n - t.slides.length % n), t.recalcSlides(), t.updateSlides() } else g(\"Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)\"); i() } else if (o) { if (s.loopAddBlankSlides) { d(s.grid.rows - t.slides.length % s.grid.rows), t.recalcSlides(), t.updateSlides() } else g(\"Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)\"); i() } else i(); t.loopFix({ slideRealIndex: e, direction: s.centeredSlides ? void 0 : \"next\" }) }, loopFix: function (e) { let { slideRealIndex: t, slideTo: s = !0, direction: a, setTranslate: i, activeSlideIndex: r, byController: n, byMousewheel: l } = void 0 === e ? {} : e; const o = this; if (!o.params.loop) return; o.emit(\"beforeLoopFix\"); const { slides: d, allowSlidePrev: c, allowSlideNext: p, slidesEl: u, params: m } = o, { centeredSlides: h } = m; if (o.allowSlidePrev = !0, o.allowSlideNext = !0, o.virtual && m.virtual.enabled) return s && (m.centeredSlides || 0 !== o.snapIndex ? m.centeredSlides && o.snapIndex < m.slidesPerView ? o.slideTo(o.virtual.slides.length + o.snapIndex, 0, !1, !0) : o.snapIndex === o.snapGrid.length - 1 && o.slideTo(o.virtual.slidesBefore, 0, !1, !0) : o.slideTo(o.virtual.slides.length, 0, !1, !0)), o.allowSlidePrev = c, o.allowSlideNext = p, void o.emit(\"loopFix\"); let f = m.slidesPerView; \"auto\" === f ? f = o.slidesPerViewDynamic() : (f = Math.ceil(parseFloat(m.slidesPerView, 10)), h && f % 2 == 0 && (f += 1)); const v = m.slidesPerGroupAuto ? f : m.slidesPerGroup; let w = v; w % v != 0 && (w += v - w % v), w += m.loopAdditionalSlides, o.loopedSlides = w; const b = o.grid && m.grid && m.grid.rows > 1; d.length < f + w ? g(\"Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters\") : b && \"row\" === m.grid.fill && g(\"Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`\"); const y = [], E = []; let x = o.activeIndex; void 0 === r ? r = o.getSlideIndex(d.filter((e => e.classList.contains(m.slideActiveClass)))[0]) : x = r; const S = \"next\" === a || !a, T = \"prev\" === a || !a; let M = 0, C = 0; const P = b ? Math.ceil(d.length / m.grid.rows) : d.length, L = (b ? d[r].column : r) + (h && void 0 === i ? -f / 2 + .5 : 0); if (L < w) { M = Math.max(w - L, v); for (let e = 0; e < w - L; e += 1) { const t = e - Math.floor(e / P) * P; if (b) { const e = P - t - 1; for (let t = d.length - 1; t >= 0; t -= 1)d[t].column === e && y.push(t) } else y.push(P - t - 1) } } else if (L + f > P - w) { C = Math.max(L - (P - 2 * w), v); for (let e = 0; e < C; e += 1) { const t = e - Math.floor(e / P) * P; b ? d.forEach(((e, s) => { e.column === t && E.push(s) })) : E.push(t) } } if (o.__preventObserver__ = !0, requestAnimationFrame((() => { o.__preventObserver__ = !1 })), T && y.forEach((e => { d[e].swiperLoopMoveDOM = !0, u.prepend(d[e]), d[e].swiperLoopMoveDOM = !1 })), S && E.forEach((e => { d[e].swiperLoopMoveDOM = !0, u.append(d[e]), d[e].swiperLoopMoveDOM = !1 })), o.recalcSlides(), \"auto\" === m.slidesPerView ? o.updateSlides() : b && (y.length > 0 && T || E.length > 0 && S) && o.slides.forEach(((e, t) => { o.grid.updateSlide(t, e, o.slides) })), m.watchSlidesProgress && o.updateSlidesOffset(), s) if (y.length > 0 && T) { if (void 0 === t) { const e = o.slidesGrid[x], t = o.slidesGrid[x + M] - e; l ? o.setTranslate(o.translate - t) : (o.slideTo(x + Math.ceil(M), 0, !1, !0), i && (o.touchEventsData.startTranslate = o.touchEventsData.startTranslate - t, o.touchEventsData.currentTranslate = o.touchEventsData.currentTranslate - t)) } else if (i) { const e = b ? y.length / m.grid.rows : y.length; o.slideTo(o.activeIndex + e, 0, !1, !0), o.touchEventsData.currentTranslate = o.translate } } else if (E.length > 0 && S) if (void 0 === t) { const e = o.slidesGrid[x], t = o.slidesGrid[x - C] - e; l ? o.setTranslate(o.translate - t) : (o.slideTo(x - C, 0, !1, !0), i && (o.touchEventsData.startTranslate = o.touchEventsData.startTranslate - t, o.touchEventsData.currentTranslate = o.touchEventsData.currentTranslate - t)) } else { const e = b ? E.length / m.grid.rows : E.length; o.slideTo(o.activeIndex - e, 0, !1, !0) } if (o.allowSlidePrev = c, o.allowSlideNext = p, o.controller && o.controller.control && !n) { const e = { slideRealIndex: t, direction: a, setTranslate: i, activeSlideIndex: r, byController: !0 }; Array.isArray(o.controller.control) ? o.controller.control.forEach((t => { !t.destroyed && t.params.loop && t.loopFix({ ...e, slideTo: t.params.slidesPerView === m.slidesPerView && s }) })) : o.controller.control instanceof o.constructor && o.controller.control.params.loop && o.controller.control.loopFix({ ...e, slideTo: o.controller.control.params.slidesPerView === m.slidesPerView && s }) } o.emit(\"loopFix\") }, loopDestroy: function () { const e = this, { params: t, slidesEl: s } = e; if (!t.loop || e.virtual && e.params.virtual.enabled) return; e.recalcSlides(); const a = []; e.slides.forEach((e => { const t = void 0 === e.swiperSlideIndex ? 1 * e.getAttribute(\"data-swiper-slide-index\") : e.swiperSlideIndex; a[t] = e })), e.slides.forEach((e => { e.removeAttribute(\"data-swiper-slide-index\") })), a.forEach((e => { s.append(e) })), e.recalcSlides(), e.slideTo(e.realIndex, 0) } }; function B(e, t, s) { const a = r(), { params: i } = e, n = i.edgeSwipeDetection, l = i.edgeSwipeThreshold; return !n || !(s <= l || s >= a.innerWidth - l) || \"prevent\" === n && (t.preventDefault(), !0) } function R(e) { const t = this, s = a(); let i = e; i.originalEvent && (i = i.originalEvent); const n = t.touchEventsData; if (\"pointerdown\" === i.type) { if (null !== n.pointerId && n.pointerId !== i.pointerId) return; n.pointerId = i.pointerId } else \"touchstart\" === i.type && 1 === i.targetTouches.length && (n.touchId = i.targetTouches[0].identifier); if (\"touchstart\" === i.type) return void B(t, i, i.targetTouches[0].pageX); const { params: l, touches: d, enabled: c } = t; if (!c) return; if (!l.simulateTouch && \"mouse\" === i.pointerType) return; if (t.animating && l.preventInteractionOnTransition) return; !t.animating && l.cssMode && l.loop && t.loopFix(); let p = i.target; if (\"wrapper\" === l.touchEventsTarget && !t.wrapperEl.contains(p)) return; if (\"which\" in i && 3 === i.which) return; if (\"button\" in i && i.button > 0) return; if (n.isTouched && n.isMoved) return; const u = !!l.noSwipingClass && \"\" !== l.noSwipingClass, m = i.composedPath ? i.composedPath() : i.path; u && i.target && i.target.shadowRoot && m && (p = m[0]); const h = l.noSwipingSelector ? l.noSwipingSelector : `.${l.noSwipingClass}`, f = !(!i.target || !i.target.shadowRoot); if (l.noSwiping && (f ? function (e, t) { return void 0 === t && (t = this), function t(s) { if (!s || s === a() || s === r()) return null; s.assignedSlot && (s = s.assignedSlot); const i = s.closest(e); return i || s.getRootNode ? i || t(s.getRootNode().host) : null }(t) }(h, p) : p.closest(h))) return void (t.allowClick = !0); if (l.swipeHandler && !p.closest(l.swipeHandler)) return; d.currentX = i.pageX, d.currentY = i.pageY; const g = d.currentX, v = d.currentY; if (!B(t, i, g)) return; Object.assign(n, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), d.startX = g, d.startY = v, n.touchStartTime = o(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, l.threshold > 0 && (n.allowThresholdMove = !1); let w = !0; p.matches(n.focusableElements) && (w = !1, \"SELECT\" === p.nodeName && (n.isTouched = !1)), s.activeElement && s.activeElement.matches(n.focusableElements) && s.activeElement !== p && s.activeElement.blur(); const b = w && t.allowTouchMove && l.touchStartPreventDefault; !l.touchStartForcePreventDefault && !b || p.isContentEditable || i.preventDefault(), l.freeMode && l.freeMode.enabled && t.freeMode && t.animating && !l.cssMode && t.freeMode.onTouchStart(), t.emit(\"touchStart\", i) } function F(e) { const t = a(), s = this, i = s.touchEventsData, { params: r, touches: n, rtlTranslate: l, enabled: d } = s; if (!d) return; if (!r.simulateTouch && \"mouse\" === e.pointerType) return; let c, p = e; if (p.originalEvent && (p = p.originalEvent), \"pointermove\" === p.type) { if (null !== i.touchId) return; if (p.pointerId !== i.pointerId) return } if (\"touchmove\" === p.type) { if (c = [...p.changedTouches].filter((e => e.identifier === i.touchId))[0], !c || c.identifier !== i.touchId) return } else c = p; if (!i.isTouched) return void (i.startMoving && i.isScrolling && s.emit(\"touchMoveOpposite\", p)); const u = c.pageX, m = c.pageY; if (p.preventedByNestedSwiper) return n.startX = u, void (n.startY = m); if (!s.allowTouchMove) return p.target.matches(i.focusableElements) || (s.allowClick = !1), void (i.isTouched && (Object.assign(n, { startX: u, startY: m, currentX: u, currentY: m }), i.touchStartTime = o())); if (r.touchReleaseOnEdges && !r.loop) if (s.isVertical()) { if (m < n.startY && s.translate <= s.maxTranslate() || m > n.startY && s.translate >= s.minTranslate()) return i.isTouched = !1, void (i.isMoved = !1) } else if (u < n.startX && s.translate <= s.maxTranslate() || u > n.startX && s.translate >= s.minTranslate()) return; if (t.activeElement && p.target === t.activeElement && p.target.matches(i.focusableElements)) return i.isMoved = !0, void (s.allowClick = !1); i.allowTouchCallbacks && s.emit(\"touchMove\", p), n.previousX = n.currentX, n.previousY = n.currentY, n.currentX = u, n.currentY = m; const h = n.currentX - n.startX, f = n.currentY - n.startY; if (s.params.threshold && Math.sqrt(h ** 2 + f ** 2) < s.params.threshold) return; if (void 0 === i.isScrolling) { let e; s.isHorizontal() && n.currentY === n.startY || s.isVertical() && n.currentX === n.startX ? i.isScrolling = !1 : h * h + f * f >= 25 && (e = 180 * Math.atan2(Math.abs(f), Math.abs(h)) / Math.PI, i.isScrolling = s.isHorizontal() ? e > r.touchAngle : 90 - e > r.touchAngle) } if (i.isScrolling && s.emit(\"touchMoveOpposite\", p), void 0 === i.startMoving && (n.currentX === n.startX && n.currentY === n.startY || (i.startMoving = !0)), i.isScrolling || \"touchmove\" === p.type && i.preventTouchMoveFromPointerMove) return void (i.isTouched = !1); if (!i.startMoving) return; s.allowClick = !1, !r.cssMode && p.cancelable && p.preventDefault(), r.touchMoveStopPropagation && !r.nested && p.stopPropagation(); let g = s.isHorizontal() ? h : f, v = s.isHorizontal() ? n.currentX - n.previousX : n.currentY - n.previousY; r.oneWayMovement && (g = Math.abs(g) * (l ? 1 : -1), v = Math.abs(v) * (l ? 1 : -1)), n.diff = g, g *= r.touchRatio, l && (g = -g, v = -v); const w = s.touchesDirection; s.swipeDirection = g > 0 ? \"prev\" : \"next\", s.touchesDirection = v > 0 ? \"prev\" : \"next\"; const b = s.params.loop && !r.cssMode, y = \"next\" === s.touchesDirection && s.allowSlideNext || \"prev\" === s.touchesDirection && s.allowSlidePrev; if (!i.isMoved) { if (b && y && s.loopFix({ direction: s.swipeDirection }), i.startTranslate = s.getTranslate(), s.setTransition(0), s.animating) { const e = new window.CustomEvent(\"transitionend\", { bubbles: !0, cancelable: !0 }); s.wrapperEl.dispatchEvent(e) } i.allowMomentumBounce = !1, !r.grabCursor || !0 !== s.allowSlideNext && !0 !== s.allowSlidePrev || s.setGrabCursor(!0), s.emit(\"sliderFirstMove\", p) } if ((new Date).getTime(), i.isMoved && i.allowThresholdMove && w !== s.touchesDirection && b && y && Math.abs(g) >= 1) return Object.assign(n, { startX: u, startY: m, currentX: u, currentY: m, startTranslate: i.currentTranslate }), i.loopSwapReset = !0, void (i.startTranslate = i.currentTranslate); s.emit(\"sliderMove\", p), i.isMoved = !0, i.currentTranslate = g + i.startTranslate; let E = !0, x = r.resistanceRatio; if (r.touchReleaseOnEdges && (x = 0), g > 0 ? (b && y && i.allowThresholdMove && i.currentTranslate > (r.centeredSlides ? s.minTranslate() - s.slidesSizesGrid[s.activeIndex + 1] : s.minTranslate()) && s.loopFix({ direction: \"prev\", setTranslate: !0, activeSlideIndex: 0 }), i.currentTranslate > s.minTranslate() && (E = !1, r.resistance && (i.currentTranslate = s.minTranslate() - 1 + (-s.minTranslate() + i.startTranslate + g) ** x))) : g < 0 && (b && y && i.allowThresholdMove && i.currentTranslate < (r.centeredSlides ? s.maxTranslate() + s.slidesSizesGrid[s.slidesSizesGrid.length - 1] : s.maxTranslate()) && s.loopFix({ direction: \"next\", setTranslate: !0, activeSlideIndex: s.slides.length - (\"auto\" === r.slidesPerView ? s.slidesPerViewDynamic() : Math.ceil(parseFloat(r.slidesPerView, 10))) }), i.currentTranslate < s.maxTranslate() && (E = !1, r.resistance && (i.currentTranslate = s.maxTranslate() + 1 - (s.maxTranslate() - i.startTranslate - g) ** x))), E && (p.preventedByNestedSwiper = !0), !s.allowSlideNext && \"next\" === s.swipeDirection && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !s.allowSlidePrev && \"prev\" === s.swipeDirection && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), s.allowSlidePrev || s.allowSlideNext || (i.currentTranslate = i.startTranslate), r.threshold > 0) { if (!(Math.abs(g) > r.threshold || i.allowThresholdMove)) return void (i.currentTranslate = i.startTranslate); if (!i.allowThresholdMove) return i.allowThresholdMove = !0, n.startX = n.currentX, n.startY = n.currentY, i.currentTranslate = i.startTranslate, void (n.diff = s.isHorizontal() ? n.currentX - n.startX : n.currentY - n.startY) } r.followFinger && !r.cssMode && ((r.freeMode && r.freeMode.enabled && s.freeMode || r.watchSlidesProgress) && (s.updateActiveIndex(), s.updateSlidesClasses()), r.freeMode && r.freeMode.enabled && s.freeMode && s.freeMode.onTouchMove(), s.updateProgress(i.currentTranslate), s.setTranslate(i.currentTranslate)) } function q(e) { const t = this, s = t.touchEventsData; let a, i = e; i.originalEvent && (i = i.originalEvent); if (\"touchend\" === i.type || \"touchcancel\" === i.type) { if (a = [...i.changedTouches].filter((e => e.identifier === s.touchId))[0], !a || a.identifier !== s.touchId) return } else { if (null !== s.touchId) return; if (i.pointerId !== s.pointerId) return; a = i } if ([\"pointercancel\", \"pointerout\", \"pointerleave\", \"contextmenu\"].includes(i.type)) { if (!([\"pointercancel\", \"contextmenu\"].includes(i.type) && (t.browser.isSafari || t.browser.isWebView))) return } s.pointerId = null, s.touchId = null; const { params: r, touches: n, rtlTranslate: d, slidesGrid: c, enabled: p } = t; if (!p) return; if (!r.simulateTouch && \"mouse\" === i.pointerType) return; if (s.allowTouchCallbacks && t.emit(\"touchEnd\", i), s.allowTouchCallbacks = !1, !s.isTouched) return s.isMoved && r.grabCursor && t.setGrabCursor(!1), s.isMoved = !1, void (s.startMoving = !1); r.grabCursor && s.isMoved && s.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1); const u = o(), m = u - s.touchStartTime; if (t.allowClick) { const e = i.path || i.composedPath && i.composedPath(); t.updateClickedSlide(e && e[0] || i.target, e), t.emit(\"tap click\", i), m < 300 && u - s.lastClickTime < 300 && t.emit(\"doubleTap doubleClick\", i) } if (s.lastClickTime = o(), l((() => { t.destroyed || (t.allowClick = !0) })), !s.isTouched || !s.isMoved || !t.swipeDirection || 0 === n.diff && !s.loopSwapReset || s.currentTranslate === s.startTranslate && !s.loopSwapReset) return s.isTouched = !1, s.isMoved = !1, void (s.startMoving = !1); let h; if (s.isTouched = !1, s.isMoved = !1, s.startMoving = !1, h = r.followFinger ? d ? t.translate : -t.translate : -s.currentTranslate, r.cssMode) return; if (r.freeMode && r.freeMode.enabled) return void t.freeMode.onTouchEnd({ currentPos: h }); const f = h >= -t.maxTranslate() && !t.params.loop; let g = 0, v = t.slidesSizesGrid[0]; for (let e = 0; e < c.length; e += e < r.slidesPerGroupSkip ? 1 : r.slidesPerGroup) { const t = e < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup; void 0 !== c[e + t] ? (f || h >= c[e] && h < c[e + t]) && (g = e, v = c[e + t] - c[e]) : (f || h >= c[e]) && (g = e, v = c[c.length - 1] - c[c.length - 2]) } let w = null, b = null; r.rewind && (t.isBeginning ? b = r.virtual && r.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (w = 0)); const y = (h - c[g]) / v, E = g < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup; if (m > r.longSwipesMs) { if (!r.longSwipes) return void t.slideTo(t.activeIndex); \"next\" === t.swipeDirection && (y >= r.longSwipesRatio ? t.slideTo(r.rewind && t.isEnd ? w : g + E) : t.slideTo(g)), \"prev\" === t.swipeDirection && (y > 1 - r.longSwipesRatio ? t.slideTo(g + E) : null !== b && y < 0 && Math.abs(y) > r.longSwipesRatio ? t.slideTo(b) : t.slideTo(g)) } else { if (!r.shortSwipes) return void t.slideTo(t.activeIndex); t.navigation && (i.target === t.navigation.nextEl || i.target === t.navigation.prevEl) ? i.target === t.navigation.nextEl ? t.slideTo(g + E) : t.slideTo(g) : (\"next\" === t.swipeDirection && t.slideTo(null !== w ? w : g + E), \"prev\" === t.swipeDirection && t.slideTo(null !== b ? b : g)) } } function V() { const e = this, { params: t, el: s } = e; if (s && 0 === s.offsetWidth) return; t.breakpoints && e.setBreakpoint(); const { allowSlideNext: a, allowSlidePrev: i, snapGrid: r } = e, n = e.virtual && e.params.virtual.enabled; e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(); const l = n && t.loop; !(\"auto\" === t.slidesPerView || t.slidesPerView > 1) || !e.isEnd || e.isBeginning || e.params.centeredSlides || l ? e.params.loop && !n ? e.slideToLoop(e.realIndex, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0) : e.slideTo(e.slides.length - 1, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && (clearTimeout(e.autoplay.resizeTimeout), e.autoplay.resizeTimeout = setTimeout((() => { e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.resume() }), 500)), e.allowSlidePrev = i, e.allowSlideNext = a, e.params.watchOverflow && r !== e.snapGrid && e.checkOverflow() } function _(e) { const t = this; t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation()))) } function W() { const e = this, { wrapperEl: t, rtlTranslate: s, enabled: a } = e; if (!a) return; let i; e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, 0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses(); const r = e.maxTranslate() - e.minTranslate(); i = 0 === r ? 0 : (e.translate - e.minTranslate()) / r, i !== e.progress && e.updateProgress(s ? -e.translate : e.translate), e.emit(\"setTranslate\", e.translate, !1) } function j(e) { const t = this; k(t, e.target), t.params.cssMode || \"auto\" !== t.params.slidesPerView && !t.params.autoHeight || t.update() } function U() { const e = this; e.documentTouchHandlerProceeded || (e.documentTouchHandlerProceeded = !0, e.params.touchReleaseOnEdges && (e.el.style.touchAction = \"auto\")) } const K = (e, t) => { const s = a(), { params: i, el: r, wrapperEl: n, device: l } = e, o = !!i.nested, d = \"on\" === t ? \"addEventListener\" : \"removeEventListener\", c = t; s[d](\"touchstart\", e.onDocumentTouchStart, { passive: !1, capture: o }), r[d](\"touchstart\", e.onTouchStart, { passive: !1 }), r[d](\"pointerdown\", e.onTouchStart, { passive: !1 }), s[d](\"touchmove\", e.onTouchMove, { passive: !1, capture: o }), s[d](\"pointermove\", e.onTouchMove, { passive: !1, capture: o }), s[d](\"touchend\", e.onTouchEnd, { passive: !0 }), s[d](\"pointerup\", e.onTouchEnd, { passive: !0 }), s[d](\"pointercancel\", e.onTouchEnd, { passive: !0 }), s[d](\"touchcancel\", e.onTouchEnd, { passive: !0 }), s[d](\"pointerout\", e.onTouchEnd, { passive: !0 }), s[d](\"pointerleave\", e.onTouchEnd, { passive: !0 }), s[d](\"contextmenu\", e.onTouchEnd, { passive: !0 }), (i.preventClicks || i.preventClicksPropagation) && r[d](\"click\", e.onClick, !0), i.cssMode && n[d](\"scroll\", e.onScroll), i.updateOnWindowResize ? e[c](l.ios || l.android ? \"resize orientationchange observerUpdate\" : \"resize observerUpdate\", V, !0) : e[c](\"observerUpdate\", V, !0), r[d](\"load\", e.onLoad, { capture: !0 }) }; const Z = (e, t) => e.grid && t.grid && t.grid.rows > 1; var Q = { init: !0, direction: \"horizontal\", oneWayMovement: !1, swiperElementNodeName: \"SWIPER-CONTAINER\", touchEventsTarget: \"wrapper\", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, eventsPrefix: \"swiper\", enabled: !0, focusableElements: \"input, select, option, textarea, button, video, label\", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: \"slide\", breakpoints: void 0, breakpointsBase: \"window\", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 5, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, loop: !1, loopAddBlankSlides: !0, loopAdditionalSlides: 0, loopPreventsSliding: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: \"swiper-no-swiping\", noSwipingSelector: null, passiveListeners: !0, maxBackfaceHiddenSlides: 10, containerModifierClass: \"swiper-\", slideClass: \"swiper-slide\", slideBlankClass: \"swiper-slide-blank\", slideActiveClass: \"swiper-slide-active\", slideVisibleClass: \"swiper-slide-visible\", slideFullyVisibleClass: \"swiper-slide-fully-visible\", slideNextClass: \"swiper-slide-next\", slidePrevClass: \"swiper-slide-prev\", wrapperClass: \"swiper-wrapper\", lazyPreloaderClass: \"swiper-lazy-preloader\", lazyPreloadPrevNext: 0, runCallbacksOnInit: !0, _emitClasses: !1 }; function J(e, t) { return function (s) { void 0 === s && (s = {}); const a = Object.keys(s)[0], i = s[a]; \"object\" == typeof i && null !== i ? (!0 === e[a] && (e[a] = { enabled: !0 }), \"navigation\" === a && e[a] && e[a].enabled && !e[a].prevEl && !e[a].nextEl && (e[a].auto = !0), [\"pagination\", \"scrollbar\"].indexOf(a) >= 0 && e[a] && e[a].enabled && !e[a].el && (e[a].auto = !0), a in e && \"enabled\" in i ? (\"object\" != typeof e[a] || \"enabled\" in e[a] || (e[a].enabled = !0), e[a] || (e[a] = { enabled: !1 }), p(t, s)) : p(t, s)) : p(t, s) } } const ee = { eventsEmitter: A, update: G, translate: H, transition: { setTransition: function (e, t) { const s = this; s.params.cssMode || (s.wrapperEl.style.transitionDuration = `${e}ms`, s.wrapperEl.style.transitionDelay = 0 === e ? \"0ms\" : \"\"), s.emit(\"setTransition\", e, t) }, transitionStart: function (e, t) { void 0 === e && (e = !0); const s = this, { params: a } = s; a.cssMode || (a.autoHeight && s.updateAutoHeight(), N({ swiper: s, runCallbacks: e, direction: t, step: \"Start\" })) }, transitionEnd: function (e, t) { void 0 === e && (e = !0); const s = this, { params: a } = s; s.animating = !1, a.cssMode || (s.setTransition(0), N({ swiper: s, runCallbacks: e, direction: t, step: \"End\" })) } }, slide: X, loop: Y, grabCursor: { setGrabCursor: function (e) { const t = this; if (!t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return; const s = \"container\" === t.params.touchEventsTarget ? t.el : t.wrapperEl; t.isElement && (t.__preventObserver__ = !0), s.style.cursor = \"move\", s.style.cursor = e ? \"grabbing\" : \"grab\", t.isElement && requestAnimationFrame((() => { t.__preventObserver__ = !1 })) }, unsetGrabCursor: function () { const e = this; e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.isElement && (e.__preventObserver__ = !0), e[\"container\" === e.params.touchEventsTarget ? \"el\" : \"wrapperEl\"].style.cursor = \"\", e.isElement && requestAnimationFrame((() => { e.__preventObserver__ = !1 }))) } }, events: { attachEvents: function () { const e = this, { params: t } = e; e.onTouchStart = R.bind(e), e.onTouchMove = F.bind(e), e.onTouchEnd = q.bind(e), e.onDocumentTouchStart = U.bind(e), t.cssMode && (e.onScroll = W.bind(e)), e.onClick = _.bind(e), e.onLoad = j.bind(e), K(e, \"on\") }, detachEvents: function () { K(this, \"off\") } }, breakpoints: { setBreakpoint: function () { const e = this, { realIndex: t, initialized: s, params: a, el: i } = e, r = a.breakpoints; if (!r || r && 0 === Object.keys(r).length) return; const n = e.getBreakpoint(r, e.params.breakpointsBase, e.el); if (!n || e.currentBreakpoint === n) return; const l = (n in r ? r[n] : void 0) || e.originalParams, o = Z(e, a), d = Z(e, l), c = e.params.grabCursor, u = l.grabCursor, m = a.enabled; o && !d ? (i.classList.remove(`${a.containerModifierClass}grid`, `${a.containerModifierClass}grid-column`), e.emitContainerClasses()) : !o && d && (i.classList.add(`${a.containerModifierClass}grid`), (l.grid.fill && \"column\" === l.grid.fill || !l.grid.fill && \"column\" === a.grid.fill) && i.classList.add(`${a.containerModifierClass}grid-column`), e.emitContainerClasses()), c && !u ? e.unsetGrabCursor() : !c && u && e.setGrabCursor(), [\"navigation\", \"pagination\", \"scrollbar\"].forEach((t => { if (void 0 === l[t]) return; const s = a[t] && a[t].enabled, i = l[t] && l[t].enabled; s && !i && e[t].disable(), !s && i && e[t].enable() })); const h = l.direction && l.direction !== a.direction, f = a.loop && (l.slidesPerView !== a.slidesPerView || h), g = a.loop; h && s && e.changeDirection(), p(e.params, l); const v = e.params.enabled, w = e.params.loop; Object.assign(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), m && !v ? e.disable() : !m && v && e.enable(), e.currentBreakpoint = n, e.emit(\"_beforeBreakpoint\", l), s && (f ? (e.loopDestroy(), e.loopCreate(t), e.updateSlides()) : !g && w ? (e.loopCreate(t), e.updateSlides()) : g && !w && e.loopDestroy()), e.emit(\"breakpoint\", l) }, getBreakpoint: function (e, t, s) { if (void 0 === t && (t = \"window\"), !e || \"container\" === t && !s) return; let a = !1; const i = r(), n = \"window\" === t ? i.innerHeight : s.clientHeight, l = Object.keys(e).map((e => { if (\"string\" == typeof e && 0 === e.indexOf(\"@\")) { const t = parseFloat(e.substr(1)); return { value: n * t, point: e } } return { value: e, point: e } })); l.sort(((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10))); for (let e = 0; e < l.length; e += 1) { const { point: r, value: n } = l[e]; \"window\" === t ? i.matchMedia(`(min-width: ${n}px)`).matches && (a = r) : n <= s.clientWidth && (a = r) } return a || \"max\" } }, checkOverflow: { checkOverflow: function () { const e = this, { isLocked: t, params: s } = e, { slidesOffsetBefore: a } = s; if (a) { const t = e.slides.length - 1, s = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * a; e.isLocked = e.size > s } else e.isLocked = 1 === e.snapGrid.length; !0 === s.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === s.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? \"lock\" : \"unlock\") } }, classes: { addClasses: function () { const e = this, { classNames: t, params: s, rtl: a, el: i, device: r } = e, n = function (e, t) { const s = []; return e.forEach((e => { \"object\" == typeof e ? Object.keys(e).forEach((a => { e[a] && s.push(t + a) })) : \"string\" == typeof e && s.push(t + e) })), s }([\"initialized\", s.direction, { \"free-mode\": e.params.freeMode && s.freeMode.enabled }, { autoheight: s.autoHeight }, { rtl: a }, { grid: s.grid && s.grid.rows > 1 }, { \"grid-column\": s.grid && s.grid.rows > 1 && \"column\" === s.grid.fill }, { android: r.android }, { ios: r.ios }, { \"css-mode\": s.cssMode }, { centered: s.cssMode && s.centeredSlides }, { \"watch-progress\": s.watchSlidesProgress }], s.containerModifierClass); t.push(...n), i.classList.add(...t), e.emitContainerClasses() }, removeClasses: function () { const { el: e, classNames: t } = this; e.classList.remove(...t), this.emitContainerClasses() } } }, te = {}; class se { constructor() { let e, t; for (var s = arguments.length, i = new Array(s), r = 0; r < s; r++)i[r] = arguments[r]; 1 === i.length && i[0].constructor && \"Object\" === Object.prototype.toString.call(i[0]).slice(8, -1) ? t = i[0] : [e, t] = i, t || (t = {}), t = p({}, t), e && !t.el && (t.el = e); const n = a(); if (t.el && \"string\" == typeof t.el && n.querySelectorAll(t.el).length > 1) { const e = []; return n.querySelectorAll(t.el).forEach((s => { const a = p({}, t, { el: s }); e.push(new se(a)) })), e } const l = this; l.__swiper__ = !0, l.support = L(), l.device = I({ userAgent: t.userAgent }), l.browser = z(), l.eventsListeners = {}, l.eventsAnyListeners = [], l.modules = [...l.__modules__], t.modules && Array.isArray(t.modules) && l.modules.push(...t.modules); const o = {}; l.modules.forEach((e => { e({ params: t, swiper: l, extendParams: J(t, o), on: l.on.bind(l), once: l.once.bind(l), off: l.off.bind(l), emit: l.emit.bind(l) }) })); const d = p({}, Q, o); return l.params = p({}, d, te, t), l.originalParams = p({}, l.params), l.passedParams = p({}, t), l.params && l.params.on && Object.keys(l.params.on).forEach((e => { l.on(e, l.params.on[e]) })), l.params && l.params.onAny && l.onAny(l.params.onAny), Object.assign(l, { enabled: l.params.enabled, el: e, classNames: [], slides: [], slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal: () => \"horizontal\" === l.params.direction, isVertical: () => \"vertical\" === l.params.direction, activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, cssOverflowAdjustment() { return Math.trunc(this.translate / 2 ** 23) * 2 ** 23 }, allowSlideNext: l.params.allowSlideNext, allowSlidePrev: l.params.allowSlidePrev, touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: l.params.focusableElements, lastClickTime: 0, clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, startMoving: void 0, pointerId: null, touchId: null }, allowClick: !0, allowTouchMove: l.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), l.emit(\"_swiper\"), l.params.init && l.init(), l } getDirectionLabel(e) { return this.isHorizontal() ? e : { width: \"height\", \"margin-top\": \"margin-left\", \"margin-bottom \": \"margin-right\", \"margin-left\": \"margin-top\", \"margin-right\": \"margin-bottom\", \"padding-left\": \"padding-top\", \"padding-right\": \"padding-bottom\", marginRight: \"marginBottom\" }[e] } getSlideIndex(e) { const { slidesEl: t, params: s } = this, a = y(f(t, `.${s.slideClass}, swiper-slide`)[0]); return y(e) - a } getSlideIndexByData(e) { return this.getSlideIndex(this.slides.filter((t => 1 * t.getAttribute(\"data-swiper-slide-index\") === e))[0]) } recalcSlides() { const { slidesEl: e, params: t } = this; this.slides = f(e, `.${t.slideClass}, swiper-slide`) } enable() { const e = this; e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit(\"enable\")) } disable() { const e = this; e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit(\"disable\")) } setProgress(e, t) { const s = this; e = Math.min(Math.max(e, 0), 1); const a = s.minTranslate(), i = (s.maxTranslate() - a) * e + a; s.translateTo(i, void 0 === t ? 0 : t), s.updateActiveIndex(), s.updateSlidesClasses() } emitContainerClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = e.el.className.split(\" \").filter((t => 0 === t.indexOf(\"swiper\") || 0 === t.indexOf(e.params.containerModifierClass))); e.emit(\"_containerClasses\", t.join(\" \")) } getSlideClasses(e) { const t = this; return t.destroyed ? \"\" : e.className.split(\" \").filter((e => 0 === e.indexOf(\"swiper-slide\") || 0 === e.indexOf(t.params.slideClass))).join(\" \") } emitSlidesClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = []; e.slides.forEach((s => { const a = e.getSlideClasses(s); t.push({ slideEl: s, classNames: a }), e.emit(\"_slideClass\", s, a) })), e.emit(\"_slideClasses\", t) } slidesPerViewDynamic(e, t) { void 0 === e && (e = \"current\"), void 0 === t && (t = !1); const { params: s, slides: a, slidesGrid: i, slidesSizesGrid: r, size: n, activeIndex: l } = this; let o = 1; if (\"number\" == typeof s.slidesPerView) return s.slidesPerView; if (s.centeredSlides) { let e, t = a[l] ? Math.ceil(a[l].swiperSlideSize) : 0; for (let s = l + 1; s < a.length; s += 1)a[s] && !e && (t += Math.ceil(a[s].swiperSlideSize), o += 1, t > n && (e = !0)); for (let s = l - 1; s >= 0; s -= 1)a[s] && !e && (t += a[s].swiperSlideSize, o += 1, t > n && (e = !0)) } else if (\"current\" === e) for (let e = l + 1; e < a.length; e += 1) { (t ? i[e] + r[e] - i[l] < n : i[e] - i[l] < n) && (o += 1) } else for (let e = l - 1; e >= 0; e -= 1) { i[l] - i[e] < n && (o += 1) } return o } update() { const e = this; if (!e || e.destroyed) return; const { snapGrid: t, params: s } = e; function a() { const t = e.rtlTranslate ? -1 * e.translate : e.translate, s = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate()); e.setTranslate(s), e.updateActiveIndex(), e.updateSlidesClasses() } let i; if (s.breakpoints && e.setBreakpoint(), [...e.el.querySelectorAll('[loading=\"lazy\"]')].forEach((t => { t.complete && k(e, t) })), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), s.freeMode && s.freeMode.enabled && !s.cssMode) a(), s.autoHeight && e.updateAutoHeight(); else { if ((\"auto\" === s.slidesPerView || s.slidesPerView > 1) && e.isEnd && !s.centeredSlides) { const t = e.virtual && s.virtual.enabled ? e.virtual.slides : e.slides; i = e.slideTo(t.length - 1, 0, !1, !0) } else i = e.slideTo(e.activeIndex, 0, !1, !0); i || a() } s.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit(\"update\") } changeDirection(e, t) { void 0 === t && (t = !0); const s = this, a = s.params.direction; return e || (e = \"horizontal\" === a ? \"vertical\" : \"horizontal\"), e === a || \"horizontal\" !== e && \"vertical\" !== e || (s.el.classList.remove(`${s.params.containerModifierClass}${a}`), s.el.classList.add(`${s.params.containerModifierClass}${e}`), s.emitContainerClasses(), s.params.direction = e, s.slides.forEach((t => { \"vertical\" === e ? t.style.width = \"\" : t.style.height = \"\" })), s.emit(\"changeDirection\"), t && s.update()), s } changeLanguageDirection(e) { const t = this; t.rtl && \"rtl\" === e || !t.rtl && \"ltr\" === e || (t.rtl = \"rtl\" === e, t.rtlTranslate = \"horizontal\" === t.params.direction && t.rtl, t.rtl ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`), t.el.dir = \"rtl\") : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`), t.el.dir = \"ltr\"), t.update()) } mount(e) { const t = this; if (t.mounted) return !0; let s = e || t.params.el; if (\"string\" == typeof s && (s = document.querySelector(s)), !s) return !1; s.swiper = t, s.parentNode && s.parentNode.host && s.parentNode.host.nodeName === t.params.swiperElementNodeName.toUpperCase() && (t.isElement = !0); const a = () => `.${(t.params.wrapperClass || \"\").trim().split(\" \").join(\".\")}`; let i = (() => { if (s && s.shadowRoot && s.shadowRoot.querySelector) { return s.shadowRoot.querySelector(a()) } return f(s, a())[0] })(); return !i && t.params.createElements && (i = v(\"div\", t.params.wrapperClass), s.append(i), f(s, `.${t.params.slideClass}`).forEach((e => { i.append(e) }))), Object.assign(t, { el: s, wrapperEl: i, slidesEl: t.isElement && !s.parentNode.host.slideSlots ? s.parentNode.host : i, hostEl: t.isElement ? s.parentNode.host : s, mounted: !0, rtl: \"rtl\" === s.dir.toLowerCase() || \"rtl\" === b(s, \"direction\"), rtlTranslate: \"horizontal\" === t.params.direction && (\"rtl\" === s.dir.toLowerCase() || \"rtl\" === b(s, \"direction\")), wrongRTL: \"-webkit-box\" === b(i, \"display\") }), !0 } init(e) { const t = this; if (t.initialized) return t; if (!1 === t.mount(e)) return t; t.emit(\"beforeInit\"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(), t.attachEvents(); const s = [...t.el.querySelectorAll('[loading=\"lazy\"]')]; return t.isElement && s.push(...t.hostEl.querySelectorAll('[loading=\"lazy\"]')), s.forEach((e => { e.complete ? k(t, e) : e.addEventListener(\"load\", (e => { k(t, e.target) })) })), D(t), t.initialized = !0, D(t), t.emit(\"init\"), t.emit(\"afterInit\"), t } destroy(e, t) { void 0 === e && (e = !0), void 0 === t && (t = !0); const s = this, { params: a, el: i, wrapperEl: r, slides: n } = s; return void 0 === s.params || s.destroyed || (s.emit(\"beforeDestroy\"), s.initialized = !1, s.detachEvents(), a.loop && s.loopDestroy(), t && (s.removeClasses(), i.removeAttribute(\"style\"), r.removeAttribute(\"style\"), n && n.length && n.forEach((e => { e.classList.remove(a.slideVisibleClass, a.slideFullyVisibleClass, a.slideActiveClass, a.slideNextClass, a.slidePrevClass), e.removeAttribute(\"style\"), e.removeAttribute(\"data-swiper-slide-index\") }))), s.emit(\"destroy\"), Object.keys(s.eventsListeners).forEach((e => { s.off(e) })), !1 !== e && (s.el.swiper = null, function (e) { const t = e; Object.keys(t).forEach((e => { try { t[e] = null } catch (e) { } try { delete t[e] } catch (e) { } })) }(s)), s.destroyed = !0), null } static extendDefaults(e) { p(te, e) } static get extendedDefaults() { return te } static get defaults() { return Q } static installModule(e) { se.prototype.__modules__ || (se.prototype.__modules__ = []); const t = se.prototype.__modules__; \"function\" == typeof e && t.indexOf(e) < 0 && t.push(e) } static use(e) { return Array.isArray(e) ? (e.forEach((e => se.installModule(e))), se) : (se.installModule(e), se) } } function ae(e, t, s, a) { return e.params.createElements && Object.keys(a).forEach((i => { if (!s[i] && !0 === s.auto) { let r = f(e.el, `.${a[i]}`)[0]; r || (r = v(\"div\", a[i]), r.className = a[i], e.el.append(r)), s[i] = r, t[i] = r } })), s } function ie(e) { return void 0 === e && (e = \"\"), `.${e.trim().replace(/([\\.:!+\\/])/g, \"\\\\$1\").replace(/ /g, \".\")}` } function re(e) { const t = this, { params: s, slidesEl: a } = t; s.loop && t.loopDestroy(); const i = e => { if (\"string\" == typeof e) { const t = document.createElement(\"div\"); t.innerHTML = e, a.append(t.children[0]), t.innerHTML = \"\" } else a.append(e) }; if (\"object\" == typeof e && \"length\" in e) for (let t = 0; t < e.length; t += 1)e[t] && i(e[t]); else i(e); t.recalcSlides(), s.loop && t.loopCreate(), s.observer && !t.isElement || t.update() } function ne(e) { const t = this, { params: s, activeIndex: a, slidesEl: i } = t; s.loop && t.loopDestroy(); let r = a + 1; const n = e => { if (\"string\" == typeof e) { const t = document.createElement(\"div\"); t.innerHTML = e, i.prepend(t.children[0]), t.innerHTML = \"\" } else i.prepend(e) }; if (\"object\" == typeof e && \"length\" in e) { for (let t = 0; t < e.length; t += 1)e[t] && n(e[t]); r = a + e.length } else n(e); t.recalcSlides(), s.loop && t.loopCreate(), s.observer && !t.isElement || t.update(), t.slideTo(r, 0, !1) } function le(e, t) { const s = this, { params: a, activeIndex: i, slidesEl: r } = s; let n = i; a.loop && (n -= s.loopedSlides, s.loopDestroy(), s.recalcSlides()); const l = s.slides.length; if (e <= 0) return void s.prependSlide(t); if (e >= l) return void s.appendSlide(t); let o = n > e ? n + 1 : n; const d = []; for (let t = l - 1; t >= e; t -= 1) { const e = s.slides[t]; e.remove(), d.unshift(e) } if (\"object\" == typeof t && \"length\" in t) { for (let e = 0; e < t.length; e += 1)t[e] && r.append(t[e]); o = n > e ? n + t.length : n } else r.append(t); for (let e = 0; e < d.length; e += 1)r.append(d[e]); s.recalcSlides(), a.loop && s.loopCreate(), a.observer && !s.isElement || s.update(), a.loop ? s.slideTo(o + s.loopedSlides, 0, !1) : s.slideTo(o, 0, !1) } function oe(e) { const t = this, { params: s, activeIndex: a } = t; let i = a; s.loop && (i -= t.loopedSlides, t.loopDestroy()); let r, n = i; if (\"object\" == typeof e && \"length\" in e) { for (let s = 0; s < e.length; s += 1)r = e[s], t.slides[r] && t.slides[r].remove(), r < n && (n -= 1); n = Math.max(n, 0) } else r = e, t.slides[r] && t.slides[r].remove(), r < n && (n -= 1), n = Math.max(n, 0); t.recalcSlides(), s.loop && t.loopCreate(), s.observer && !t.isElement || t.update(), s.loop ? t.slideTo(n + t.loopedSlides, 0, !1) : t.slideTo(n, 0, !1) } function de() { const e = this, t = []; for (let s = 0; s < e.slides.length; s += 1)t.push(s); e.removeSlide(t) } function ce(e) { const { effect: t, swiper: s, on: a, setTranslate: i, setTransition: r, overwriteParams: n, perspective: l, recreateShadows: o, getEffectParams: d } = e; let c; a(\"beforeInit\", (() => { if (s.params.effect !== t) return; s.classNames.push(`${s.params.containerModifierClass}${t}`), l && l() && s.classNames.push(`${s.params.containerModifierClass}3d`); const e = n ? n() : {}; Object.assign(s.params, e), Object.assign(s.originalParams, e) })), a(\"setTranslate\", (() => { s.params.effect === t && i() })), a(\"setTransition\", ((e, a) => { s.params.effect === t && r(a) })), a(\"transitionEnd\", (() => { if (s.params.effect === t && o) { if (!d || !d().slideShadows) return; s.slides.forEach((e => { e.querySelectorAll(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").forEach((e => e.remove())) })), o() } })), a(\"virtualUpdate\", (() => { s.params.effect === t && (s.slides.length || (c = !0), requestAnimationFrame((() => { c && s.slides && s.slides.length && (i(), c = !1) }))) })) } function pe(e, t) { const s = h(t); return s !== t && (s.style.backfaceVisibility = \"hidden\", s.style[\"-webkit-backface-visibility\"] = \"hidden\"), s } function ue(e) { let { swiper: t, duration: s, transformElements: a, allSlides: i } = e; const { activeIndex: r } = t; if (t.params.virtualTranslate && 0 !== s) { let e, s = !1; e = i ? a : a.filter((e => { const s = e.classList.contains(\"swiper-slide-transform\") ? (e => { if (!e.parentElement) return t.slides.filter((t => t.shadowRoot && t.shadowRoot === e.parentNode))[0]; return e.parentElement })(e) : e; return t.getSlideIndex(s) === r })), e.forEach((e => { x(e, (() => { if (s) return; if (!t || t.destroyed) return; s = !0, t.animating = !1; const e = new window.CustomEvent(\"transitionend\", { bubbles: !0, cancelable: !0 }); t.wrapperEl.dispatchEvent(e) })) })) } } function me(e, t, s) { const a = `swiper-slide-shadow${s ? `-${s}` : \"\"}${e ? ` swiper-slide-shadow-${e}` : \"\"}`, i = h(t); let r = i.querySelector(`.${a.split(\" \").join(\".\")}`); return r || (r = v(\"div\", a.split(\" \")), i.append(r)), r } Object.keys(ee).forEach((e => { Object.keys(ee[e]).forEach((t => { se.prototype[t] = ee[e][t] })) })), se.use([function (e) { let { swiper: t, on: s, emit: a } = e; const i = r(); let n = null, l = null; const o = () => { t && !t.destroyed && t.initialized && (a(\"beforeResize\"), a(\"resize\")) }, d = () => { t && !t.destroyed && t.initialized && a(\"orientationchange\") }; s(\"init\", (() => { t.params.resizeObserver && void 0 !== i.ResizeObserver ? t && !t.destroyed && t.initialized && (n = new ResizeObserver((e => { l = i.requestAnimationFrame((() => { const { width: s, height: a } = t; let i = s, r = a; e.forEach((e => { let { contentBoxSize: s, contentRect: a, target: n } = e; n && n !== t.el || (i = a ? a.width : (s[0] || s).inlineSize, r = a ? a.height : (s[0] || s).blockSize) })), i === s && r === a || o() })) })), n.observe(t.el)) : (i.addEventListener(\"resize\", o), i.addEventListener(\"orientationchange\", d)) })), s(\"destroy\", (() => { l && i.cancelAnimationFrame(l), n && n.unobserve && t.el && (n.unobserve(t.el), n = null), i.removeEventListener(\"resize\", o), i.removeEventListener(\"orientationchange\", d) })) }, function (e) { let { swiper: t, extendParams: s, on: a, emit: i } = e; const n = [], l = r(), o = function (e, s) { void 0 === s && (s = {}); const a = new (l.MutationObserver || l.WebkitMutationObserver)((e => { if (t.__preventObserver__) return; if (1 === e.length) return void i(\"observerUpdate\", e[0]); const s = function () { i(\"observerUpdate\", e[0]) }; l.requestAnimationFrame ? l.requestAnimationFrame(s) : l.setTimeout(s, 0) })); a.observe(e, { attributes: void 0 === s.attributes || s.attributes, childList: void 0 === s.childList || s.childList, characterData: void 0 === s.characterData || s.characterData }), n.push(a) }; s({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), a(\"init\", (() => { if (t.params.observer) { if (t.params.observeParents) { const e = E(t.hostEl); for (let t = 0; t < e.length; t += 1)o(e[t]) } o(t.hostEl, { childList: t.params.observeSlideChildren }), o(t.wrapperEl, { attributes: !1 }) } })), a(\"destroy\", (() => { n.forEach((e => { e.disconnect() })), n.splice(0, n.length) })) }]); const he = [function (e) { let t, { swiper: s, extendParams: i, on: r, emit: n } = e; i({ virtual: { enabled: !1, slides: [], cache: !0, renderSlide: null, renderExternal: null, renderExternalUpdate: !0, addSlidesBefore: 0, addSlidesAfter: 0 } }); const l = a(); s.virtual = { cache: {}, from: void 0, to: void 0, slides: [], offset: 0, slidesGrid: [] }; const o = l.createElement(\"div\"); function d(e, t) { const a = s.params.virtual; if (a.cache && s.virtual.cache[t]) return s.virtual.cache[t]; let i; return a.renderSlide ? (i = a.renderSlide.call(s, e, t), \"string\" == typeof i && (o.innerHTML = i, i = o.children[0])) : i = s.isElement ? v(\"swiper-slide\") : v(\"div\", s.params.slideClass), i.setAttribute(\"data-swiper-slide-index\", t), a.renderSlide || (i.innerHTML = e), a.cache && (s.virtual.cache[t] = i), i } function c(e, t) { const { slidesPerView: a, slidesPerGroup: i, centeredSlides: r, loop: l, initialSlide: o } = s.params; if (t && !l && o > 0) return; const { addSlidesBefore: c, addSlidesAfter: p } = s.params.virtual, { from: u, to: m, slides: h, slidesGrid: g, offset: v } = s.virtual; s.params.cssMode || s.updateActiveIndex(); const w = s.activeIndex || 0; let b, y, E; b = s.rtlTranslate ? \"right\" : s.isHorizontal() ? \"left\" : \"top\", r ? (y = Math.floor(a / 2) + i + p, E = Math.floor(a / 2) + i + c) : (y = a + (i - 1) + p, E = (l ? a : i) + c); let x = w - E, S = w + y; l || (x = Math.max(x, 0), S = Math.min(S, h.length - 1)); let T = (s.slidesGrid[x] || 0) - (s.slidesGrid[0] || 0); function M() { s.updateSlides(), s.updateProgress(), s.updateSlidesClasses(), n(\"virtualUpdate\") } if (l && w >= E ? (x -= E, r || (T += s.slidesGrid[0])) : l && w < E && (x = -E, r && (T += s.slidesGrid[0])), Object.assign(s.virtual, { from: x, to: S, offset: T, slidesGrid: s.slidesGrid, slidesBefore: E, slidesAfter: y }), u === x && m === S && !e) return s.slidesGrid !== g && T !== v && s.slides.forEach((e => { e.style[b] = T - Math.abs(s.cssOverflowAdjustment()) + \"px\" })), s.updateProgress(), void n(\"virtualUpdate\"); if (s.params.virtual.renderExternal) return s.params.virtual.renderExternal.call(s, { offset: T, from: x, to: S, slides: function () { const e = []; for (let t = x; t <= S; t += 1)e.push(h[t]); return e }() }), void (s.params.virtual.renderExternalUpdate ? M() : n(\"virtualUpdate\")); const C = [], P = [], L = e => { let t = e; return e < 0 ? t = h.length + e : t >= h.length && (t -= h.length), t }; if (e) s.slides.filter((e => e.matches(`.${s.params.slideClass}, swiper-slide`))).forEach((e => { e.remove() })); else for (let e = u; e <= m; e += 1)if (e < x || e > S) { const t = L(e); s.slides.filter((e => e.matches(`.${s.params.slideClass}[data-swiper-slide-index=\"${t}\"], swiper-slide[data-swiper-slide-index=\"${t}\"]`))).forEach((e => { e.remove() })) } const I = l ? -h.length : 0, z = l ? 2 * h.length : h.length; for (let t = I; t < z; t += 1)if (t >= x && t <= S) { const s = L(t); void 0 === m || e ? P.push(s) : (t > m && P.push(s), t < u && C.push(s)) } if (P.forEach((e => { s.slidesEl.append(d(h[e], e)) })), l) for (let e = C.length - 1; e >= 0; e -= 1) { const t = C[e]; s.slidesEl.prepend(d(h[t], t)) } else C.sort(((e, t) => t - e)), C.forEach((e => { s.slidesEl.prepend(d(h[e], e)) })); f(s.slidesEl, \".swiper-slide, swiper-slide\").forEach((e => { e.style[b] = T - Math.abs(s.cssOverflowAdjustment()) + \"px\" })), M() } r(\"beforeInit\", (() => { if (!s.params.virtual.enabled) return; let e; if (void 0 === s.passedParams.virtual.slides) { const t = [...s.slidesEl.children].filter((e => e.matches(`.${s.params.slideClass}, swiper-slide`))); t && t.length && (s.virtual.slides = [...t], e = !0, t.forEach(((e, t) => { e.setAttribute(\"data-swiper-slide-index\", t), s.virtual.cache[t] = e, e.remove() }))) } e || (s.virtual.slides = s.params.virtual.slides), s.classNames.push(`${s.params.containerModifierClass}virtual`), s.params.watchSlidesProgress = !0, s.originalParams.watchSlidesProgress = !0, c(!1, !0) })), r(\"setTranslate\", (() => { s.params.virtual.enabled && (s.params.cssMode && !s._immediateVirtual ? (clearTimeout(t), t = setTimeout((() => { c() }), 100)) : c()) })), r(\"init update resize\", (() => { s.params.virtual.enabled && s.params.cssMode && u(s.wrapperEl, \"--swiper-virtual-size\", `${s.virtualSize}px`) })), Object.assign(s.virtual, { appendSlide: function (e) { if (\"object\" == typeof e && \"length\" in e) for (let t = 0; t < e.length; t += 1)e[t] && s.virtual.slides.push(e[t]); else s.virtual.slides.push(e); c(!0) }, prependSlide: function (e) { const t = s.activeIndex; let a = t + 1, i = 1; if (Array.isArray(e)) { for (let t = 0; t < e.length; t += 1)e[t] && s.virtual.slides.unshift(e[t]); a = t + e.length, i = e.length } else s.virtual.slides.unshift(e); if (s.params.virtual.cache) { const e = s.virtual.cache, t = {}; Object.keys(e).forEach((s => { const a = e[s], r = a.getAttribute(\"data-swiper-slide-index\"); r && a.setAttribute(\"data-swiper-slide-index\", parseInt(r, 10) + i), t[parseInt(s, 10) + i] = a })), s.virtual.cache = t } c(!0), s.slideTo(a, 0) }, removeSlide: function (e) { if (null == e) return; let t = s.activeIndex; if (Array.isArray(e)) for (let a = e.length - 1; a >= 0; a -= 1)s.params.virtual.cache && (delete s.virtual.cache[e[a]], Object.keys(s.virtual.cache).forEach((t => { t > e && (s.virtual.cache[t - 1] = s.virtual.cache[t], s.virtual.cache[t - 1].setAttribute(\"data-swiper-slide-index\", t - 1), delete s.virtual.cache[t]) }))), s.virtual.slides.splice(e[a], 1), e[a] < t && (t -= 1), t = Math.max(t, 0); else s.params.virtual.cache && (delete s.virtual.cache[e], Object.keys(s.virtual.cache).forEach((t => { t > e && (s.virtual.cache[t - 1] = s.virtual.cache[t], s.virtual.cache[t - 1].setAttribute(\"data-swiper-slide-index\", t - 1), delete s.virtual.cache[t]) }))), s.virtual.slides.splice(e, 1), e < t && (t -= 1), t = Math.max(t, 0); c(!0), s.slideTo(t, 0) }, removeAllSlides: function () { s.virtual.slides = [], s.params.virtual.cache && (s.virtual.cache = {}), c(!0), s.slideTo(0, 0) }, update: c }) }, function (e) { let { swiper: t, extendParams: s, on: i, emit: n } = e; const l = a(), o = r(); function d(e) { if (!t.enabled) return; const { rtlTranslate: s } = t; let a = e; a.originalEvent && (a = a.originalEvent); const i = a.keyCode || a.charCode, r = t.params.keyboard.pageUpDown, d = r && 33 === i, c = r && 34 === i, p = 37 === i, u = 39 === i, m = 38 === i, h = 40 === i; if (!t.allowSlideNext && (t.isHorizontal() && u || t.isVertical() && h || c)) return !1; if (!t.allowSlidePrev && (t.isHorizontal() && p || t.isVertical() && m || d)) return !1; if (!(a.shiftKey || a.altKey || a.ctrlKey || a.metaKey || l.activeElement && l.activeElement.nodeName && (\"input\" === l.activeElement.nodeName.toLowerCase() || \"textarea\" === l.activeElement.nodeName.toLowerCase()))) { if (t.params.keyboard.onlyInViewport && (d || c || p || u || m || h)) { let e = !1; if (E(t.el, `.${t.params.slideClass}, swiper-slide`).length > 0 && 0 === E(t.el, `.${t.params.slideActiveClass}`).length) return; const a = t.el, i = a.clientWidth, r = a.clientHeight, n = o.innerWidth, l = o.innerHeight, d = w(a); s && (d.left -= a.scrollLeft); const c = [[d.left, d.top], [d.left + i, d.top], [d.left, d.top + r], [d.left + i, d.top + r]]; for (let t = 0; t < c.length; t += 1) { const s = c[t]; if (s[0] >= 0 && s[0] <= n && s[1] >= 0 && s[1] <= l) { if (0 === s[0] && 0 === s[1]) continue; e = !0 } } if (!e) return } t.isHorizontal() ? ((d || c || p || u) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), ((c || u) && !s || (d || p) && s) && t.slideNext(), ((d || p) && !s || (c || u) && s) && t.slidePrev()) : ((d || c || m || h) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), (c || h) && t.slideNext(), (d || m) && t.slidePrev()), n(\"keyPress\", i) } } function c() { t.keyboard.enabled || (l.addEventListener(\"keydown\", d), t.keyboard.enabled = !0) } function p() { t.keyboard.enabled && (l.removeEventListener(\"keydown\", d), t.keyboard.enabled = !1) } t.keyboard = { enabled: !1 }, s({ keyboard: { enabled: !1, onlyInViewport: !0, pageUpDown: !0 } }), i(\"init\", (() => { t.params.keyboard.enabled && c() })), i(\"destroy\", (() => { t.keyboard.enabled && p() })), Object.assign(t.keyboard, { enable: c, disable: p }) }, function (e) { let { swiper: t, extendParams: s, on: a, emit: i } = e; const n = r(); let d; s({ mousewheel: { enabled: !1, releaseOnEdges: !1, invert: !1, forceToAxis: !1, sensitivity: 1, eventsTarget: \"container\", thresholdDelta: null, thresholdTime: null, noMousewheelClass: \"swiper-no-mousewheel\" } }), t.mousewheel = { enabled: !1 }; let c, p = o(); const u = []; function m() { t.enabled && (t.mouseEntered = !0) } function h() { t.enabled && (t.mouseEntered = !1) } function f(e) { return !(t.params.mousewheel.thresholdDelta && e.delta < t.params.mousewheel.thresholdDelta) && (!(t.params.mousewheel.thresholdTime && o() - p < t.params.mousewheel.thresholdTime) && (e.delta >= 6 && o() - p < 60 || (e.direction < 0 ? t.isEnd && !t.params.loop || t.animating || (t.slideNext(), i(\"scroll\", e.raw)) : t.isBeginning && !t.params.loop || t.animating || (t.slidePrev(), i(\"scroll\", e.raw)), p = (new n.Date).getTime(), !1))) } function g(e) { let s = e, a = !0; if (!t.enabled) return; if (e.target.closest(`.${t.params.mousewheel.noMousewheelClass}`)) return; const r = t.params.mousewheel; t.params.cssMode && s.preventDefault(); let n = t.el; \"container\" !== t.params.mousewheel.eventsTarget && (n = document.querySelector(t.params.mousewheel.eventsTarget)); const p = n && n.contains(s.target); if (!t.mouseEntered && !p && !r.releaseOnEdges) return !0; s.originalEvent && (s = s.originalEvent); let m = 0; const h = t.rtlTranslate ? -1 : 1, g = function (e) { let t = 0, s = 0, a = 0, i = 0; return \"detail\" in e && (s = e.detail), \"wheelDelta\" in e && (s = -e.wheelDelta / 120), \"wheelDeltaY\" in e && (s = -e.wheelDeltaY / 120), \"wheelDeltaX\" in e && (t = -e.wheelDeltaX / 120), \"axis\" in e && e.axis === e.HORIZONTAL_AXIS && (t = s, s = 0), a = 10 * t, i = 10 * s, \"deltaY\" in e && (i = e.deltaY), \"deltaX\" in e && (a = e.deltaX), e.shiftKey && !a && (a = i, i = 0), (a || i) && e.deltaMode && (1 === e.deltaMode ? (a *= 40, i *= 40) : (a *= 800, i *= 800)), a && !t && (t = a < 1 ? -1 : 1), i && !s && (s = i < 1 ? -1 : 1), { spinX: t, spinY: s, pixelX: a, pixelY: i } }(s); if (r.forceToAxis) if (t.isHorizontal()) { if (!(Math.abs(g.pixelX) > Math.abs(g.pixelY))) return !0; m = -g.pixelX * h } else { if (!(Math.abs(g.pixelY) > Math.abs(g.pixelX))) return !0; m = -g.pixelY } else m = Math.abs(g.pixelX) > Math.abs(g.pixelY) ? -g.pixelX * h : -g.pixelY; if (0 === m) return !0; r.invert && (m = -m); let v = t.getTranslate() + m * r.sensitivity; if (v >= t.minTranslate() && (v = t.minTranslate()), v <= t.maxTranslate() && (v = t.maxTranslate()), a = !!t.params.loop || !(v === t.minTranslate() || v === t.maxTranslate()), a && t.params.nested && s.stopPropagation(), t.params.freeMode && t.params.freeMode.enabled) { const e = { time: o(), delta: Math.abs(m), direction: Math.sign(m) }, a = c && e.time < c.time + 500 && e.delta <= c.delta && e.direction === c.direction; if (!a) { c = void 0; let n = t.getTranslate() + m * r.sensitivity; const o = t.isBeginning, p = t.isEnd; if (n >= t.minTranslate() && (n = t.minTranslate()), n <= t.maxTranslate() && (n = t.maxTranslate()), t.setTransition(0), t.setTranslate(n), t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses(), (!o && t.isBeginning || !p && t.isEnd) && t.updateSlidesClasses(), t.params.loop && t.loopFix({ direction: e.direction < 0 ? \"next\" : \"prev\", byMousewheel: !0 }), t.params.freeMode.sticky) { clearTimeout(d), d = void 0, u.length >= 15 && u.shift(); const s = u.length ? u[u.length - 1] : void 0, a = u[0]; if (u.push(e), s && (e.delta > s.delta || e.direction !== s.direction)) u.splice(0); else if (u.length >= 15 && e.time - a.time < 500 && a.delta - e.delta >= 1 && e.delta <= 6) { const s = m > 0 ? .8 : .2; c = e, u.splice(0), d = l((() => { t.slideToClosest(t.params.speed, !0, void 0, s) }), 0) } d || (d = l((() => { c = e, u.splice(0), t.slideToClosest(t.params.speed, !0, void 0, .5) }), 500)) } if (a || i(\"scroll\", s), t.params.autoplay && t.params.autoplayDisableOnInteraction && t.autoplay.stop(), r.releaseOnEdges && (n === t.minTranslate() || n === t.maxTranslate())) return !0 } } else { const s = { time: o(), delta: Math.abs(m), direction: Math.sign(m), raw: e }; u.length >= 2 && u.shift(); const a = u.length ? u[u.length - 1] : void 0; if (u.push(s), a ? (s.direction !== a.direction || s.delta > a.delta || s.time > a.time + 150) && f(s) : f(s), function (e) { const s = t.params.mousewheel; if (e.direction < 0) { if (t.isEnd && !t.params.loop && s.releaseOnEdges) return !0 } else if (t.isBeginning && !t.params.loop && s.releaseOnEdges) return !0; return !1 }(s)) return !0 } return s.preventDefault ? s.preventDefault() : s.returnValue = !1, !1 } function v(e) { let s = t.el; \"container\" !== t.params.mousewheel.eventsTarget && (s = document.querySelector(t.params.mousewheel.eventsTarget)), s[e](\"mouseenter\", m), s[e](\"mouseleave\", h), s[e](\"wheel\", g) } function w() { return t.params.cssMode ? (t.wrapperEl.removeEventListener(\"wheel\", g), !0) : !t.mousewheel.enabled && (v(\"addEventListener\"), t.mousewheel.enabled = !0, !0) } function b() { return t.params.cssMode ? (t.wrapperEl.addEventListener(event, g), !0) : !!t.mousewheel.enabled && (v(\"removeEventListener\"), t.mousewheel.enabled = !1, !0) } a(\"init\", (() => { !t.params.mousewheel.enabled && t.params.cssMode && b(), t.params.mousewheel.enabled && w() })), a(\"destroy\", (() => { t.params.cssMode && w(), t.mousewheel.enabled && b() })), Object.assign(t.mousewheel, { enable: w, disable: b }) }, function (e) { let { swiper: t, extendParams: s, on: a, emit: i } = e; function r(e) { let s; return e && \"string\" == typeof e && t.isElement && (s = t.el.querySelector(e), s) ? s : (e && (\"string\" == typeof e && (s = [...document.querySelectorAll(e)]), t.params.uniqueNavElements && \"string\" == typeof e && s && s.length > 1 && 1 === t.el.querySelectorAll(e).length ? s = t.el.querySelector(e) : s && 1 === s.length && (s = s[0])), e && !s ? e : s) } function n(e, s) { const a = t.params.navigation; (e = T(e)).forEach((e => { e && (e.classList[s ? \"add\" : \"remove\"](...a.disabledClass.split(\" \")), \"BUTTON\" === e.tagName && (e.disabled = s), t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? \"add\" : \"remove\"](a.lockClass)) })) } function l() { const { nextEl: e, prevEl: s } = t.navigation; if (t.params.loop) return n(s, !1), void n(e, !1); n(s, t.isBeginning && !t.params.rewind), n(e, t.isEnd && !t.params.rewind) } function o(e) { e.preventDefault(), (!t.isBeginning || t.params.loop || t.params.rewind) && (t.slidePrev(), i(\"navigationPrev\")) } function d(e) { e.preventDefault(), (!t.isEnd || t.params.loop || t.params.rewind) && (t.slideNext(), i(\"navigationNext\")) } function c() { const e = t.params.navigation; if (t.params.navigation = ae(t, t.originalParams.navigation, t.params.navigation, { nextEl: \"swiper-button-next\", prevEl: \"swiper-button-prev\" }), !e.nextEl && !e.prevEl) return; let s = r(e.nextEl), a = r(e.prevEl); Object.assign(t.navigation, { nextEl: s, prevEl: a }), s = T(s), a = T(a); const i = (s, a) => { s && s.addEventListener(\"click\", \"next\" === a ? d : o), !t.enabled && s && s.classList.add(...e.lockClass.split(\" \")) }; s.forEach((e => i(e, \"next\"))), a.forEach((e => i(e, \"prev\"))) } function p() { let { nextEl: e, prevEl: s } = t.navigation; e = T(e), s = T(s); const a = (e, s) => { e.removeEventListener(\"click\", \"next\" === s ? d : o), e.classList.remove(...t.params.navigation.disabledClass.split(\" \")) }; e.forEach((e => a(e, \"next\"))), s.forEach((e => a(e, \"prev\"))) } s({ navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: \"swiper-button-disabled\", hiddenClass: \"swiper-button-hidden\", lockClass: \"swiper-button-lock\", navigationDisabledClass: \"swiper-navigation-disabled\" } }), t.navigation = { nextEl: null, prevEl: null }, a(\"init\", (() => { !1 === t.params.navigation.enabled ? u() : (c(), l()) })), a(\"toEdge fromEdge lock unlock\", (() => { l() })), a(\"destroy\", (() => { p() })), a(\"enable disable\", (() => { let { nextEl: e, prevEl: s } = t.navigation; e = T(e), s = T(s), t.enabled ? l() : [...e, ...s].filter((e => !!e)).forEach((e => e.classList.add(t.params.navigation.lockClass))) })), a(\"click\", ((e, s) => { let { nextEl: a, prevEl: r } = t.navigation; a = T(a), r = T(r); const n = s.target; if (t.params.navigation.hideOnClick && !r.includes(n) && !a.includes(n)) { if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === n || t.pagination.el.contains(n))) return; let e; a.length ? e = a[0].classList.contains(t.params.navigation.hiddenClass) : r.length && (e = r[0].classList.contains(t.params.navigation.hiddenClass)), i(!0 === e ? \"navigationShow\" : \"navigationHide\"), [...a, ...r].filter((e => !!e)).forEach((e => e.classList.toggle(t.params.navigation.hiddenClass))) } })); const u = () => { t.el.classList.add(...t.params.navigation.navigationDisabledClass.split(\" \")), p() }; Object.assign(t.navigation, { enable: () => { t.el.classList.remove(...t.params.navigation.navigationDisabledClass.split(\" \")), c(), l() }, disable: u, update: l, init: c, destroy: p }) }, function (e) { let { swiper: t, extendParams: s, on: a, emit: i } = e; const r = \"swiper-pagination\"; let n; s({ pagination: { el: null, bulletElement: \"span\", clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: \"bullets\", dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: e => e, formatFractionTotal: e => e, bulletClass: `${r}-bullet`, bulletActiveClass: `${r}-bullet-active`, modifierClass: `${r}-`, currentClass: `${r}-current`, totalClass: `${r}-total`, hiddenClass: `${r}-hidden`, progressbarFillClass: `${r}-progressbar-fill`, progressbarOppositeClass: `${r}-progressbar-opposite`, clickableClass: `${r}-clickable`, lockClass: `${r}-lock`, horizontalClass: `${r}-horizontal`, verticalClass: `${r}-vertical`, paginationDisabledClass: `${r}-disabled` } }), t.pagination = { el: null, bullets: [] }; let l = 0; function o() { return !t.params.pagination.el || !t.pagination.el || Array.isArray(t.pagination.el) && 0 === t.pagination.el.length } function d(e, s) { const { bulletActiveClass: a } = t.params.pagination; e && (e = e[(\"prev\" === s ? \"previous\" : \"next\") + \"ElementSibling\"]) && (e.classList.add(`${a}-${s}`), (e = e[(\"prev\" === s ? \"previous\" : \"next\") + \"ElementSibling\"]) && e.classList.add(`${a}-${s}-${s}`)) } function c(e) { const s = e.target.closest(ie(t.params.pagination.bulletClass)); if (!s) return; e.preventDefault(); const a = y(s) * t.params.slidesPerGroup; if (t.params.loop) { if (t.realIndex === a) return; t.slideToLoop(a) } else t.slideTo(a) } function p() { const e = t.rtl, s = t.params.pagination; if (o()) return; let a, r, c = t.pagination.el; c = T(c); const p = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length, u = t.params.loop ? Math.ceil(p / t.params.slidesPerGroup) : t.snapGrid.length; if (t.params.loop ? (r = t.previousRealIndex || 0, a = t.params.slidesPerGroup > 1 ? Math.floor(t.realIndex / t.params.slidesPerGroup) : t.realIndex) : void 0 !== t.snapIndex ? (a = t.snapIndex, r = t.previousSnapIndex) : (r = t.previousIndex || 0, a = t.activeIndex || 0), \"bullets\" === s.type && t.pagination.bullets && t.pagination.bullets.length > 0) { const i = t.pagination.bullets; let o, p, u; if (s.dynamicBullets && (n = S(i[0], t.isHorizontal() ? \"width\" : \"height\", !0), c.forEach((e => { e.style[t.isHorizontal() ? \"width\" : \"height\"] = n * (s.dynamicMainBullets + 4) + \"px\" })), s.dynamicMainBullets > 1 && void 0 !== r && (l += a - (r || 0), l > s.dynamicMainBullets - 1 ? l = s.dynamicMainBullets - 1 : l < 0 && (l = 0)), o = Math.max(a - l, 0), p = o + (Math.min(i.length, s.dynamicMainBullets) - 1), u = (p + o) / 2), i.forEach((e => { const t = [...[\"\", \"-next\", \"-next-next\", \"-prev\", \"-prev-prev\", \"-main\"].map((e => `${s.bulletActiveClass}${e}`))].map((e => \"string\" == typeof e && e.includes(\" \") ? e.split(\" \") : e)).flat(); e.classList.remove(...t) })), c.length > 1) i.forEach((e => { const i = y(e); i === a ? e.classList.add(...s.bulletActiveClass.split(\" \")) : t.isElement && e.setAttribute(\"part\", \"bullet\"), s.dynamicBullets && (i >= o && i <= p && e.classList.add(...`${s.bulletActiveClass}-main`.split(\" \")), i === o && d(e, \"prev\"), i === p && d(e, \"next\")) })); else { const e = i[a]; if (e && e.classList.add(...s.bulletActiveClass.split(\" \")), t.isElement && i.forEach(((e, t) => { e.setAttribute(\"part\", t === a ? \"bullet-active\" : \"bullet\") })), s.dynamicBullets) { const e = i[o], t = i[p]; for (let e = o; e <= p; e += 1)i[e] && i[e].classList.add(...`${s.bulletActiveClass}-main`.split(\" \")); d(e, \"prev\"), d(t, \"next\") } } if (s.dynamicBullets) { const a = Math.min(i.length, s.dynamicMainBullets + 4), r = (n * a - n) / 2 - u * n, l = e ? \"right\" : \"left\"; i.forEach((e => { e.style[t.isHorizontal() ? l : \"top\"] = `${r}px` })) } } c.forEach(((e, r) => { if (\"fraction\" === s.type && (e.querySelectorAll(ie(s.currentClass)).forEach((e => { e.textContent = s.formatFractionCurrent(a + 1) })), e.querySelectorAll(ie(s.totalClass)).forEach((e => { e.textContent = s.formatFractionTotal(u) }))), \"progressbar\" === s.type) { let i; i = s.progressbarOpposite ? t.isHorizontal() ? \"vertical\" : \"horizontal\" : t.isHorizontal() ? \"horizontal\" : \"vertical\"; const r = (a + 1) / u; let n = 1, l = 1; \"horizontal\" === i ? n = r : l = r, e.querySelectorAll(ie(s.progressbarFillClass)).forEach((e => { e.style.transform = `translate3d(0,0,0) scaleX(${n}) scaleY(${l})`, e.style.transitionDuration = `${t.params.speed}ms` })) } \"custom\" === s.type && s.renderCustom ? (e.innerHTML = s.renderCustom(t, a + 1, u), 0 === r && i(\"paginationRender\", e)) : (0 === r && i(\"paginationRender\", e), i(\"paginationUpdate\", e)), t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? \"add\" : \"remove\"](s.lockClass) })) } function u() { const e = t.params.pagination; if (o()) return; const s = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.grid && t.params.grid.rows > 1 ? t.slides.length / Math.ceil(t.params.grid.rows) : t.slides.length; let a = t.pagination.el; a = T(a); let r = \"\"; if (\"bullets\" === e.type) { let a = t.params.loop ? Math.ceil(s / t.params.slidesPerGroup) : t.snapGrid.length; t.params.freeMode && t.params.freeMode.enabled && a > s && (a = s); for (let s = 0; s < a; s += 1)e.renderBullet ? r += e.renderBullet.call(t, s, e.bulletClass) : r += `<${e.bulletElement} ${t.isElement ? 'part=\"bullet\"' : \"\"} class=\"${e.bulletClass}\"></${e.bulletElement}>` } \"fraction\" === e.type && (r = e.renderFraction ? e.renderFraction.call(t, e.currentClass, e.totalClass) : `<span class=\"${e.currentClass}\"></span> / <span class=\"${e.totalClass}\"></span>`), \"progressbar\" === e.type && (r = e.renderProgressbar ? e.renderProgressbar.call(t, e.progressbarFillClass) : `<span class=\"${e.progressbarFillClass}\"></span>`), t.pagination.bullets = [], a.forEach((s => { \"custom\" !== e.type && (s.innerHTML = r || \"\"), \"bullets\" === e.type && t.pagination.bullets.push(...s.querySelectorAll(ie(e.bulletClass))) })), \"custom\" !== e.type && i(\"paginationRender\", a[0]) } function m() { t.params.pagination = ae(t, t.originalParams.pagination, t.params.pagination, { el: \"swiper-pagination\" }); const e = t.params.pagination; if (!e.el) return; let s; \"string\" == typeof e.el && t.isElement && (s = t.el.querySelector(e.el)), s || \"string\" != typeof e.el || (s = [...document.querySelectorAll(e.el)]), s || (s = e.el), s && 0 !== s.length && (t.params.uniqueNavElements && \"string\" == typeof e.el && Array.isArray(s) && s.length > 1 && (s = [...t.el.querySelectorAll(e.el)], s.length > 1 && (s = s.filter((e => E(e, \".swiper\")[0] === t.el))[0])), Array.isArray(s) && 1 === s.length && (s = s[0]), Object.assign(t.pagination, { el: s }), s = T(s), s.forEach((s => { \"bullets\" === e.type && e.clickable && s.classList.add(...(e.clickableClass || \"\").split(\" \")), s.classList.add(e.modifierClass + e.type), s.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass), \"bullets\" === e.type && e.dynamicBullets && (s.classList.add(`${e.modifierClass}${e.type}-dynamic`), l = 0, e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)), \"progressbar\" === e.type && e.progressbarOpposite && s.classList.add(e.progressbarOppositeClass), e.clickable && s.addEventListener(\"click\", c), t.enabled || s.classList.add(e.lockClass) }))) } function h() { const e = t.params.pagination; if (o()) return; let s = t.pagination.el; s && (s = T(s), s.forEach((s => { s.classList.remove(e.hiddenClass), s.classList.remove(e.modifierClass + e.type), s.classList.remove(t.isHorizontal() ? e.horizontalClass : e.verticalClass), e.clickable && (s.classList.remove(...(e.clickableClass || \"\").split(\" \")), s.removeEventListener(\"click\", c)) }))), t.pagination.bullets && t.pagination.bullets.forEach((t => t.classList.remove(...e.bulletActiveClass.split(\" \")))) } a(\"changeDirection\", (() => { if (!t.pagination || !t.pagination.el) return; const e = t.params.pagination; let { el: s } = t.pagination; s = T(s), s.forEach((s => { s.classList.remove(e.horizontalClass, e.verticalClass), s.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass) })) })), a(\"init\", (() => { !1 === t.params.pagination.enabled ? f() : (m(), u(), p()) })), a(\"activeIndexChange\", (() => { void 0 === t.snapIndex && p() })), a(\"snapIndexChange\", (() => { p() })), a(\"snapGridLengthChange\", (() => { u(), p() })), a(\"destroy\", (() => { h() })), a(\"enable disable\", (() => { let { el: e } = t.pagination; e && (e = T(e), e.forEach((e => e.classList[t.enabled ? \"remove\" : \"add\"](t.params.pagination.lockClass)))) })), a(\"lock unlock\", (() => { p() })), a(\"click\", ((e, s) => { const a = s.target, r = T(t.pagination.el); if (t.params.pagination.el && t.params.pagination.hideOnClick && r && r.length > 0 && !a.classList.contains(t.params.pagination.bulletClass)) { if (t.navigation && (t.navigation.nextEl && a === t.navigation.nextEl || t.navigation.prevEl && a === t.navigation.prevEl)) return; const e = r[0].classList.contains(t.params.pagination.hiddenClass); i(!0 === e ? \"paginationShow\" : \"paginationHide\"), r.forEach((e => e.classList.toggle(t.params.pagination.hiddenClass))) } })); const f = () => { t.el.classList.add(t.params.pagination.paginationDisabledClass); let { el: e } = t.pagination; e && (e = T(e), e.forEach((e => e.classList.add(t.params.pagination.paginationDisabledClass)))), h() }; Object.assign(t.pagination, { enable: () => { t.el.classList.remove(t.params.pagination.paginationDisabledClass); let { el: e } = t.pagination; e && (e = T(e), e.forEach((e => e.classList.remove(t.params.pagination.paginationDisabledClass)))), m(), u(), p() }, disable: f, render: u, update: p, init: m, destroy: h }) }, function (e) { let { swiper: t, extendParams: s, on: i, emit: r } = e; const o = a(); let d, c, p, u, m = !1, h = null, f = null; function g() { if (!t.params.scrollbar.el || !t.scrollbar.el) return; const { scrollbar: e, rtlTranslate: s } = t, { dragEl: a, el: i } = e, r = t.params.scrollbar, n = t.params.loop ? t.progressLoop : t.progress; let l = c, o = (p - c) * n; s ? (o = -o, o > 0 ? (l = c - o, o = 0) : -o + c > p && (l = p + o)) : o < 0 ? (l = c + o, o = 0) : o + c > p && (l = p - o), t.isHorizontal() ? (a.style.transform = `translate3d(${o}px, 0, 0)`, a.style.width = `${l}px`) : (a.style.transform = `translate3d(0px, ${o}px, 0)`, a.style.height = `${l}px`), r.hide && (clearTimeout(h), i.style.opacity = 1, h = setTimeout((() => { i.style.opacity = 0, i.style.transitionDuration = \"400ms\" }), 1e3)) } function b() { if (!t.params.scrollbar.el || !t.scrollbar.el) return; const { scrollbar: e } = t, { dragEl: s, el: a } = e; s.style.width = \"\", s.style.height = \"\", p = t.isHorizontal() ? a.offsetWidth : a.offsetHeight, u = t.size / (t.virtualSize + t.params.slidesOffsetBefore - (t.params.centeredSlides ? t.snapGrid[0] : 0)), c = \"auto\" === t.params.scrollbar.dragSize ? p * u : parseInt(t.params.scrollbar.dragSize, 10), t.isHorizontal() ? s.style.width = `${c}px` : s.style.height = `${c}px`, a.style.display = u >= 1 ? \"none\" : \"\", t.params.scrollbar.hide && (a.style.opacity = 0), t.params.watchOverflow && t.enabled && e.el.classList[t.isLocked ? \"add\" : \"remove\"](t.params.scrollbar.lockClass) } function y(e) { return t.isHorizontal() ? e.clientX : e.clientY } function E(e) { const { scrollbar: s, rtlTranslate: a } = t, { el: i } = s; let r; r = (y(e) - w(i)[t.isHorizontal() ? \"left\" : \"top\"] - (null !== d ? d : c / 2)) / (p - c), r = Math.max(Math.min(r, 1), 0), a && (r = 1 - r); const n = t.minTranslate() + (t.maxTranslate() - t.minTranslate()) * r; t.updateProgress(n), t.setTranslate(n), t.updateActiveIndex(), t.updateSlidesClasses() } function x(e) { const s = t.params.scrollbar, { scrollbar: a, wrapperEl: i } = t, { el: n, dragEl: l } = a; m = !0, d = e.target === l ? y(e) - e.target.getBoundingClientRect()[t.isHorizontal() ? \"left\" : \"top\"] : null, e.preventDefault(), e.stopPropagation(), i.style.transitionDuration = \"100ms\", l.style.transitionDuration = \"100ms\", E(e), clearTimeout(f), n.style.transitionDuration = \"0ms\", s.hide && (n.style.opacity = 1), t.params.cssMode && (t.wrapperEl.style[\"scroll-snap-type\"] = \"none\"), r(\"scrollbarDragStart\", e) } function S(e) { const { scrollbar: s, wrapperEl: a } = t, { el: i, dragEl: n } = s; m && (e.preventDefault && e.cancelable ? e.preventDefault() : e.returnValue = !1, E(e), a.style.transitionDuration = \"0ms\", i.style.transitionDuration = \"0ms\", n.style.transitionDuration = \"0ms\", r(\"scrollbarDragMove\", e)) } function M(e) { const s = t.params.scrollbar, { scrollbar: a, wrapperEl: i } = t, { el: n } = a; m && (m = !1, t.params.cssMode && (t.wrapperEl.style[\"scroll-snap-type\"] = \"\", i.style.transitionDuration = \"\"), s.hide && (clearTimeout(f), f = l((() => { n.style.opacity = 0, n.style.transitionDuration = \"400ms\" }), 1e3)), r(\"scrollbarDragEnd\", e), s.snapOnRelease && t.slideToClosest()) } function C(e) { const { scrollbar: s, params: a } = t, i = s.el; if (!i) return; const r = i, n = !!a.passiveListeners && { passive: !1, capture: !1 }, l = !!a.passiveListeners && { passive: !0, capture: !1 }; if (!r) return; const d = \"on\" === e ? \"addEventListener\" : \"removeEventListener\"; r[d](\"pointerdown\", x, n), o[d](\"pointermove\", S, n), o[d](\"pointerup\", M, l) } function P() { const { scrollbar: e, el: s } = t; t.params.scrollbar = ae(t, t.originalParams.scrollbar, t.params.scrollbar, { el: \"swiper-scrollbar\" }); const a = t.params.scrollbar; if (!a.el) return; let i, r; if (\"string\" == typeof a.el && t.isElement && (i = t.el.querySelector(a.el)), i || \"string\" != typeof a.el) i || (i = a.el); else if (i = o.querySelectorAll(a.el), !i.length) return; t.params.uniqueNavElements && \"string\" == typeof a.el && i.length > 1 && 1 === s.querySelectorAll(a.el).length && (i = s.querySelector(a.el)), i.length > 0 && (i = i[0]), i.classList.add(t.isHorizontal() ? a.horizontalClass : a.verticalClass), i && (r = i.querySelector(ie(t.params.scrollbar.dragClass)), r || (r = v(\"div\", t.params.scrollbar.dragClass), i.append(r))), Object.assign(e, { el: i, dragEl: r }), a.draggable && t.params.scrollbar.el && t.scrollbar.el && C(\"on\"), i && i.classList[t.enabled ? \"remove\" : \"add\"](...n(t.params.scrollbar.lockClass)) } function L() { const e = t.params.scrollbar, s = t.scrollbar.el; s && s.classList.remove(...n(t.isHorizontal() ? e.horizontalClass : e.verticalClass)), t.params.scrollbar.el && t.scrollbar.el && C(\"off\") } s({ scrollbar: { el: null, dragSize: \"auto\", hide: !1, draggable: !1, snapOnRelease: !0, lockClass: \"swiper-scrollbar-lock\", dragClass: \"swiper-scrollbar-drag\", scrollbarDisabledClass: \"swiper-scrollbar-disabled\", horizontalClass: \"swiper-scrollbar-horizontal\", verticalClass: \"swiper-scrollbar-vertical\" } }), t.scrollbar = { el: null, dragEl: null }, i(\"changeDirection\", (() => { if (!t.scrollbar || !t.scrollbar.el) return; const e = t.params.scrollbar; let { el: s } = t.scrollbar; s = T(s), s.forEach((s => { s.classList.remove(e.horizontalClass, e.verticalClass), s.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass) })) })), i(\"init\", (() => { !1 === t.params.scrollbar.enabled ? I() : (P(), b(), g()) })), i(\"update resize observerUpdate lock unlock changeDirection\", (() => { b() })), i(\"setTranslate\", (() => { g() })), i(\"setTransition\", ((e, s) => { !function (e) { t.params.scrollbar.el && t.scrollbar.el && (t.scrollbar.dragEl.style.transitionDuration = `${e}ms`) }(s) })), i(\"enable disable\", (() => { const { el: e } = t.scrollbar; e && e.classList[t.enabled ? \"remove\" : \"add\"](...n(t.params.scrollbar.lockClass)) })), i(\"destroy\", (() => { L() })); const I = () => { t.el.classList.add(...n(t.params.scrollbar.scrollbarDisabledClass)), t.scrollbar.el && t.scrollbar.el.classList.add(...n(t.params.scrollbar.scrollbarDisabledClass)), L() }; Object.assign(t.scrollbar, { enable: () => { t.el.classList.remove(...n(t.params.scrollbar.scrollbarDisabledClass)), t.scrollbar.el && t.scrollbar.el.classList.remove(...n(t.params.scrollbar.scrollbarDisabledClass)), P(), b(), g() }, disable: I, updateSize: b, setTranslate: g, init: P, destroy: L }) }, function (e) { let { swiper: t, extendParams: s, on: a } = e; s({ parallax: { enabled: !1 } }); const i = \"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]\", r = (e, s) => { const { rtl: a } = t, i = a ? -1 : 1, r = e.getAttribute(\"data-swiper-parallax\") || \"0\"; let n = e.getAttribute(\"data-swiper-parallax-x\"), l = e.getAttribute(\"data-swiper-parallax-y\"); const o = e.getAttribute(\"data-swiper-parallax-scale\"), d = e.getAttribute(\"data-swiper-parallax-opacity\"), c = e.getAttribute(\"data-swiper-parallax-rotate\"); if (n || l ? (n = n || \"0\", l = l || \"0\") : t.isHorizontal() ? (n = r, l = \"0\") : (l = r, n = \"0\"), n = n.indexOf(\"%\") >= 0 ? parseInt(n, 10) * s * i + \"%\" : n * s * i + \"px\", l = l.indexOf(\"%\") >= 0 ? parseInt(l, 10) * s + \"%\" : l * s + \"px\", null != d) { const t = d - (d - 1) * (1 - Math.abs(s)); e.style.opacity = t } let p = `translate3d(${n}, ${l}, 0px)`; if (null != o) { p += ` scale(${o - (o - 1) * (1 - Math.abs(s))})` } if (c && null != c) { p += ` rotate(${c * s * -1}deg)` } e.style.transform = p }, n = () => { const { el: e, slides: s, progress: a, snapGrid: n, isElement: l } = t, o = f(e, i); t.isElement && o.push(...f(t.hostEl, i)), o.forEach((e => { r(e, a) })), s.forEach(((e, s) => { let l = e.progress; t.params.slidesPerGroup > 1 && \"auto\" !== t.params.slidesPerView && (l += Math.ceil(s / 2) - a * (n.length - 1)), l = Math.min(Math.max(l, -1), 1), e.querySelectorAll(`${i}, [data-swiper-parallax-rotate]`).forEach((e => { r(e, l) })) })) }; a(\"beforeInit\", (() => { t.params.parallax.enabled && (t.params.watchSlidesProgress = !0, t.originalParams.watchSlidesProgress = !0) })), a(\"init\", (() => { t.params.parallax.enabled && n() })), a(\"setTranslate\", (() => { t.params.parallax.enabled && n() })), a(\"setTransition\", ((e, s) => { t.params.parallax.enabled && function (e) { void 0 === e && (e = t.params.speed); const { el: s, hostEl: a } = t, r = [...s.querySelectorAll(i)]; t.isElement && r.push(...a.querySelectorAll(i)), r.forEach((t => { let s = parseInt(t.getAttribute(\"data-swiper-parallax-duration\"), 10) || e; 0 === e && (s = 0), t.style.transitionDuration = `${s}ms` })) }(s) })) }, function (e) { let { swiper: t, extendParams: s, on: a, emit: i } = e; const n = r(); s({ zoom: { enabled: !1, limitToOriginalSize: !1, maxRatio: 3, minRatio: 1, toggle: !0, containerClass: \"swiper-zoom-container\", zoomedSlideClass: \"swiper-slide-zoomed\" } }), t.zoom = { enabled: !1 }; let l, o, c = 1, p = !1; const u = [], m = { originX: 0, originY: 0, slideEl: void 0, slideWidth: void 0, slideHeight: void 0, imageEl: void 0, imageWrapEl: void 0, maxRatio: 3 }, h = { isTouched: void 0, isMoved: void 0, currentX: void 0, currentY: void 0, minX: void 0, minY: void 0, maxX: void 0, maxY: void 0, width: void 0, height: void 0, startX: void 0, startY: void 0, touchesStart: {}, touchesCurrent: {} }, g = { x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0 }; let v, b = 1; function y() { if (u.length < 2) return 1; const e = u[0].pageX, t = u[0].pageY, s = u[1].pageX, a = u[1].pageY; return Math.sqrt((s - e) ** 2 + (a - t) ** 2) } function x() { const e = t.params.zoom, s = m.imageWrapEl.getAttribute(\"data-swiper-zoom\") || e.maxRatio; if (e.limitToOriginalSize && m.imageEl && m.imageEl.naturalWidth) { const e = m.imageEl.naturalWidth / m.imageEl.offsetWidth; return Math.min(e, s) } return s } function S(e) { const s = t.isElement ? \"swiper-slide\" : `.${t.params.slideClass}`; return !!e.target.matches(s) || t.slides.filter((t => t.contains(e.target))).length > 0 } function T(e) { if (\"mouse\" === e.pointerType && u.splice(0, u.length), !S(e)) return; const s = t.params.zoom; if (l = !1, o = !1, u.push(e), !(u.length < 2)) { if (l = !0, m.scaleStart = y(), !m.slideEl) { m.slideEl = e.target.closest(`.${t.params.slideClass}, swiper-slide`), m.slideEl || (m.slideEl = t.slides[t.activeIndex]); let a = m.slideEl.querySelector(`.${s.containerClass}`); if (a && (a = a.querySelectorAll(\"picture, img, svg, canvas, .swiper-zoom-target\")[0]), m.imageEl = a, m.imageWrapEl = a ? E(m.imageEl, `.${s.containerClass}`)[0] : void 0, !m.imageWrapEl) return void (m.imageEl = void 0); m.maxRatio = x() } if (m.imageEl) { const [e, t] = function () { if (u.length < 2) return { x: null, y: null }; const e = m.imageEl.getBoundingClientRect(); return [(u[0].pageX + (u[1].pageX - u[0].pageX) / 2 - e.x - n.scrollX) / c, (u[0].pageY + (u[1].pageY - u[0].pageY) / 2 - e.y - n.scrollY) / c] }(); m.originX = e, m.originY = t, m.imageEl.style.transitionDuration = \"0ms\" } p = !0 } } function M(e) { if (!S(e)) return; const s = t.params.zoom, a = t.zoom, i = u.findIndex((t => t.pointerId === e.pointerId)); i >= 0 && (u[i] = e), u.length < 2 || (o = !0, m.scaleMove = y(), m.imageEl && (a.scale = m.scaleMove / m.scaleStart * c, a.scale > m.maxRatio && (a.scale = m.maxRatio - 1 + (a.scale - m.maxRatio + 1) ** .5), a.scale < s.minRatio && (a.scale = s.minRatio + 1 - (s.minRatio - a.scale + 1) ** .5), m.imageEl.style.transform = `translate3d(0,0,0) scale(${a.scale})`)) } function C(e) { if (!S(e)) return; if (\"mouse\" === e.pointerType && \"pointerout\" === e.type) return; const s = t.params.zoom, a = t.zoom, i = u.findIndex((t => t.pointerId === e.pointerId)); i >= 0 && u.splice(i, 1), l && o && (l = !1, o = !1, m.imageEl && (a.scale = Math.max(Math.min(a.scale, m.maxRatio), s.minRatio), m.imageEl.style.transitionDuration = `${t.params.speed}ms`, m.imageEl.style.transform = `translate3d(0,0,0) scale(${a.scale})`, c = a.scale, p = !1, a.scale > 1 && m.slideEl ? m.slideEl.classList.add(`${s.zoomedSlideClass}`) : a.scale <= 1 && m.slideEl && m.slideEl.classList.remove(`${s.zoomedSlideClass}`), 1 === a.scale && (m.originX = 0, m.originY = 0, m.slideEl = void 0))) } function P() { t.touchEventsData.preventTouchMoveFromPointerMove = !1 } function L(e) { if (!S(e) || !function (e) { const s = `.${t.params.zoom.containerClass}`; return !!e.target.matches(s) || [...t.hostEl.querySelectorAll(s)].filter((t => t.contains(e.target))).length > 0 }(e)) return; const s = t.zoom; if (!m.imageEl) return; if (!h.isTouched || !m.slideEl) return; h.isMoved || (h.width = m.imageEl.offsetWidth || m.imageEl.clientWidth, h.height = m.imageEl.offsetHeight || m.imageEl.clientHeight, h.startX = d(m.imageWrapEl, \"x\") || 0, h.startY = d(m.imageWrapEl, \"y\") || 0, m.slideWidth = m.slideEl.offsetWidth, m.slideHeight = m.slideEl.offsetHeight, m.imageWrapEl.style.transitionDuration = \"0ms\"); const a = h.width * s.scale, i = h.height * s.scale; if (a < m.slideWidth && i < m.slideHeight) return void P(); h.minX = Math.min(m.slideWidth / 2 - a / 2, 0), h.maxX = -h.minX, h.minY = Math.min(m.slideHeight / 2 - i / 2, 0), h.maxY = -h.minY, h.touchesCurrent.x = u.length > 0 ? u[0].pageX : e.pageX, h.touchesCurrent.y = u.length > 0 ? u[0].pageY : e.pageY; if (Math.max(Math.abs(h.touchesCurrent.x - h.touchesStart.x), Math.abs(h.touchesCurrent.y - h.touchesStart.y)) > 5 && (t.allowClick = !1), !h.isMoved && !p) { if (t.isHorizontal() && (Math.floor(h.minX) === Math.floor(h.startX) && h.touchesCurrent.x < h.touchesStart.x || Math.floor(h.maxX) === Math.floor(h.startX) && h.touchesCurrent.x > h.touchesStart.x)) return h.isTouched = !1, void P(); if (!t.isHorizontal() && (Math.floor(h.minY) === Math.floor(h.startY) && h.touchesCurrent.y < h.touchesStart.y || Math.floor(h.maxY) === Math.floor(h.startY) && h.touchesCurrent.y > h.touchesStart.y)) return h.isTouched = !1, void P() } e.cancelable && e.preventDefault(), e.stopPropagation(), clearTimeout(v), t.touchEventsData.preventTouchMoveFromPointerMove = !0, v = setTimeout((() => { P() })), h.isMoved = !0; const r = (s.scale - c) / (m.maxRatio - t.params.zoom.minRatio), { originX: n, originY: l } = m; h.currentX = h.touchesCurrent.x - h.touchesStart.x + h.startX + r * (h.width - 2 * n), h.currentY = h.touchesCurrent.y - h.touchesStart.y + h.startY + r * (h.height - 2 * l), h.currentX < h.minX && (h.currentX = h.minX + 1 - (h.minX - h.currentX + 1) ** .8), h.currentX > h.maxX && (h.currentX = h.maxX - 1 + (h.currentX - h.maxX + 1) ** .8), h.currentY < h.minY && (h.currentY = h.minY + 1 - (h.minY - h.currentY + 1) ** .8), h.currentY > h.maxY && (h.currentY = h.maxY - 1 + (h.currentY - h.maxY + 1) ** .8), g.prevPositionX || (g.prevPositionX = h.touchesCurrent.x), g.prevPositionY || (g.prevPositionY = h.touchesCurrent.y), g.prevTime || (g.prevTime = Date.now()), g.x = (h.touchesCurrent.x - g.prevPositionX) / (Date.now() - g.prevTime) / 2, g.y = (h.touchesCurrent.y - g.prevPositionY) / (Date.now() - g.prevTime) / 2, Math.abs(h.touchesCurrent.x - g.prevPositionX) < 2 && (g.x = 0), Math.abs(h.touchesCurrent.y - g.prevPositionY) < 2 && (g.y = 0), g.prevPositionX = h.touchesCurrent.x, g.prevPositionY = h.touchesCurrent.y, g.prevTime = Date.now(), m.imageWrapEl.style.transform = `translate3d(${h.currentX}px, ${h.currentY}px,0)` } function I() { const e = t.zoom; m.slideEl && t.activeIndex !== t.slides.indexOf(m.slideEl) && (m.imageEl && (m.imageEl.style.transform = \"translate3d(0,0,0) scale(1)\"), m.imageWrapEl && (m.imageWrapEl.style.transform = \"translate3d(0,0,0)\"), m.slideEl.classList.remove(`${t.params.zoom.zoomedSlideClass}`), e.scale = 1, c = 1, m.slideEl = void 0, m.imageEl = void 0, m.imageWrapEl = void 0, m.originX = 0, m.originY = 0) } function z(e) { const s = t.zoom, a = t.params.zoom; if (!m.slideEl) { e && e.target && (m.slideEl = e.target.closest(`.${t.params.slideClass}, swiper-slide`)), m.slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? m.slideEl = f(t.slidesEl, `.${t.params.slideActiveClass}`)[0] : m.slideEl = t.slides[t.activeIndex]); let s = m.slideEl.querySelector(`.${a.containerClass}`); s && (s = s.querySelectorAll(\"picture, img, svg, canvas, .swiper-zoom-target\")[0]), m.imageEl = s, m.imageWrapEl = s ? E(m.imageEl, `.${a.containerClass}`)[0] : void 0 } if (!m.imageEl || !m.imageWrapEl) return; let i, r, l, o, d, p, u, g, v, b, y, S, T, M, C, P, L, I; t.params.cssMode && (t.wrapperEl.style.overflow = \"hidden\", t.wrapperEl.style.touchAction = \"none\"), m.slideEl.classList.add(`${a.zoomedSlideClass}`), void 0 === h.touchesStart.x && e ? (i = e.pageX, r = e.pageY) : (i = h.touchesStart.x, r = h.touchesStart.y); const z = \"number\" == typeof e ? e : null; 1 === c && z && (i = void 0, r = void 0); const A = x(); s.scale = z || A, c = z || A, !e || 1 === c && z ? (u = 0, g = 0) : (L = m.slideEl.offsetWidth, I = m.slideEl.offsetHeight, l = w(m.slideEl).left + n.scrollX, o = w(m.slideEl).top + n.scrollY, d = l + L / 2 - i, p = o + I / 2 - r, v = m.imageEl.offsetWidth || m.imageEl.clientWidth, b = m.imageEl.offsetHeight || m.imageEl.clientHeight, y = v * s.scale, S = b * s.scale, T = Math.min(L / 2 - y / 2, 0), M = Math.min(I / 2 - S / 2, 0), C = -T, P = -M, u = d * s.scale, g = p * s.scale, u < T && (u = T), u > C && (u = C), g < M && (g = M), g > P && (g = P)), z && 1 === s.scale && (m.originX = 0, m.originY = 0), m.imageWrapEl.style.transitionDuration = \"300ms\", m.imageWrapEl.style.transform = `translate3d(${u}px, ${g}px,0)`, m.imageEl.style.transitionDuration = \"300ms\", m.imageEl.style.transform = `translate3d(0,0,0) scale(${s.scale})` } function A() { const e = t.zoom, s = t.params.zoom; if (!m.slideEl) { t.params.virtual && t.params.virtual.enabled && t.virtual ? m.slideEl = f(t.slidesEl, `.${t.params.slideActiveClass}`)[0] : m.slideEl = t.slides[t.activeIndex]; let e = m.slideEl.querySelector(`.${s.containerClass}`); e && (e = e.querySelectorAll(\"picture, img, svg, canvas, .swiper-zoom-target\")[0]), m.imageEl = e, m.imageWrapEl = e ? E(m.imageEl, `.${s.containerClass}`)[0] : void 0 } m.imageEl && m.imageWrapEl && (t.params.cssMode && (t.wrapperEl.style.overflow = \"\", t.wrapperEl.style.touchAction = \"\"), e.scale = 1, c = 1, m.imageWrapEl.style.transitionDuration = \"300ms\", m.imageWrapEl.style.transform = \"translate3d(0,0,0)\", m.imageEl.style.transitionDuration = \"300ms\", m.imageEl.style.transform = \"translate3d(0,0,0) scale(1)\", m.slideEl.classList.remove(`${s.zoomedSlideClass}`), m.slideEl = void 0, m.originX = 0, m.originY = 0) } function $(e) { const s = t.zoom; s.scale && 1 !== s.scale ? A() : z(e) } function k() { return { passiveListener: !!t.params.passiveListeners && { passive: !0, capture: !1 }, activeListenerWithCapture: !t.params.passiveListeners || { passive: !1, capture: !0 } } } function O() { const e = t.zoom; if (e.enabled) return; e.enabled = !0; const { passiveListener: s, activeListenerWithCapture: a } = k(); t.wrapperEl.addEventListener(\"pointerdown\", T, s), t.wrapperEl.addEventListener(\"pointermove\", M, a), [\"pointerup\", \"pointercancel\", \"pointerout\"].forEach((e => { t.wrapperEl.addEventListener(e, C, s) })), t.wrapperEl.addEventListener(\"pointermove\", L, a) } function D() { const e = t.zoom; if (!e.enabled) return; e.enabled = !1; const { passiveListener: s, activeListenerWithCapture: a } = k(); t.wrapperEl.removeEventListener(\"pointerdown\", T, s), t.wrapperEl.removeEventListener(\"pointermove\", M, a), [\"pointerup\", \"pointercancel\", \"pointerout\"].forEach((e => { t.wrapperEl.removeEventListener(e, C, s) })), t.wrapperEl.removeEventListener(\"pointermove\", L, a) } Object.defineProperty(t.zoom, \"scale\", { get: () => b, set(e) { if (b !== e) { const t = m.imageEl, s = m.slideEl; i(\"zoomChange\", e, t, s) } b = e } }), a(\"init\", (() => { t.params.zoom.enabled && O() })), a(\"destroy\", (() => { D() })), a(\"touchStart\", ((e, s) => { t.zoom.enabled && function (e) { const s = t.device; if (!m.imageEl) return; if (h.isTouched) return; s.android && e.cancelable && e.preventDefault(), h.isTouched = !0; const a = u.length > 0 ? u[0] : e; h.touchesStart.x = a.pageX, h.touchesStart.y = a.pageY }(s) })), a(\"touchEnd\", ((e, s) => { t.zoom.enabled && function () { const e = t.zoom; if (!m.imageEl) return; if (!h.isTouched || !h.isMoved) return h.isTouched = !1, void (h.isMoved = !1); h.isTouched = !1, h.isMoved = !1; let s = 300, a = 300; const i = g.x * s, r = h.currentX + i, n = g.y * a, l = h.currentY + n; 0 !== g.x && (s = Math.abs((r - h.currentX) / g.x)), 0 !== g.y && (a = Math.abs((l - h.currentY) / g.y)); const o = Math.max(s, a); h.currentX = r, h.currentY = l; const d = h.width * e.scale, c = h.height * e.scale; h.minX = Math.min(m.slideWidth / 2 - d / 2, 0), h.maxX = -h.minX, h.minY = Math.min(m.slideHeight / 2 - c / 2, 0), h.maxY = -h.minY, h.currentX = Math.max(Math.min(h.currentX, h.maxX), h.minX), h.currentY = Math.max(Math.min(h.currentY, h.maxY), h.minY), m.imageWrapEl.style.transitionDuration = `${o}ms`, m.imageWrapEl.style.transform = `translate3d(${h.currentX}px, ${h.currentY}px,0)` }() })), a(\"doubleTap\", ((e, s) => { !t.animating && t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && $(s) })), a(\"transitionEnd\", (() => { t.zoom.enabled && t.params.zoom.enabled && I() })), a(\"slideChange\", (() => { t.zoom.enabled && t.params.zoom.enabled && t.params.cssMode && I() })), Object.assign(t.zoom, { enable: O, disable: D, in: z, out: A, toggle: $ }) }, function (e) { let { swiper: t, extendParams: s, on: a } = e; function i(e, t) { const s = function () { let e, t, s; return (a, i) => { for (t = -1, e = a.length; e - t > 1;)s = e + t >> 1, a[s] <= i ? t = s : e = s; return e } }(); let a, i; return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function (e) { return e ? (i = s(this.x, e), a = i - 1, (e - this.x[a]) * (this.y[i] - this.y[a]) / (this.x[i] - this.x[a]) + this.y[a]) : 0 }, this } function r() { t.controller.control && t.controller.spline && (t.controller.spline = void 0, delete t.controller.spline) } s({ controller: { control: void 0, inverse: !1, by: \"slide\" } }), t.controller = { control: void 0 }, a(\"beforeInit\", (() => { if (\"undefined\" != typeof window && (\"string\" == typeof t.params.controller.control || t.params.controller.control instanceof HTMLElement)) { const e = document.querySelector(t.params.controller.control); if (e && e.swiper) t.controller.control = e.swiper; else if (e) { const s = a => { t.controller.control = a.detail[0], t.update(), e.removeEventListener(\"init\", s) }; e.addEventListener(\"init\", s) } } else t.controller.control = t.params.controller.control })), a(\"update\", (() => { r() })), a(\"resize\", (() => { r() })), a(\"observerUpdate\", (() => { r() })), a(\"setTranslate\", ((e, s, a) => { t.controller.control && !t.controller.control.destroyed && t.controller.setTranslate(s, a) })), a(\"setTransition\", ((e, s, a) => { t.controller.control && !t.controller.control.destroyed && t.controller.setTransition(s, a) })), Object.assign(t.controller, { setTranslate: function (e, s) { const a = t.controller.control; let r, n; const l = t.constructor; function o(e) { if (e.destroyed) return; const s = t.rtlTranslate ? -t.translate : t.translate; \"slide\" === t.params.controller.by && (!function (e) { t.controller.spline = t.params.loop ? new i(t.slidesGrid, e.slidesGrid) : new i(t.snapGrid, e.snapGrid) }(e), n = -t.controller.spline.interpolate(-s)), n && \"container\" !== t.params.controller.by || (r = (e.maxTranslate() - e.minTranslate()) / (t.maxTranslate() - t.minTranslate()), !Number.isNaN(r) && Number.isFinite(r) || (r = 1), n = (s - t.minTranslate()) * r + e.minTranslate()), t.params.controller.inverse && (n = e.maxTranslate() - n), e.updateProgress(n), e.setTranslate(n, t), e.updateActiveIndex(), e.updateSlidesClasses() } if (Array.isArray(a)) for (let e = 0; e < a.length; e += 1)a[e] !== s && a[e] instanceof l && o(a[e]); else a instanceof l && s !== a && o(a) }, setTransition: function (e, s) { const a = t.constructor, i = t.controller.control; let r; function n(s) { s.destroyed || (s.setTransition(e, t), 0 !== e && (s.transitionStart(), s.params.autoHeight && l((() => { s.updateAutoHeight() })), x(s.wrapperEl, (() => { i && s.transitionEnd() })))) } if (Array.isArray(i)) for (r = 0; r < i.length; r += 1)i[r] !== s && i[r] instanceof a && n(i[r]); else i instanceof a && s !== i && n(i) } }) }, function (e) { let { swiper: t, extendParams: s, on: i } = e; s({ a11y: { enabled: !0, notificationClass: \"swiper-notification\", prevSlideMessage: \"Previous slide\", nextSlideMessage: \"Next slide\", firstSlideMessage: \"This is the first slide\", lastSlideMessage: \"This is the last slide\", paginationBulletMessage: \"Go to slide {{index}}\", slideLabelMessage: \"{{index}} / {{slidesLength}}\", containerMessage: null, containerRoleDescriptionMessage: null, itemRoleDescriptionMessage: null, slideRole: \"group\", id: null } }), t.a11y = { clicked: !1 }; let r, n, l = null, o = (new Date).getTime(); function d(e) { const t = l; 0 !== t.length && (t.innerHTML = \"\", t.innerHTML = e) } function c(e) { (e = T(e)).forEach((e => { e.setAttribute(\"tabIndex\", \"0\") })) } function p(e) { (e = T(e)).forEach((e => { e.setAttribute(\"tabIndex\", \"-1\") })) } function u(e, t) { (e = T(e)).forEach((e => { e.setAttribute(\"role\", t) })) } function m(e, t) { (e = T(e)).forEach((e => { e.setAttribute(\"aria-roledescription\", t) })) } function h(e, t) { (e = T(e)).forEach((e => { e.setAttribute(\"aria-label\", t) })) } function f(e) { (e = T(e)).forEach((e => { e.setAttribute(\"aria-disabled\", !0) })) } function g(e) { (e = T(e)).forEach((e => { e.setAttribute(\"aria-disabled\", !1) })) } function w(e) { if (13 !== e.keyCode && 32 !== e.keyCode) return; const s = t.params.a11y, a = e.target; if (!t.pagination || !t.pagination.el || a !== t.pagination.el && !t.pagination.el.contains(e.target) || e.target.matches(ie(t.params.pagination.bulletClass))) { if (t.navigation && t.navigation.prevEl && t.navigation.nextEl) { const e = T(t.navigation.prevEl); T(t.navigation.nextEl).includes(a) && (t.isEnd && !t.params.loop || t.slideNext(), t.isEnd ? d(s.lastSlideMessage) : d(s.nextSlideMessage)), e.includes(a) && (t.isBeginning && !t.params.loop || t.slidePrev(), t.isBeginning ? d(s.firstSlideMessage) : d(s.prevSlideMessage)) } t.pagination && a.matches(ie(t.params.pagination.bulletClass)) && a.click() } } function b() { return t.pagination && t.pagination.bullets && t.pagination.bullets.length } function E() { return b() && t.params.pagination.clickable } const x = (e, t, s) => { c(e), \"BUTTON\" !== e.tagName && (u(e, \"button\"), e.addEventListener(\"keydown\", w)), h(e, s), function (e, t) { (e = T(e)).forEach((e => { e.setAttribute(\"aria-controls\", t) })) }(e, t) }, S = e => { n && n !== e.target && !n.contains(e.target) && (r = !0), t.a11y.clicked = !0 }, M = () => { r = !1, requestAnimationFrame((() => { requestAnimationFrame((() => { t.destroyed || (t.a11y.clicked = !1) })) })) }, C = e => { o = (new Date).getTime() }, P = e => { if (t.a11y.clicked) return; if ((new Date).getTime() - o < 100) return; const s = e.target.closest(`.${t.params.slideClass}, swiper-slide`); if (!s || !t.slides.includes(s)) return; n = s; const a = t.slides.indexOf(s) === t.activeIndex, i = t.params.watchSlidesProgress && t.visibleSlides && t.visibleSlides.includes(s); a || i || e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents || (t.isHorizontal() ? t.el.scrollLeft = 0 : t.el.scrollTop = 0, requestAnimationFrame((() => { r || (t.slideTo(t.slides.indexOf(s), 0), r = !1) }))) }, L = () => { const e = t.params.a11y; e.itemRoleDescriptionMessage && m(t.slides, e.itemRoleDescriptionMessage), e.slideRole && u(t.slides, e.slideRole); const s = t.slides.length; e.slideLabelMessage && t.slides.forEach(((a, i) => { const r = t.params.loop ? parseInt(a.getAttribute(\"data-swiper-slide-index\"), 10) : i; h(a, e.slideLabelMessage.replace(/\\{\\{index\\}\\}/, r + 1).replace(/\\{\\{slidesLength\\}\\}/, s)) })) }, I = () => { const e = t.params.a11y; t.el.append(l); const s = t.el; e.containerRoleDescriptionMessage && m(s, e.containerRoleDescriptionMessage), e.containerMessage && h(s, e.containerMessage); const i = t.wrapperEl, r = e.id || i.getAttribute(\"id\") || `swiper-wrapper-${n = 16, void 0 === n && (n = 16), \"x\".repeat(n).replace(/x/g, (() => Math.round(16 * Math.random()).toString(16)))}`; var n; const o = t.params.autoplay && t.params.autoplay.enabled ? \"off\" : \"polite\"; var d; d = r, T(i).forEach((e => { e.setAttribute(\"id\", d) })), function (e, t) { (e = T(e)).forEach((e => { e.setAttribute(\"aria-live\", t) })) }(i, o), L(); let { nextEl: c, prevEl: p } = t.navigation ? t.navigation : {}; if (c = T(c), p = T(p), c && c.forEach((t => x(t, r, e.nextSlideMessage))), p && p.forEach((t => x(t, r, e.prevSlideMessage))), E()) { T(t.pagination.el).forEach((e => { e.addEventListener(\"keydown\", w) })) } a().addEventListener(\"visibilitychange\", C), t.el.addEventListener(\"focus\", P, !0), t.el.addEventListener(\"focus\", P, !0), t.el.addEventListener(\"pointerdown\", S, !0), t.el.addEventListener(\"pointerup\", M, !0) }; i(\"beforeInit\", (() => { l = v(\"span\", t.params.a11y.notificationClass), l.setAttribute(\"aria-live\", \"assertive\"), l.setAttribute(\"aria-atomic\", \"true\") })), i(\"afterInit\", (() => { t.params.a11y.enabled && I() })), i(\"slidesLengthChange snapGridLengthChange slidesGridLengthChange\", (() => { t.params.a11y.enabled && L() })), i(\"fromEdge toEdge afterInit lock unlock\", (() => { t.params.a11y.enabled && function () { if (t.params.loop || t.params.rewind || !t.navigation) return; const { nextEl: e, prevEl: s } = t.navigation; s && (t.isBeginning ? (f(s), p(s)) : (g(s), c(s))), e && (t.isEnd ? (f(e), p(e)) : (g(e), c(e))) }() })), i(\"paginationUpdate\", (() => { t.params.a11y.enabled && function () { const e = t.params.a11y; b() && t.pagination.bullets.forEach((s => { t.params.pagination.clickable && (c(s), t.params.pagination.renderBullet || (u(s, \"button\"), h(s, e.paginationBulletMessage.replace(/\\{\\{index\\}\\}/, y(s) + 1)))), s.matches(ie(t.params.pagination.bulletActiveClass)) ? s.setAttribute(\"aria-current\", \"true\") : s.removeAttribute(\"aria-current\") })) }() })), i(\"destroy\", (() => { t.params.a11y.enabled && function () { l && l.remove(); let { nextEl: e, prevEl: s } = t.navigation ? t.navigation : {}; e = T(e), s = T(s), e && e.forEach((e => e.removeEventListener(\"keydown\", w))), s && s.forEach((e => e.removeEventListener(\"keydown\", w))), E() && T(t.pagination.el).forEach((e => { e.removeEventListener(\"keydown\", w) })); a().removeEventListener(\"visibilitychange\", C), t.el.removeEventListener(\"focus\", P, !0), t.el.removeEventListener(\"pointerdown\", S, !0), t.el.removeEventListener(\"pointerup\", M, !0) }() })) }, function (e) { let { swiper: t, extendParams: s, on: a } = e; s({ history: { enabled: !1, root: \"\", replaceState: !1, key: \"slides\", keepQuery: !1 } }); let i = !1, n = {}; const l = e => e.toString().replace(/\\s+/g, \"-\").replace(/[^\\w-]+/g, \"\").replace(/--+/g, \"-\").replace(/^-+/, \"\").replace(/-+$/, \"\"), o = e => { const t = r(); let s; s = e ? new URL(e) : t.location; const a = s.pathname.slice(1).split(\"/\").filter((e => \"\" !== e)), i = a.length; return { key: a[i - 2], value: a[i - 1] } }, d = (e, s) => { const a = r(); if (!i || !t.params.history.enabled) return; let n; n = t.params.url ? new URL(t.params.url) : a.location; const o = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index=\"${s}\"]`) : t.slides[s]; let d = l(o.getAttribute(\"data-history\")); if (t.params.history.root.length > 0) { let s = t.params.history.root; \"/\" === s[s.length - 1] && (s = s.slice(0, s.length - 1)), d = `${s}/${e ? `${e}/` : \"\"}${d}` } else n.pathname.includes(e) || (d = `${e ? `${e}/` : \"\"}${d}`); t.params.history.keepQuery && (d += n.search); const c = a.history.state; c && c.value === d || (t.params.history.replaceState ? a.history.replaceState({ value: d }, null, d) : a.history.pushState({ value: d }, null, d)) }, c = (e, s, a) => { if (s) for (let i = 0, r = t.slides.length; i < r; i += 1) { const r = t.slides[i]; if (l(r.getAttribute(\"data-history\")) === s) { const s = t.getSlideIndex(r); t.slideTo(s, e, a) } } else t.slideTo(0, e, a) }, p = () => { n = o(t.params.url), c(t.params.speed, n.value, !1) }; a(\"init\", (() => { t.params.history.enabled && (() => { const e = r(); if (t.params.history) { if (!e.history || !e.history.pushState) return t.params.history.enabled = !1, void (t.params.hashNavigation.enabled = !0); i = !0, n = o(t.params.url), n.key || n.value ? (c(0, n.value, t.params.runCallbacksOnInit), t.params.history.replaceState || e.addEventListener(\"popstate\", p)) : t.params.history.replaceState || e.addEventListener(\"popstate\", p) } })() })), a(\"destroy\", (() => { t.params.history.enabled && (() => { const e = r(); t.params.history.replaceState || e.removeEventListener(\"popstate\", p) })() })), a(\"transitionEnd _freeModeNoMomentumRelease\", (() => { i && d(t.params.history.key, t.activeIndex) })), a(\"slideChange\", (() => { i && t.params.cssMode && d(t.params.history.key, t.activeIndex) })) }, function (e) { let { swiper: t, extendParams: s, emit: i, on: n } = e, l = !1; const o = a(), d = r(); s({ hashNavigation: { enabled: !1, replaceState: !1, watchState: !1, getSlideIndex(e, s) { if (t.virtual && t.params.virtual.enabled) { const e = t.slides.filter((e => e.getAttribute(\"data-hash\") === s))[0]; if (!e) return 0; return parseInt(e.getAttribute(\"data-swiper-slide-index\"), 10) } return t.getSlideIndex(f(t.slidesEl, `.${t.params.slideClass}[data-hash=\"${s}\"], swiper-slide[data-hash=\"${s}\"]`)[0]) } } }); const c = () => { i(\"hashChange\"); const e = o.location.hash.replace(\"#\", \"\"), s = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index=\"${t.activeIndex}\"]`) : t.slides[t.activeIndex]; if (e !== (s ? s.getAttribute(\"data-hash\") : \"\")) { const s = t.params.hashNavigation.getSlideIndex(t, e); if (void 0 === s || Number.isNaN(s)) return; t.slideTo(s) } }, p = () => { if (!l || !t.params.hashNavigation.enabled) return; const e = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index=\"${t.activeIndex}\"]`) : t.slides[t.activeIndex], s = e ? e.getAttribute(\"data-hash\") || e.getAttribute(\"data-history\") : \"\"; t.params.hashNavigation.replaceState && d.history && d.history.replaceState ? (d.history.replaceState(null, null, `#${s}` || \"\"), i(\"hashSet\")) : (o.location.hash = s || \"\", i(\"hashSet\")) }; n(\"init\", (() => { t.params.hashNavigation.enabled && (() => { if (!t.params.hashNavigation.enabled || t.params.history && t.params.history.enabled) return; l = !0; const e = o.location.hash.replace(\"#\", \"\"); if (e) { const s = 0, a = t.params.hashNavigation.getSlideIndex(t, e); t.slideTo(a || 0, s, t.params.runCallbacksOnInit, !0) } t.params.hashNavigation.watchState && d.addEventListener(\"hashchange\", c) })() })), n(\"destroy\", (() => { t.params.hashNavigation.enabled && t.params.hashNavigation.watchState && d.removeEventListener(\"hashchange\", c) })), n(\"transitionEnd _freeModeNoMomentumRelease\", (() => { l && p() })), n(\"slideChange\", (() => { l && t.params.cssMode && p() })) }, function (e) { let t, s, { swiper: i, extendParams: r, on: n, emit: l, params: o } = e; i.autoplay = { running: !1, paused: !1, timeLeft: 0 }, r({ autoplay: { enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !1, stopOnLastSlide: !1, reverseDirection: !1, pauseOnMouseEnter: !1 } }); let d, c, p, u, m, h, f, g, v = o && o.autoplay ? o.autoplay.delay : 3e3, w = o && o.autoplay ? o.autoplay.delay : 3e3, b = (new Date).getTime(); function y(e) { i && !i.destroyed && i.wrapperEl && e.target === i.wrapperEl && (i.wrapperEl.removeEventListener(\"transitionend\", y), g || C()) } const E = () => { if (i.destroyed || !i.autoplay.running) return; i.autoplay.paused ? c = !0 : c && (w = d, c = !1); const e = i.autoplay.paused ? d : b + w - (new Date).getTime(); i.autoplay.timeLeft = e, l(\"autoplayTimeLeft\", e, e / v), s = requestAnimationFrame((() => { E() })) }, x = e => { if (i.destroyed || !i.autoplay.running) return; cancelAnimationFrame(s), E(); let a = void 0 === e ? i.params.autoplay.delay : e; v = i.params.autoplay.delay, w = i.params.autoplay.delay; const r = (() => { let e; if (e = i.virtual && i.params.virtual.enabled ? i.slides.filter((e => e.classList.contains(\"swiper-slide-active\")))[0] : i.slides[i.activeIndex], !e) return; return parseInt(e.getAttribute(\"data-swiper-autoplay\"), 10) })(); !Number.isNaN(r) && r > 0 && void 0 === e && (a = r, v = r, w = r), d = a; const n = i.params.speed, o = () => { i && !i.destroyed && (i.params.autoplay.reverseDirection ? !i.isBeginning || i.params.loop || i.params.rewind ? (i.slidePrev(n, !0, !0), l(\"autoplay\")) : i.params.autoplay.stopOnLastSlide || (i.slideTo(i.slides.length - 1, n, !0, !0), l(\"autoplay\")) : !i.isEnd || i.params.loop || i.params.rewind ? (i.slideNext(n, !0, !0), l(\"autoplay\")) : i.params.autoplay.stopOnLastSlide || (i.slideTo(0, n, !0, !0), l(\"autoplay\")), i.params.cssMode && (b = (new Date).getTime(), requestAnimationFrame((() => { x() })))) }; return a > 0 ? (clearTimeout(t), t = setTimeout((() => { o() }), a)) : requestAnimationFrame((() => { o() })), a }, S = () => { b = (new Date).getTime(), i.autoplay.running = !0, x(), l(\"autoplayStart\") }, T = () => { i.autoplay.running = !1, clearTimeout(t), cancelAnimationFrame(s), l(\"autoplayStop\") }, M = (e, s) => { if (i.destroyed || !i.autoplay.running) return; clearTimeout(t), e || (f = !0); const a = () => { l(\"autoplayPause\"), i.params.autoplay.waitForTransition ? i.wrapperEl.addEventListener(\"transitionend\", y) : C() }; if (i.autoplay.paused = !0, s) return h && (d = i.params.autoplay.delay), h = !1, void a(); const r = d || i.params.autoplay.delay; d = r - ((new Date).getTime() - b), i.isEnd && d < 0 && !i.params.loop || (d < 0 && (d = 0), a()) }, C = () => { i.isEnd && d < 0 && !i.params.loop || i.destroyed || !i.autoplay.running || (b = (new Date).getTime(), f ? (f = !1, x(d)) : x(), i.autoplay.paused = !1, l(\"autoplayResume\")) }, P = () => { if (i.destroyed || !i.autoplay.running) return; const e = a(); \"hidden\" === e.visibilityState && (f = !0, M(!0)), \"visible\" === e.visibilityState && C() }, L = e => { \"mouse\" === e.pointerType && (f = !0, g = !0, i.animating || i.autoplay.paused || M(!0)) }, I = e => { \"mouse\" === e.pointerType && (g = !1, i.autoplay.paused && C()) }; n(\"init\", (() => { i.params.autoplay.enabled && (i.params.autoplay.pauseOnMouseEnter && (i.el.addEventListener(\"pointerenter\", L), i.el.addEventListener(\"pointerleave\", I)), a().addEventListener(\"visibilitychange\", P), S()) })), n(\"destroy\", (() => { i.el.removeEventListener(\"pointerenter\", L), i.el.removeEventListener(\"pointerleave\", I), a().removeEventListener(\"visibilitychange\", P), i.autoplay.running && T() })), n(\"_freeModeStaticRelease\", (() => { (u || f) && C() })), n(\"_freeModeNoMomentumRelease\", (() => { i.params.autoplay.disableOnInteraction ? T() : M(!0, !0) })), n(\"beforeTransitionStart\", ((e, t, s) => { !i.destroyed && i.autoplay.running && (s || !i.params.autoplay.disableOnInteraction ? M(!0, !0) : T()) })), n(\"sliderFirstMove\", (() => { !i.destroyed && i.autoplay.running && (i.params.autoplay.disableOnInteraction ? T() : (p = !0, u = !1, f = !1, m = setTimeout((() => { f = !0, u = !0, M(!0) }), 200))) })), n(\"touchEnd\", (() => { if (!i.destroyed && i.autoplay.running && p) { if (clearTimeout(m), clearTimeout(t), i.params.autoplay.disableOnInteraction) return u = !1, void (p = !1); u && i.params.cssMode && C(), u = !1, p = !1 } })), n(\"slideChange\", (() => { !i.destroyed && i.autoplay.running && (h = !0) })), Object.assign(i.autoplay, { start: S, stop: T, pause: M, resume: C }) }, function (e) { let { swiper: t, extendParams: s, on: i } = e; s({ thumbs: { swiper: null, multipleActiveThumbs: !0, autoScrollOffset: 0, slideThumbActiveClass: \"swiper-slide-thumb-active\", thumbsContainerClass: \"swiper-thumbs\" } }); let r = !1, n = !1; function l() { const e = t.thumbs.swiper; if (!e || e.destroyed) return; const s = e.clickedIndex, a = e.clickedSlide; if (a && a.classList.contains(t.params.thumbs.slideThumbActiveClass)) return; if (null == s) return; let i; i = e.params.loop ? parseInt(e.clickedSlide.getAttribute(\"data-swiper-slide-index\"), 10) : s, t.params.loop ? t.slideToLoop(i) : t.slideTo(i) } function o() { const { thumbs: e } = t.params; if (r) return !1; r = !0; const s = t.constructor; if (e.swiper instanceof s) t.thumbs.swiper = e.swiper, Object.assign(t.thumbs.swiper.originalParams, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), Object.assign(t.thumbs.swiper.params, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), t.thumbs.swiper.update(); else if (c(e.swiper)) { const a = Object.assign({}, e.swiper); Object.assign(a, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), t.thumbs.swiper = new s(a), n = !0 } return t.thumbs.swiper.el.classList.add(t.params.thumbs.thumbsContainerClass), t.thumbs.swiper.on(\"tap\", l), !0 } function d(e) { const s = t.thumbs.swiper; if (!s || s.destroyed) return; const a = \"auto\" === s.params.slidesPerView ? s.slidesPerViewDynamic() : s.params.slidesPerView; let i = 1; const r = t.params.thumbs.slideThumbActiveClass; if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (i = t.params.slidesPerView), t.params.thumbs.multipleActiveThumbs || (i = 1), i = Math.floor(i), s.slides.forEach((e => e.classList.remove(r))), s.params.loop || s.params.virtual && s.params.virtual.enabled) for (let e = 0; e < i; e += 1)f(s.slidesEl, `[data-swiper-slide-index=\"${t.realIndex + e}\"]`).forEach((e => { e.classList.add(r) })); else for (let e = 0; e < i; e += 1)s.slides[t.realIndex + e] && s.slides[t.realIndex + e].classList.add(r); const n = t.params.thumbs.autoScrollOffset, l = n && !s.params.loop; if (t.realIndex !== s.realIndex || l) { const i = s.activeIndex; let r, o; if (s.params.loop) { const e = s.slides.filter((e => e.getAttribute(\"data-swiper-slide-index\") === `${t.realIndex}`))[0]; r = s.slides.indexOf(e), o = t.activeIndex > t.previousIndex ? \"next\" : \"prev\" } else r = t.realIndex, o = r > t.previousIndex ? \"next\" : \"prev\"; l && (r += \"next\" === o ? n : -1 * n), s.visibleSlidesIndexes && s.visibleSlidesIndexes.indexOf(r) < 0 && (s.params.centeredSlides ? r = r > i ? r - Math.floor(a / 2) + 1 : r + Math.floor(a / 2) - 1 : r > i && s.params.slidesPerGroup, s.slideTo(r, e ? 0 : void 0)) } } t.thumbs = { swiper: null }, i(\"beforeInit\", (() => { const { thumbs: e } = t.params; if (e && e.swiper) if (\"string\" == typeof e.swiper || e.swiper instanceof HTMLElement) { const s = a(), i = () => { const a = \"string\" == typeof e.swiper ? s.querySelector(e.swiper) : e.swiper; if (a && a.swiper) e.swiper = a.swiper, o(), d(!0); else if (a) { const s = i => { e.swiper = i.detail[0], a.removeEventListener(\"init\", s), o(), d(!0), e.swiper.update(), t.update() }; a.addEventListener(\"init\", s) } return a }, r = () => { if (t.destroyed) return; i() || requestAnimationFrame(r) }; requestAnimationFrame(r) } else o(), d(!0) })), i(\"slideChange update resize observerUpdate\", (() => { d() })), i(\"setTransition\", ((e, s) => { const a = t.thumbs.swiper; a && !a.destroyed && a.setTransition(s) })), i(\"beforeDestroy\", (() => { const e = t.thumbs.swiper; e && !e.destroyed && n && e.destroy() })), Object.assign(t.thumbs, { init: o, update: d }) }, function (e) { let { swiper: t, extendParams: s, emit: a, once: i } = e; s({ freeMode: { enabled: !1, momentum: !0, momentumRatio: 1, momentumBounce: !0, momentumBounceRatio: 1, momentumVelocityRatio: 1, sticky: !1, minimumVelocity: .02 } }), Object.assign(t, { freeMode: { onTouchStart: function () { if (t.params.cssMode) return; const e = t.getTranslate(); t.setTranslate(e), t.setTransition(0), t.touchEventsData.velocities.length = 0, t.freeMode.onTouchEnd({ currentPos: t.rtl ? t.translate : -t.translate }) }, onTouchMove: function () { if (t.params.cssMode) return; const { touchEventsData: e, touches: s } = t; 0 === e.velocities.length && e.velocities.push({ position: s[t.isHorizontal() ? \"startX\" : \"startY\"], time: e.touchStartTime }), e.velocities.push({ position: s[t.isHorizontal() ? \"currentX\" : \"currentY\"], time: o() }) }, onTouchEnd: function (e) { let { currentPos: s } = e; if (t.params.cssMode) return; const { params: r, wrapperEl: n, rtlTranslate: l, snapGrid: d, touchEventsData: c } = t, p = o() - c.touchStartTime; if (s < -t.minTranslate()) t.slideTo(t.activeIndex); else if (s > -t.maxTranslate()) t.slides.length < d.length ? t.slideTo(d.length - 1) : t.slideTo(t.slides.length - 1); else { if (r.freeMode.momentum) { if (c.velocities.length > 1) { const e = c.velocities.pop(), s = c.velocities.pop(), a = e.position - s.position, i = e.time - s.time; t.velocity = a / i, t.velocity /= 2, Math.abs(t.velocity) < r.freeMode.minimumVelocity && (t.velocity = 0), (i > 150 || o() - e.time > 300) && (t.velocity = 0) } else t.velocity = 0; t.velocity *= r.freeMode.momentumVelocityRatio, c.velocities.length = 0; let e = 1e3 * r.freeMode.momentumRatio; const s = t.velocity * e; let p = t.translate + s; l && (p = -p); let u, m = !1; const h = 20 * Math.abs(t.velocity) * r.freeMode.momentumBounceRatio; let f; if (p < t.maxTranslate()) r.freeMode.momentumBounce ? (p + t.maxTranslate() < -h && (p = t.maxTranslate() - h), u = t.maxTranslate(), m = !0, c.allowMomentumBounce = !0) : p = t.maxTranslate(), r.loop && r.centeredSlides && (f = !0); else if (p > t.minTranslate()) r.freeMode.momentumBounce ? (p - t.minTranslate() > h && (p = t.minTranslate() + h), u = t.minTranslate(), m = !0, c.allowMomentumBounce = !0) : p = t.minTranslate(), r.loop && r.centeredSlides && (f = !0); else if (r.freeMode.sticky) { let e; for (let t = 0; t < d.length; t += 1)if (d[t] > -p) { e = t; break } p = Math.abs(d[e] - p) < Math.abs(d[e - 1] - p) || \"next\" === t.swipeDirection ? d[e] : d[e - 1], p = -p } if (f && i(\"transitionEnd\", (() => { t.loopFix() })), 0 !== t.velocity) { if (e = l ? Math.abs((-p - t.translate) / t.velocity) : Math.abs((p - t.translate) / t.velocity), r.freeMode.sticky) { const s = Math.abs((l ? -p : p) - t.translate), a = t.slidesSizesGrid[t.activeIndex]; e = s < a ? r.speed : s < 2 * a ? 1.5 * r.speed : 2.5 * r.speed } } else if (r.freeMode.sticky) return void t.slideToClosest(); r.freeMode.momentumBounce && m ? (t.updateProgress(u), t.setTransition(e), t.setTranslate(p), t.transitionStart(!0, t.swipeDirection), t.animating = !0, x(n, (() => { t && !t.destroyed && c.allowMomentumBounce && (a(\"momentumBounce\"), t.setTransition(r.speed), setTimeout((() => { t.setTranslate(u), x(n, (() => { t && !t.destroyed && t.transitionEnd() })) }), 0)) }))) : t.velocity ? (a(\"_freeModeNoMomentumRelease\"), t.updateProgress(p), t.setTransition(e), t.setTranslate(p), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, x(n, (() => { t && !t.destroyed && t.transitionEnd() })))) : t.updateProgress(p), t.updateActiveIndex(), t.updateSlidesClasses() } else { if (r.freeMode.sticky) return void t.slideToClosest(); r.freeMode && a(\"_freeModeNoMomentumRelease\") } (!r.freeMode.momentum || p >= r.longSwipesMs) && (a(\"_freeModeStaticRelease\"), t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses()) } } } }) }, function (e) { let t, s, a, i, { swiper: r, extendParams: n, on: l } = e; n({ grid: { rows: 1, fill: \"column\" } }); const o = () => { let e = r.params.spaceBetween; return \"string\" == typeof e && e.indexOf(\"%\") >= 0 ? e = parseFloat(e.replace(\"%\", \"\")) / 100 * r.size : \"string\" == typeof e && (e = parseFloat(e)), e }; l(\"init\", (() => { i = r.params.grid && r.params.grid.rows > 1 })), l(\"update\", (() => { const { params: e, el: t } = r, s = e.grid && e.grid.rows > 1; i && !s ? (t.classList.remove(`${e.containerModifierClass}grid`, `${e.containerModifierClass}grid-column`), a = 1, r.emitContainerClasses()) : !i && s && (t.classList.add(`${e.containerModifierClass}grid`), \"column\" === e.grid.fill && t.classList.add(`${e.containerModifierClass}grid-column`), r.emitContainerClasses()), i = s })), r.grid = { initSlides: e => { const { slidesPerView: i } = r.params, { rows: n, fill: l } = r.params.grid, o = r.virtual && r.params.virtual.enabled ? r.virtual.slides.length : e.length; a = Math.floor(o / n), t = Math.floor(o / n) === o / n ? o : Math.ceil(o / n) * n, \"auto\" !== i && \"row\" === l && (t = Math.max(t, i * n)), s = t / n }, unsetSlides: () => { r.slides && r.slides.forEach((e => { e.swiperSlideGridSet && (e.style.height = \"\", e.style[r.getDirectionLabel(\"margin-top\")] = \"\") })) }, updateSlide: (e, i, n) => { const { slidesPerGroup: l } = r.params, d = o(), { rows: c, fill: p } = r.params.grid, u = r.virtual && r.params.virtual.enabled ? r.virtual.slides.length : n.length; let m, h, f; if (\"row\" === p && l > 1) { const s = Math.floor(e / (l * c)), a = e - c * l * s, r = 0 === s ? l : Math.min(Math.ceil((u - s * c * l) / c), l); f = Math.floor(a / r), h = a - f * r + s * l, m = h + f * t / c, i.style.order = m } else \"column\" === p ? (h = Math.floor(e / c), f = e - h * c, (h > a || h === a && f === c - 1) && (f += 1, f >= c && (f = 0, h += 1))) : (f = Math.floor(e / s), h = e - f * s); i.row = f, i.column = h, i.style.height = `calc((100% - ${(c - 1) * d}px) / ${c})`, i.style[r.getDirectionLabel(\"margin-top\")] = 0 !== f ? d && `${d}px` : \"\", i.swiperSlideGridSet = !0 }, updateWrapperSize: (e, s) => { const { centeredSlides: a, roundLengths: i } = r.params, n = o(), { rows: l } = r.params.grid; if (r.virtualSize = (e + n) * t, r.virtualSize = Math.ceil(r.virtualSize / l) - n, r.params.cssMode || (r.wrapperEl.style[r.getDirectionLabel(\"width\")] = `${r.virtualSize + n}px`), a) { const e = []; for (let t = 0; t < s.length; t += 1) { let a = s[t]; i && (a = Math.floor(a)), s[t] < r.virtualSize + s[0] && e.push(a) } s.splice(0, s.length), s.push(...e) } } } }, function (e) { let { swiper: t } = e; Object.assign(t, { appendSlide: re.bind(t), prependSlide: ne.bind(t), addSlide: le.bind(t), removeSlide: oe.bind(t), removeAllSlides: de.bind(t) }) }, function (e) { let { swiper: t, extendParams: s, on: a } = e; s({ fadeEffect: { crossFade: !1 } }), ce({ effect: \"fade\", swiper: t, on: a, setTranslate: () => { const { slides: e } = t; t.params.fadeEffect; for (let s = 0; s < e.length; s += 1) { const e = t.slides[s]; let a = -e.swiperSlideOffset; t.params.virtualTranslate || (a -= t.translate); let i = 0; t.isHorizontal() || (i = a, a = 0); const r = t.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(e.progress), 0) : 1 + Math.min(Math.max(e.progress, -1), 0), n = pe(0, e); n.style.opacity = r, n.style.transform = `translate3d(${a}px, ${i}px, 0px)` } }, setTransition: e => { const s = t.slides.map((e => h(e))); s.forEach((t => { t.style.transitionDuration = `${e}ms` })), ue({ swiper: t, duration: e, transformElements: s, allSlides: !0 }) }, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !t.params.cssMode }) }) }, function (e) { let { swiper: t, extendParams: s, on: a } = e; s({ cubeEffect: { slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: .94 } }); const i = (e, t, s) => { let a = s ? e.querySelector(\".swiper-slide-shadow-left\") : e.querySelector(\".swiper-slide-shadow-top\"), i = s ? e.querySelector(\".swiper-slide-shadow-right\") : e.querySelector(\".swiper-slide-shadow-bottom\"); a || (a = v(\"div\", (\"swiper-slide-shadow-cube swiper-slide-shadow-\" + (s ? \"left\" : \"top\")).split(\" \")), e.append(a)), i || (i = v(\"div\", (\"swiper-slide-shadow-cube swiper-slide-shadow-\" + (s ? \"right\" : \"bottom\")).split(\" \")), e.append(i)), a && (a.style.opacity = Math.max(-t, 0)), i && (i.style.opacity = Math.max(t, 0)) }; ce({ effect: \"cube\", swiper: t, on: a, setTranslate: () => { const { el: e, wrapperEl: s, slides: a, width: r, height: n, rtlTranslate: l, size: o, browser: d } = t, c = t.params.cubeEffect, p = t.isHorizontal(), u = t.virtual && t.params.virtual.enabled; let m, h = 0; c.shadow && (p ? (m = t.wrapperEl.querySelector(\".swiper-cube-shadow\"), m || (m = v(\"div\", \"swiper-cube-shadow\"), t.wrapperEl.append(m)), m.style.height = `${r}px`) : (m = e.querySelector(\".swiper-cube-shadow\"), m || (m = v(\"div\", \"swiper-cube-shadow\"), e.append(m)))); for (let e = 0; e < a.length; e += 1) { const s = a[e]; let r = e; u && (r = parseInt(s.getAttribute(\"data-swiper-slide-index\"), 10)); let n = 90 * r, d = Math.floor(n / 360); l && (n = -n, d = Math.floor(-n / 360)); const m = Math.max(Math.min(s.progress, 1), -1); let f = 0, g = 0, v = 0; r % 4 == 0 ? (f = 4 * -d * o, v = 0) : (r - 1) % 4 == 0 ? (f = 0, v = 4 * -d * o) : (r - 2) % 4 == 0 ? (f = o + 4 * d * o, v = o) : (r - 3) % 4 == 0 && (f = -o, v = 3 * o + 4 * o * d), l && (f = -f), p || (g = f, f = 0); const w = `rotateX(${p ? 0 : -n}deg) rotateY(${p ? n : 0}deg) translate3d(${f}px, ${g}px, ${v}px)`; m <= 1 && m > -1 && (h = 90 * r + 90 * m, l && (h = 90 * -r - 90 * m), t.browser && t.browser.need3dFix && Math.abs(h) / 90 % 2 == 1 && (h += .001)), s.style.transform = w, c.slideShadows && i(s, m, p) } if (s.style.transformOrigin = `50% 50% -${o / 2}px`, s.style[\"-webkit-transform-origin\"] = `50% 50% -${o / 2}px`, c.shadow) if (p) m.style.transform = `translate3d(0px, ${r / 2 + c.shadowOffset}px, ${-r / 2}px) rotateX(89.99deg) rotateZ(0deg) scale(${c.shadowScale})`; else { const e = Math.abs(h) - 90 * Math.floor(Math.abs(h) / 90), t = 1.5 - (Math.sin(2 * e * Math.PI / 360) / 2 + Math.cos(2 * e * Math.PI / 360) / 2), s = c.shadowScale, a = c.shadowScale / t, i = c.shadowOffset; m.style.transform = `scale3d(${s}, 1, ${a}) translate3d(0px, ${n / 2 + i}px, ${-n / 2 / a}px) rotateX(-89.99deg)` } const f = (d.isSafari || d.isWebView) && d.needPerspectiveFix ? -o / 2 : 0; s.style.transform = `translate3d(0px,0,${f}px) rotateX(${t.isHorizontal() ? 0 : h}deg) rotateY(${t.isHorizontal() ? -h : 0}deg)`, s.style.setProperty(\"--swiper-cube-translate-z\", `${f}px`) }, setTransition: e => { const { el: s, slides: a } = t; if (a.forEach((t => { t.style.transitionDuration = `${e}ms`, t.querySelectorAll(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").forEach((t => { t.style.transitionDuration = `${e}ms` })) })), t.params.cubeEffect.shadow && !t.isHorizontal()) { const t = s.querySelector(\".swiper-cube-shadow\"); t && (t.style.transitionDuration = `${e}ms`) } }, recreateShadows: () => { const e = t.isHorizontal(); t.slides.forEach((t => { const s = Math.max(Math.min(t.progress, 1), -1); i(t, s, e) })) }, getEffectParams: () => t.params.cubeEffect, perspective: () => !0, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, resistanceRatio: 0, spaceBetween: 0, centeredSlides: !1, virtualTranslate: !0 }) }) }, function (e) { let { swiper: t, extendParams: s, on: a } = e; s({ flipEffect: { slideShadows: !0, limitRotation: !0 } }); const i = (e, s) => { let a = t.isHorizontal() ? e.querySelector(\".swiper-slide-shadow-left\") : e.querySelector(\".swiper-slide-shadow-top\"), i = t.isHorizontal() ? e.querySelector(\".swiper-slide-shadow-right\") : e.querySelector(\".swiper-slide-shadow-bottom\"); a || (a = me(\"flip\", e, t.isHorizontal() ? \"left\" : \"top\")), i || (i = me(\"flip\", e, t.isHorizontal() ? \"right\" : \"bottom\")), a && (a.style.opacity = Math.max(-s, 0)), i && (i.style.opacity = Math.max(s, 0)) }; ce({ effect: \"flip\", swiper: t, on: a, setTranslate: () => { const { slides: e, rtlTranslate: s } = t, a = t.params.flipEffect; for (let r = 0; r < e.length; r += 1) { const n = e[r]; let l = n.progress; t.params.flipEffect.limitRotation && (l = Math.max(Math.min(n.progress, 1), -1)); const o = n.swiperSlideOffset; let d = -180 * l, c = 0, p = t.params.cssMode ? -o - t.translate : -o, u = 0; t.isHorizontal() ? s && (d = -d) : (u = p, p = 0, c = -d, d = 0), t.browser && t.browser.need3dFix && (Math.abs(d) / 90 % 2 == 1 && (d += .001), Math.abs(c) / 90 % 2 == 1 && (c += .001)), n.style.zIndex = -Math.abs(Math.round(l)) + e.length, a.slideShadows && i(n, l); const m = `translate3d(${p}px, ${u}px, 0px) rotateX(${c}deg) rotateY(${d}deg)`; pe(0, n).style.transform = m } }, setTransition: e => { const s = t.slides.map((e => h(e))); s.forEach((t => { t.style.transitionDuration = `${e}ms`, t.querySelectorAll(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").forEach((t => { t.style.transitionDuration = `${e}ms` })) })), ue({ swiper: t, duration: e, transformElements: s }) }, recreateShadows: () => { t.params.flipEffect, t.slides.forEach((e => { let s = e.progress; t.params.flipEffect.limitRotation && (s = Math.max(Math.min(e.progress, 1), -1)), i(e, s) })) }, getEffectParams: () => t.params.flipEffect, perspective: () => !0, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !t.params.cssMode }) }) }, function (e) { let { swiper: t, extendParams: s, on: a } = e; s({ coverflowEffect: { rotate: 50, stretch: 0, depth: 100, scale: 1, modifier: 1, slideShadows: !0 } }), ce({ effect: \"coverflow\", swiper: t, on: a, setTranslate: () => { const { width: e, height: s, slides: a, slidesSizesGrid: i } = t, r = t.params.coverflowEffect, n = t.isHorizontal(), l = t.translate, o = n ? e / 2 - l : s / 2 - l, d = n ? r.rotate : -r.rotate, c = r.depth; for (let e = 0, s = a.length; e < s; e += 1) { const s = a[e], l = i[e], p = (o - s.swiperSlideOffset - l / 2) / l, u = \"function\" == typeof r.modifier ? r.modifier(p) : p * r.modifier; let m = n ? d * u : 0, h = n ? 0 : d * u, f = -c * Math.abs(u), g = r.stretch; \"string\" == typeof g && -1 !== g.indexOf(\"%\") && (g = parseFloat(r.stretch) / 100 * l); let v = n ? 0 : g * u, w = n ? g * u : 0, b = 1 - (1 - r.scale) * Math.abs(u); Math.abs(w) < .001 && (w = 0), Math.abs(v) < .001 && (v = 0), Math.abs(f) < .001 && (f = 0), Math.abs(m) < .001 && (m = 0), Math.abs(h) < .001 && (h = 0), Math.abs(b) < .001 && (b = 0), t.browser && t.browser.need3dFix && (Math.abs(m) / 90 % 2 == 1 && (m += .001), Math.abs(h) / 90 % 2 == 1 && (h += .001)); const y = `translate3d(${w}px,${v}px,${f}px)  rotateX(${h}deg) rotateY(${m}deg) scale(${b})`; if (pe(0, s).style.transform = y, s.style.zIndex = 1 - Math.abs(Math.round(u)), r.slideShadows) { let e = n ? s.querySelector(\".swiper-slide-shadow-left\") : s.querySelector(\".swiper-slide-shadow-top\"), t = n ? s.querySelector(\".swiper-slide-shadow-right\") : s.querySelector(\".swiper-slide-shadow-bottom\"); e || (e = me(\"coverflow\", s, n ? \"left\" : \"top\")), t || (t = me(\"coverflow\", s, n ? \"right\" : \"bottom\")), e && (e.style.opacity = u > 0 ? u : 0), t && (t.style.opacity = -u > 0 ? -u : 0) } } }, setTransition: e => { t.slides.map((e => h(e))).forEach((t => { t.style.transitionDuration = `${e}ms`, t.querySelectorAll(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").forEach((t => { t.style.transitionDuration = `${e}ms` })) })) }, perspective: () => !0, overwriteParams: () => ({ watchSlidesProgress: !0 }) }) }, function (e) { let { swiper: t, extendParams: s, on: a } = e; s({ creativeEffect: { limitProgress: 1, shadowPerProgress: !1, progressMultiplier: 1, perspective: !0, prev: { translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1 }, next: { translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1 } } }); const i = e => \"string\" == typeof e ? e : `${e}px`; ce({ effect: \"creative\", swiper: t, on: a, setTranslate: () => { const { slides: e, wrapperEl: s, slidesSizesGrid: a } = t, r = t.params.creativeEffect, { progressMultiplier: n } = r, l = t.params.centeredSlides; if (l) { const e = a[0] / 2 - t.params.slidesOffsetBefore || 0; s.style.transform = `translateX(calc(50% - ${e}px))` } for (let s = 0; s < e.length; s += 1) { const a = e[s], o = a.progress, d = Math.min(Math.max(a.progress, -r.limitProgress), r.limitProgress); let c = d; l || (c = Math.min(Math.max(a.originalProgress, -r.limitProgress), r.limitProgress)); const p = a.swiperSlideOffset, u = [t.params.cssMode ? -p - t.translate : -p, 0, 0], m = [0, 0, 0]; let h = !1; t.isHorizontal() || (u[1] = u[0], u[0] = 0); let f = { translate: [0, 0, 0], rotate: [0, 0, 0], scale: 1, opacity: 1 }; d < 0 ? (f = r.next, h = !0) : d > 0 && (f = r.prev, h = !0), u.forEach(((e, t) => { u[t] = `calc(${e}px + (${i(f.translate[t])} * ${Math.abs(d * n)}))` })), m.forEach(((e, s) => { let a = f.rotate[s] * Math.abs(d * n); t.browser && t.browser.need3dFix && Math.abs(a) / 90 % 2 == 1 && (a += .001), m[s] = a })), a.style.zIndex = -Math.abs(Math.round(o)) + e.length; const g = u.join(\", \"), v = `rotateX(${m[0]}deg) rotateY(${m[1]}deg) rotateZ(${m[2]}deg)`, w = c < 0 ? `scale(${1 + (1 - f.scale) * c * n})` : `scale(${1 - (1 - f.scale) * c * n})`, b = c < 0 ? 1 + (1 - f.opacity) * c * n : 1 - (1 - f.opacity) * c * n, y = `translate3d(${g}) ${v} ${w}`; if (h && f.shadow || !h) { let e = a.querySelector(\".swiper-slide-shadow\"); if (!e && f.shadow && (e = me(\"creative\", a)), e) { const t = r.shadowPerProgress ? d * (1 / r.limitProgress) : d; e.style.opacity = Math.min(Math.max(Math.abs(t), 0), 1) } } const E = pe(0, a); E.style.transform = y, E.style.opacity = b, f.origin && (E.style.transformOrigin = f.origin) } }, setTransition: e => { const s = t.slides.map((e => h(e))); s.forEach((t => { t.style.transitionDuration = `${e}ms`, t.querySelectorAll(\".swiper-slide-shadow\").forEach((t => { t.style.transitionDuration = `${e}ms` })) })), ue({ swiper: t, duration: e, transformElements: s, allSlides: !0 }) }, perspective: () => t.params.creativeEffect.perspective, overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !t.params.cssMode }) }) }, function (e) { let { swiper: t, extendParams: s, on: a } = e; s({ cardsEffect: { slideShadows: !0, rotate: !0, perSlideRotate: 2, perSlideOffset: 8 } }), ce({ effect: \"cards\", swiper: t, on: a, setTranslate: () => { const { slides: e, activeIndex: s, rtlTranslate: a } = t, i = t.params.cardsEffect, { startTranslate: r, isTouched: n } = t.touchEventsData, l = a ? -t.translate : t.translate; for (let o = 0; o < e.length; o += 1) { const d = e[o], c = d.progress, p = Math.min(Math.max(c, -4), 4); let u = d.swiperSlideOffset; t.params.centeredSlides && !t.params.cssMode && (t.wrapperEl.style.transform = `translateX(${t.minTranslate()}px)`), t.params.centeredSlides && t.params.cssMode && (u -= e[0].swiperSlideOffset); let m = t.params.cssMode ? -u - t.translate : -u, h = 0; const f = -100 * Math.abs(p); let g = 1, v = -i.perSlideRotate * p, w = i.perSlideOffset - .75 * Math.abs(p); const b = t.virtual && t.params.virtual.enabled ? t.virtual.from + o : o, y = (b === s || b === s - 1) && p > 0 && p < 1 && (n || t.params.cssMode) && l < r, E = (b === s || b === s + 1) && p < 0 && p > -1 && (n || t.params.cssMode) && l > r; if (y || E) { const e = (1 - Math.abs((Math.abs(p) - .5) / .5)) ** .5; v += -28 * p * e, g += -.5 * e, w += 96 * e, h = -25 * e * Math.abs(p) + \"%\" } if (m = p < 0 ? `calc(${m}px ${a ? \"-\" : \"+\"} (${w * Math.abs(p)}%))` : p > 0 ? `calc(${m}px ${a ? \"-\" : \"+\"} (-${w * Math.abs(p)}%))` : `${m}px`, !t.isHorizontal()) { const e = h; h = m, m = e } const x = p < 0 ? \"\" + (1 + (1 - g) * p) : \"\" + (1 - (1 - g) * p), S = `\\n        translate3d(${m}, ${h}, ${f}px)\\n        rotateZ(${i.rotate ? a ? -v : v : 0}deg)\\n        scale(${x})\\n      `; if (i.slideShadows) { let e = d.querySelector(\".swiper-slide-shadow\"); e || (e = me(\"cards\", d)), e && (e.style.opacity = Math.min(Math.max((Math.abs(p) - .5) / .5, 0), 1)) } d.style.zIndex = -Math.abs(Math.round(c)) + e.length; pe(0, d).style.transform = S } }, setTransition: e => { const s = t.slides.map((e => h(e))); s.forEach((t => { t.style.transitionDuration = `${e}ms`, t.querySelectorAll(\".swiper-slide-shadow\").forEach((t => { t.style.transitionDuration = `${e}ms` })) })), ue({ swiper: t, duration: e, transformElements: s }) }, perspective: () => !0, overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !t.params.cssMode }) }) }]; return se.use(he), se }();\n//# sourceMappingURL=swiper-bundle.min.js.map\n\n// Добавление классов слайдерам\n// swiper главному блоку, swiper-wrapper оболочке, swiper-slide для слайдов\nfunction bildSliders() {\n\tconsole.log(\"свайпер\")\n\t// BildSlider\n\tlet sliders = document.querySelectorAll(`[class*=\"__swiper\"]:not(.swiper-wrapper)`);\n\tif (sliders) {\n\t\tsliders.forEach(slider => {\n\t\t\tslider.parentElement.classList.add(\"swiper\");\n\t\t\tslider.classList.add(\"swiper-wrapper\");\n\t\t\tfor (const slide of slider.children) {\n\t\t\t\tslide.classList.add('swiper-slide')\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Инициализация слайдеров\nfunction initSliders() {\n\t// добавление классов слайдерам\n\t// при необходимости отключить\n\tbildSliders();\n\t// Перечень слайдеров\n\t// Проверяем, есть ли слайдер на стронице\n\tif (document.querySelector('.feedback__slider')) { // Указываем скласс нужного слайдера\n\t\t// Создаем слайдер\n\t\tnew Swiper('.feedback__slider', { // Указываем скласс нужного слайдера\n\t\t\t// Подключаем модули слайдера\n\t\t\t// для конкретного случая\n\t\t\t// modules: [Autoplay, Pagination, Navigation],\n\t\t\tobserver: true,\n\t\t\tobserveParents: true,\n\t\t\tobserveSlideChildren: true,\n\t\t\tslidesPerView: 1,\n\t\t\tspaceBetween: 0,\n\t\t\tautoHeight: true,\n\t\t\tspeed: 800,\n\t\t\tloop: true,\n\t\t\tautoplay: false,\n\n\t\t\t// Эффекты\n\t\t\t// effect: 'fade',\n\t\t\t// autoplay: {\n\t\t\t// \t// delay: 3000,\n\t\t\t// \t// disableOnInteraction: false,\n\t\t\t// },\n\n\n\t\t\t// Пагинация\n\n\t\t\t// pagination: {\n\t\t\t// \tel: '.feedback-swiper__pagination',\n\t\t\t// \tclickable: true,\n\t\t\t// \t// type: \"fraction\",\n\t\t\t// \trenderBullet: function (index, className) {\n\t\t\t// \t\tconst pageIndex = String(index + 1).padStart(2, '0');\n\n\t\t\t// \t\tconsole.log(pageIndex)\n\t\t\t// \t\treturn `<span class=\"${className}\"> ${pageIndex}</span>`;\n\t\t\t// \t},\n\n\t\t\t// },\n\n\t\t\t// Кнопки \"влево/вправо\"\n\t\t\tnavigation: {\n\t\t\t\tprevEl: '.feedback-swiper__navigation .prev',\n\t\t\t\tnextEl: '.feedback-swiper__navigation .next',\n\t\t\t},\n\t\t});\n\t}\n\n\tif (document.querySelector('.projects__slider')) { // Указываем скласс нужного слайдера\n\t\t// Создаем слайдер\n\t\tnew Swiper('.projects__slider', { // Указываем скласс нужного слайдера\n\t\t\t// Подключаем модули слайдера\n\t\t\t// для конкретного случая\n\t\t\t// modules: [Autoplay, Pagination, Navigation],\n\t\t\tobserver: true,\n\t\t\tobserveParents: true,\n\t\t\tobserveSlideChildren: true,\n\t\t\tslidesPerView: 1,\n\t\t\tspaceBetween: 0,\n\t\t\t// autoHeight: true,\n\t\t\tspeed: 800,\n\n\t\t\t//touchRatio: 0,\n\t\t\t//simulateTouch: false,\n\t\t\tloop: true,\n\t\t\t//preloadImages: false,\n\t\t\t//lazy: true,\n\t\t\t// parallax: true,\n\n\n\t\t\t// Эффекты\n\t\t\t// effect: 'fade',\n\t\t\t// autoplay: {\n\t\t\t// \t// delay: 3000,\n\t\t\t// \t// disableOnInteraction: false,\n\t\t\t// },\n\n\t\t\t// Кнопки \"влево/вправо\"\n\t\t\tnavigation: {\n\t\t\t\tprevEl: '.projects-swiper__navigation  .prev',\n\t\t\t\tnextEl: '.projects-swiper__navigation  .next',\n\t\t\t},\n\n\t\t\tpagination: {\n\t\t\t\tel: \".projects-swiper__pagination\",\n\t\t\t\ttype: \"progressbar\",\n\t\t\t\t// clickable: true,\n\t\t\t\t// renderBullet: function (index, className) {\n\t\t\t\t// \tconst pageIndex = String(index + 1).padStart(2, '0');\n\n\t\t\t\t// \tconsole.log(pageIndex)\n\t\t\t\t// \treturn `<span class=\"${className}\"> ${pageIndex}</span>`;\n\t\t\t\t// },\n\t\t\t},\n\n\t\t\t// События\n\t\t\ton: {\n\t\t\t\t// init: function(swiper) {\n\t\t\t\t// \tconst allSlides = document.querySelector(\".fraction-controll__all\");\n\t\t\t\t// \tconst allSlidesItems = document.querySelectorAll(\".slide-main-block:not(.swiper-slide-duplicate)\");\n\n\t\t\t\t// \tallSlides.textContent = allSlidesItems.length < 10 ? `0${allSlidesItems.length}` : allSlidesItems.length;\n\t\t\t\t// },\n\t\t\t\tslideChange: function (swiper) {\n\t\t\t\t\tconst projectsImages = document.querySelectorAll(\"#projectsImages img\")\n\n\t\t\t\t\tif (projectsImages.length) {\n\t\t\t\t\t\tprojectsImages.forEach((img) => {\n\t\t\t\t\t\t\timg.classList.add(\"hidden\")\n\t\t\t\t\t\t})\n\t\t\t\t\t\tconst currentImageIndex = swiper.realIndex\n\t\t\t\t\t\tdocument.querySelector(`img[data-image='${currentImageIndex}']`).classList.remove(\"hidden\")\n\t\t\t\t\t}\n\t\t\t\t\t// const currentSlide = document.querySelector(\".fraction-controll__current\");\n\t\t\t\t\t// currentSlide.textContent = (swiper.realIndex + 1) < 10 ? `0${swiper.realIndex + 1}` : swiper.realIndex + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tif (document.querySelector('.simple__slider')) { // Указываем скласс нужного слайдера\n\t\t// Создаем слайдер\n\t\tnew Swiper('.simple__slider', { // Указываем скласс нужного слайдера\n\t\t\t// Подключаем модули слайдера\n\t\t\t// для конкретного случая\n\t\t\t// modules: [Autoplay, Pagination, Navigation],\n\t\t\tobserver: true,\n\t\t\tobserveParents: true,\n\t\t\tobserveSlideChildren: true,\n\t\t\tslidesPerView: 3,\n\t\t\tspaceBetween: 40,\n\t\t\t// autoHeight: true,\n\t\t\tspeed: 800,\n\t\t\tloop: true,\n\n\n\n\t\t\t// Эффекты\n\t\t\t// effect: 'fade',\n\t\t\tautoplay: {\n\t\t\t\tdelay: 30000,\n\t\t\t\t// disableOnInteraction: false,\n\t\t\t},\n\n\t\t\t// Кнопки \"влево/вправо\"\n\t\t\tnavigation: {\n\t\t\t\tprevEl: '.delivery-swiper__navigation .prev',\n\t\t\t\tnextEl: '.delivery-swiper__navigation .next',\n\t\t\t},\n\n\t\t\t// Брейкпоинты\n\n\t\t\tbreakpoints: {\n\t\t\t\t320: {\n\t\t\t\t\tslidesPerView: 1,\n\t\t\t\t\tspaceBetween: 10,\n\t\t\t\t\t// autoHeight: true,\n\t\t\t\t},\n\t\t\t\t576: {\n\t\t\t\t\tslidesPerView: 1,\n\t\t\t\t\tspaceBetween: 10,\n\t\t\t\t\t// autoHeight: true,\n\t\t\t\t},\n\t\t\t\t768: {\n\t\t\t\t\tslidesPerView: 2,\n\t\t\t\t\tspaceBetween: 20,\n\t\t\t\t},\n\t\t\t\t992: {\n\t\t\t\t\tslidesPerView: 3,\n\t\t\t\t\tspaceBetween: 20,\n\t\t\t\t},\n\t\t\t\t1268: {\n\t\t\t\t\tslidesPerView: 3,\n\t\t\t\t\tspaceBetween: 20,\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t}\n\n\tif (document.querySelector('.grid-recomendation__slider')) { // Указываем скласс нужного слайдера\n\t\t// Создаем слайдер\n\t\tnew Swiper('.grid-recomendation__slider', { // Указываем скласс нужного слайдера\n\t\t\t// Подключаем модули слайдера\n\t\t\t// для конкретного случая\n\t\t\t// modules: [Autoplay, Pagination, Navigation],\n\t\t\tobserver: true,\n\t\t\tobserveParents: true,\n\t\t\tobserveSlideChildren: true,\n\t\t\tslidesPerView: 3,\n\t\t\tspaceBetween: 65,\n\t\t\t// autoHeight: true,\n\t\t\tspeed: 800,\n\t\t\tloop: true,\n\n\n\n\t\t\t// Эффекты\n\t\t\t// effect: 'fade',\n\t\t\tautoplay: {\n\t\t\t\tdelay: 30000,\n\t\t\t\t// disableOnInteraction: false,\n\t\t\t},\n\n\t\t\t// Кнопки \"влево/вправо\"\n\t\t\tnavigation: {\n\t\t\t\tprevEl: '.grid-recomendation__navigation .prev',\n\t\t\t\tnextEl: '.grid-recomendation__navigation .next',\n\t\t\t},\n\n\t\t\t// Брейкпоинты\n\n\t\t\tbreakpoints: {\n\t\t\t\t320: {\n\t\t\t\t\tslidesPerView: 1,\n\t\t\t\t\tspaceBetween: 10,\n\t\t\t\t\t// autoHeight: true,\n\t\t\t\t},\n\t\t\t\t576: {\n\t\t\t\t\tslidesPerView: 1,\n\t\t\t\t\tspaceBetween: 10,\n\t\t\t\t\t// autoHeight: true,\n\t\t\t\t},\n\t\t\t\t768: {\n\t\t\t\t\tslidesPerView: 2,\n\t\t\t\t\tspaceBetween: 18,\n\t\t\t\t},\n\t\t\t\t992: {\n\t\t\t\t\tslidesPerView: 2,\n\t\t\t\t\tspaceBetween: 40,\n\t\t\t\t},\n\t\t\t\t1268: {\n\t\t\t\t\tslidesPerView: 2,\n\t\t\t\t\tspaceBetween: 65,\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t}\n}\n// Скролл на базе слайдера (по классу swiper_scroll для оболочки слайдера)\n\n\nwindow.addEventListener(\"load\", function (e) {\n\t// Запуск инициализации слайдеров\n\tinitSliders();\n\t// Запуск инициализации скролла на базе слайдера (по классу swiper_scroll)\n\t//initSlidersScroll();\n});\n\n//# sourceURL=webpack://gulp-2022/./src/js/files/sliders.js?");

/***/ }),

/***/ "./src/js/libs/dynamic_adapt.js":
/*!**************************************!*\
  !*** ./src/js/libs/dynamic_adapt.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// Dynamic Adapt v.1\n// HTML data-da=\"where(uniq class name),when(breakpoint),position(digi)\"\n// e.x. data-da=\".item,992,2\"\n// Andrikanych Yevhen 2020\n// https://www.youtube.com/c/freelancerlifestyle\n\n\nfunction DynamicAdapt(type) {\n\tthis.type = type;\n}\nDynamicAdapt.prototype.init = function () {\n\tconst _this = this;\n\t// массив объектов\n\tthis.оbjects = [];\n\tthis.daClassname = \"_dynamic_adapt_\";\n\t// массив DOM-элементов\n\tthis.nodes = document.querySelectorAll(\"[data-da]\");\n\t// наполнение оbjects объктами\n\tfor (let i = 0; i < this.nodes.length; i++) {\n\t\tconst node = this.nodes[i];\n\t\tconst data = node.dataset.da.trim();\n\t\tconst dataArray = data.split(\",\");\n\t\tconst оbject = {};\n\t\tоbject.element = node;\n\t\tоbject.parent = node.parentNode;\n\t\tоbject.destination = document.querySelector(dataArray[0].trim());\n\t\tоbject.breakpoint = dataArray[1] ? dataArray[1].trim() : \"767\";\n\t\tоbject.place = dataArray[2] ? dataArray[2].trim() : \"last\";\n\t\tоbject.index = this.indexInParent(оbject.parent, оbject.element);\n\t\tthis.оbjects.push(оbject);\n\t}\n\tthis.arraySort(this.оbjects);\n\t// массив уникальных медиа-запросов\n\tthis.mediaQueries = Array.prototype.map.call(this.оbjects, function (item) {\n\t\treturn '(' + this.type + \"-width: \" + item.breakpoint + \"px),\" + item.breakpoint;\n\t}, this);\n\tthis.mediaQueries = Array.prototype.filter.call(this.mediaQueries, function (item, index, self) {\n\t\treturn Array.prototype.indexOf.call(self, item) === index;\n\t});\n\t// навешивание слушателя на медиа-запрос\n\t// и вызов обработчика при первом запуске\n\tfor (let i = 0; i < this.mediaQueries.length; i++) {\n\t\tconst media = this.mediaQueries[i];\n\t\tconst mediaSplit = String.prototype.split.call(media, ',');\n\t\tconst matchMedia = window.matchMedia(mediaSplit[0]);\n\t\tconst mediaBreakpoint = mediaSplit[1];\n\t\t// массив объектов с подходящим брейкпоинтом\n\t\tconst оbjectsFilter = Array.prototype.filter.call(this.оbjects, function (item) {\n\t\t\treturn item.breakpoint === mediaBreakpoint;\n\t\t});\n\t\tmatchMedia.addListener(function () {\n\t\t\t_this.mediaHandler(matchMedia, оbjectsFilter);\n\t\t});\n\t\tthis.mediaHandler(matchMedia, оbjectsFilter);\n\t}\n};\nDynamicAdapt.prototype.mediaHandler = function (matchMedia, оbjects) {\n\tif (matchMedia.matches) {\n\t\tfor (let i = 0; i < оbjects.length; i++) {\n\t\t\tconst оbject = оbjects[i];\n\t\t\tоbject.index = this.indexInParent(оbject.parent, оbject.element);\n\t\t\tthis.moveTo(оbject.place, оbject.element, оbject.destination);\n\t\t}\n\t} else {\n\t\t//for (let i = 0; i < оbjects.length; i++) {\n\t\tfor (let i = оbjects.length - 1; i >= 0; i--) {\n\t\t\tconst оbject = оbjects[i];\n\t\t\tif (оbject.element.classList.contains(this.daClassname)) {\n\t\t\t\tthis.moveBack(оbject.parent, оbject.element, оbject.index);\n\t\t\t}\n\t\t}\n\t}\n};\n// Функция перемещения\nDynamicAdapt.prototype.moveTo = function (place, element, destination) {\n\telement.classList.add(this.daClassname);\n\tif (place === 'last' || place >= destination.children.length) {\n\t\tdestination.insertAdjacentElement('beforeend', element);\n\t\treturn;\n\t}\n\tif (place === 'first') {\n\t\tdestination.insertAdjacentElement('afterbegin', element);\n\t\treturn;\n\t}\n\tdestination.children[place].insertAdjacentElement('beforebegin', element);\n}\n// Функция возврата\nDynamicAdapt.prototype.moveBack = function (parent, element, index) {\n\telement.classList.remove(this.daClassname);\n\tif (parent.children[index] !== undefined) {\n\t\tparent.children[index].insertAdjacentElement('beforebegin', element);\n\t} else {\n\t\tparent.insertAdjacentElement('beforeend', element);\n\t}\n}\n// Функция получения индекса внутри родителя\nDynamicAdapt.prototype.indexInParent = function (parent, element) {\n\tconst array = Array.prototype.slice.call(parent.children);\n\treturn Array.prototype.indexOf.call(array, element);\n};\n// Функция сортировки массива по breakpoint и place \n// по возрастанию для this.type = min\n// по убыванию для this.type = max\nDynamicAdapt.prototype.arraySort = function (arr) {\n\tif (this.type === \"min\") {\n\t\tArray.prototype.sort.call(arr, function (a, b) {\n\t\t\tif (a.breakpoint === b.breakpoint) {\n\t\t\t\tif (a.place === b.place) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tif (a.place === \"first\" || b.place === \"last\") {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (a.place === \"last\" || b.place === \"first\") {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\treturn a.place - b.place;\n\t\t\t}\n\n\t\t\treturn a.breakpoint - b.breakpoint;\n\t\t});\n\t} else {\n\t\tArray.prototype.sort.call(arr, function (a, b) {\n\t\t\tif (a.breakpoint === b.breakpoint) {\n\t\t\t\tif (a.place === b.place) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tif (a.place === \"first\" || b.place === \"last\") {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\tif (a.place === \"last\" || b.place === \"first\") {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\treturn b.place - a.place;\n\t\t\t}\n\n\t\t\treturn b.breakpoint - a.breakpoint;\n\t\t});\n\t\treturn;\n\t}\n};\nconst da = new DynamicAdapt(\"max\");\nda.init();\n\n//# sourceURL=webpack://gulp-2022/./src/js/libs/dynamic_adapt.js?");

/***/ }),

/***/ "./src/js/libs/popup.js":
/*!******************************!*\
  !*** ./src/js/libs/popup.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _files_functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../files/functions.js */ \"./src/js/files/functions.js\");\n/* harmony import */ var _files_modules_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../files/modules.js */ \"./src/js/files/modules.js\");\n// Модуль попапов\n// (c) Фрилансер по жизни, Хмурый Кот\n// Документация по работе в шаблоне: https://template.fls.guru/template-docs/funkcional-popup.html\n// Сниппет (HTML): pl\n\n// Подключение функционала \"Чертогов Фрилансера\"\n\n\n\n// Класс Popup\nclass Popup {\n\tconstructor(options) {\n\t\tlet config = {\n\t\t\tlogging: true,\n\t\t\tinit: true,\n\t\t\t// Для кнопок \n\t\t\tattributeOpenButton: 'data-popup', // Атрибут для кнопки, которая вызывает попап\n\t\t\tattributeCloseButton: 'data-close', // Атрибут для кнопки, которая закрывает попап\n\t\t\t// Для сторонних объектов\n\t\t\tfixElementSelector: '[data-lp]', // Атрибут для элементов с левым паддингом (которые fixed)\n\t\t\t// Для объекта попапа\n\t\t\tyoutubeAttribute: 'data-popup-youtube', // Атрибут для кода youtube\n\t\t\tyoutubePlaceAttribute: 'data-popup-youtube-place', // Атрибут для вставки ролика youtube\n\t\t\tsetAutoplayYoutube: true,\n\t\t\t// Изменение классов\n\t\t\tclasses: {\n\t\t\t\tpopup: 'popup',\n\t\t\t\t// popupWrapper: 'popup__wrapper',\n\t\t\t\tpopupContent: 'popup__content',\n\t\t\t\tpopupActive: 'popup_show', // Добавляется для попапа, когда он открывается\n\t\t\t\tbodyActive: 'popup-show', // Добавляется для боди, когда попап открыт\n\t\t\t},\n\t\t\tfocusCatch: true, // Фокус внутри попапа зациклен\n\t\t\tcloseEsc: true, // Закрытие по ESC\n\t\t\tbodyLock: true, // Блокировка скролла\n\t\t\thashSettings: {\n\t\t\t\tlocation: true, // Хэш в адресной строке\n\t\t\t\tgoHash: true, // Переход по наличию в адресной строке\n\t\t\t},\n\t\t\ton: { // События\n\t\t\t\tbeforeOpen: function () { },\n\t\t\t\tafterOpen: function () { },\n\t\t\t\tbeforeClose: function () { },\n\t\t\t\tafterClose: function () { },\n\t\t\t},\n\t\t}\n\t\tthis.youTubeCode;\n\t\tthis.isOpen = false;\n\t\t// Текущее окно\n\t\tthis.targetOpen = {\n\t\t\tselector: false,\n\t\t\telement: false,\n\t\t}\n\t\t// Предыдущее открытое\n\t\tthis.previousOpen = {\n\t\t\tselector: false,\n\t\t\telement: false,\n\t\t}\n\t\t// Последнее закрытое\n\t\tthis.lastClosed = {\n\t\t\tselector: false,\n\t\t\telement: false,\n\t\t}\n\t\tthis._dataValue = false;\n\t\tthis.hash = false;\n\n\t\tthis._reopen = false;\n\t\tthis._selectorOpen = false;\n\n\t\tthis.lastFocusEl = false;\n\t\tthis._focusEl = [\n\t\t\t'a[href]',\n\t\t\t'input:not([disabled]):not([type=\"hidden\"]):not([aria-hidden])',\n\t\t\t'button:not([disabled]):not([aria-hidden])',\n\t\t\t'select:not([disabled]):not([aria-hidden])',\n\t\t\t'textarea:not([disabled]):not([aria-hidden])',\n\t\t\t'area[href]',\n\t\t\t'iframe',\n\t\t\t'object',\n\t\t\t'embed',\n\t\t\t'[contenteditable]',\n\t\t\t'[tabindex]:not([tabindex^=\"-\"])'\n\t\t];\n\t\t//this.options = Object.assign(config, options);\n\t\tthis.options = {\n\t\t\t...config,\n\t\t\t...options,\n\t\t\tclasses: {\n\t\t\t\t...config.classes,\n\t\t\t\t...options?.classes,\n\t\t\t},\n\t\t\thashSettings: {\n\t\t\t\t...config.hashSettings,\n\t\t\t\t...options?.hashSettings,\n\t\t\t},\n\t\t\ton: {\n\t\t\t\t...config.on,\n\t\t\t\t...options?.on,\n\t\t\t}\n\t\t}\n\t\tthis.bodyLock = false;\n\t\tthis.options.init ? this.initPopups() : null\n\t}\n\tinitPopups() {\n\t\tthis.popupLogging(`Проснулся`);\n\t\tthis.eventsPopup();\n\t}\n\teventsPopup() {\n\t\t// Клик на всем документе\n\t\tdocument.addEventListener(\"click\", function (e) {\n\t\t\t// Клик по кнопке \"открыть\"\n\t\t\tconst buttonOpen = e.target.closest(`[${this.options.attributeOpenButton}]`);\n\t\t\tif (buttonOpen) {\n\t\t\t\te.preventDefault();\n\t\t\t\tthis._dataValue = buttonOpen.getAttribute(this.options.attributeOpenButton) ?\n\t\t\t\t\tbuttonOpen.getAttribute(this.options.attributeOpenButton) :\n\t\t\t\t\t'error';\n\t\t\t\tthis.youTubeCode = buttonOpen.getAttribute(this.options.youtubeAttribute) ?\n\t\t\t\t\tbuttonOpen.getAttribute(this.options.youtubeAttribute) :\n\t\t\t\t\tnull;\n\t\t\t\tif (this._dataValue !== 'error') {\n\t\t\t\t\tif (!this.isOpen) this.lastFocusEl = buttonOpen;\n\t\t\t\t\tthis.targetOpen.selector = `${this._dataValue}`;\n\t\t\t\t\tthis._selectorOpen = true;\n\t\t\t\t\tthis.open();\n\t\t\t\t\treturn;\n\n\t\t\t\t} else this.popupLogging(`Ой ой, не заполнен атрибут у ${buttonOpen.classList}`);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Закрытие на пустом месте (popup__wrapper) и кнопки закрытия (popup__close) для закрытия\n\t\t\tconst buttonClose = e.target.closest(`[${this.options.attributeCloseButton}]`);\n\t\t\tif (buttonClose || !e.target.closest(`.${this.options.classes.popupContent}`) && this.isOpen) {\n\t\t\t\te.preventDefault();\n\t\t\t\tthis.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}.bind(this));\n\t\t// Закрытие по ESC\n\t\tdocument.addEventListener(\"keydown\", function (e) {\n\t\t\tif (this.options.closeEsc && e.which == 27 && e.code === 'Escape' && this.isOpen) {\n\t\t\t\te.preventDefault();\n\t\t\t\tthis.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.options.focusCatch && e.which == 9 && this.isOpen) {\n\t\t\t\tthis._focusCatch(e);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}.bind(this))\n\n\t\t// Открытие по хешу\n\t\tif (this.options.hashSettings.goHash) {\n\t\t\t// Проверка изменения адресной строки\n\t\t\twindow.addEventListener('hashchange', function () {\n\t\t\t\tif (window.location.hash) {\n\t\t\t\t\tthis._openToHash();\n\t\t\t\t} else {\n\t\t\t\t\tthis.close(this.targetOpen.selector);\n\t\t\t\t}\n\t\t\t}.bind(this))\n\n\t\t\twindow.addEventListener('load', function () {\n\t\t\t\tif (window.location.hash) {\n\t\t\t\t\tthis._openToHash();\n\t\t\t\t}\n\t\t\t}.bind(this))\n\t\t}\n\t}\n\topen(selectorValue) {\n\t\tif (_files_functions_js__WEBPACK_IMPORTED_MODULE_0__.bodyLockStatus) {\n\t\t\t// Если перед открытием попапа был режим lock\n\t\t\tthis.bodyLock = document.documentElement.classList.contains('lock') && !this.isOpen ? true : false;\n\n\t\t\t// Если ввести значение селектора (селектор настраивается в options)\n\t\t\tif (selectorValue && typeof (selectorValue) === \"string\" && selectorValue.trim() !== \"\") {\n\t\t\t\tthis.targetOpen.selector = selectorValue;\n\t\t\t\tthis._selectorOpen = true;\n\t\t\t}\n\t\t\tif (this.isOpen) {\n\t\t\t\tthis._reopen = true;\n\t\t\t\tthis.close();\n\t\t\t}\n\t\t\tif (!this._selectorOpen) this.targetOpen.selector = this.lastClosed.selector;\n\t\t\tif (!this._reopen) this.previousActiveElement = document.activeElement;\n\n\t\t\tthis.targetOpen.element = document.querySelector(this.targetOpen.selector);\n\n\t\t\tif (this.targetOpen.element) {\n\t\t\t\t// YouTube\n\t\t\t\tif (this.youTubeCode) {\n\t\t\t\t\tconst codeVideo = this.youTubeCode;\n\t\t\t\t\tconst urlVideo = `https://www.youtube.com/embed/${codeVideo}?rel=0&showinfo=0&autoplay=1`\n\t\t\t\t\tconst iframe = document.createElement('iframe');\n\t\t\t\t\tiframe.setAttribute('allowfullscreen', '');\n\n\t\t\t\t\tconst autoplay = this.options.setAutoplayYoutube ? 'autoplay;' : '';\n\t\t\t\t\tiframe.setAttribute('allow', `${autoplay}; encrypted-media`);\n\n\t\t\t\t\tiframe.setAttribute('src', urlVideo);\n\n\t\t\t\t\tif (!this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`)) {\n\t\t\t\t\t\tconst youtubePlace = this.targetOpen.element.querySelector('.popup__text').setAttribute(`${this.options.youtubePlaceAttribute}`, '');\n\t\t\t\t\t}\n\t\t\t\t\tthis.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`).appendChild(iframe);\n\t\t\t\t}\n\t\t\t\tif (this.options.hashSettings.location) {\n\t\t\t\t\t// Получение хэша и его выставление \n\t\t\t\t\tthis._getHash();\n\t\t\t\t\tthis._setHash();\n\t\t\t\t}\n\n\t\t\t\t// До открытия\n\t\t\t\tthis.options.on.beforeOpen(this);\n\t\t\t\t// Создаем свое событие после открытия попапа\n\t\t\t\tdocument.dispatchEvent(new CustomEvent(\"beforePopupOpen\", {\n\t\t\t\t\tdetail: {\n\t\t\t\t\t\tpopup: this\n\t\t\t\t\t}\n\t\t\t\t}));\n\n\t\t\t\tthis.targetOpen.element.classList.add(this.options.classes.popupActive);\n\t\t\t\tdocument.documentElement.classList.add(this.options.classes.bodyActive);\n\n\t\t\t\tif (!this._reopen) {\n\t\t\t\t\t!this.bodyLock ? (0,_files_functions_js__WEBPACK_IMPORTED_MODULE_0__.bodyLock)() : null;\n\t\t\t\t}\n\t\t\t\telse this._reopen = false;\n\n\t\t\t\tthis.targetOpen.element.setAttribute('aria-hidden', 'false');\n\n\t\t\t\t// Запоминаю это открытое окно. Оно будет последним открытым\n\t\t\t\tthis.previousOpen.selector = this.targetOpen.selector;\n\t\t\t\tthis.previousOpen.element = this.targetOpen.element;\n\n\t\t\t\tthis._selectorOpen = false;\n\n\t\t\t\tthis.isOpen = true;\n\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tthis._focusTrap();\n\t\t\t\t}, 50);\n\n\t\t\t\t// После открытия\n\t\t\t\tthis.options.on.afterOpen(this);\n\t\t\t\t// Создаем свое событие после открытия попапа\n\t\t\t\tdocument.dispatchEvent(new CustomEvent(\"afterPopupOpen\", {\n\t\t\t\t\tdetail: {\n\t\t\t\t\t\tpopup: this\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t\tthis.popupLogging(`Открыл попап`);\n\n\t\t\t} else this.popupLogging(`Ой ой, такого попапа нет.Проверьте корректность ввода. `);\n\t\t}\n\t}\n\tclose(selectorValue) {\n\t\tif (selectorValue && typeof (selectorValue) === \"string\" && selectorValue.trim() !== \"\") {\n\t\t\tthis.previousOpen.selector = selectorValue;\n\t\t}\n\t\tif (!this.isOpen || !_files_functions_js__WEBPACK_IMPORTED_MODULE_0__.bodyLockStatus) {\n\t\t\treturn;\n\t\t}\n\t\t// До закрытия\n\t\tthis.options.on.beforeClose(this);\n\t\t// Создаем свое событие перед закрытием попапа\n\t\tdocument.dispatchEvent(new CustomEvent(\"beforePopupClose\", {\n\t\t\tdetail: {\n\t\t\t\tpopup: this\n\t\t\t}\n\t\t}));\n\n\t\t// YouTube\n\t\tif (this.youTubeCode) {\n\t\t\tif (this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`))\n\t\t\t\tthis.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`).innerHTML = '';\n\t\t}\n\t\tthis.previousOpen.element.classList.remove(this.options.classes.popupActive);\n\t\t// aria-hidden\n\t\tthis.previousOpen.element.setAttribute('aria-hidden', 'true');\n\t\tif (!this._reopen) {\n\t\t\tdocument.documentElement.classList.remove(this.options.classes.bodyActive);\n\t\t\t!this.bodyLock ? (0,_files_functions_js__WEBPACK_IMPORTED_MODULE_0__.bodyUnlock)() : null;\n\t\t\tthis.isOpen = false;\n\t\t}\n\t\t// Очищение адресной строки\n\t\tthis._removeHash();\n\t\tif (this._selectorOpen) {\n\t\t\tthis.lastClosed.selector = this.previousOpen.selector;\n\t\t\tthis.lastClosed.element = this.previousOpen.element;\n\n\t\t}\n\t\t// После закрытия\n\t\tthis.options.on.afterClose(this);\n\t\t// Создаем свое событие после закрытия попапа\n\t\tdocument.dispatchEvent(new CustomEvent(\"afterPopupClose\", {\n\t\t\tdetail: {\n\t\t\t\tpopup: this\n\t\t\t}\n\t\t}));\n\n\t\tsetTimeout(() => {\n\t\t\tthis._focusTrap();\n\t\t}, 50);\n\n\t\tthis.popupLogging(`Закрыл попап`);\n\t}\n\t// Получение хэша \n\t_getHash() {\n\t\tif (this.options.hashSettings.location) {\n\t\t\tthis.hash = this.targetOpen.selector.includes('#') ?\n\t\t\t\tthis.targetOpen.selector : this.targetOpen.selector.replace('.', '#')\n\t\t}\n\t}\n\t_openToHash() {\n\t\tlet classInHash = document.querySelector(`.${window.location.hash.replace('#', '')}`) ? `.${window.location.hash.replace('#', '')}` :\n\t\t\tdocument.querySelector(`${window.location.hash}`) ? `${window.location.hash}` :\n\t\t\t\tnull;\n\n\t\tconst buttons = document.querySelector(`[${this.options.attributeOpenButton} = \"${classInHash}\"]`) ? document.querySelector(`[${this.options.attributeOpenButton} = \"${classInHash}\"]`) : document.querySelector(`[${this.options.attributeOpenButton} = \"${classInHash.replace('.', \"#\")}\"]`);\n\t\tif (buttons && classInHash) this.open(classInHash);\n\t}\n\t// Утсановка хэша\n\t_setHash() {\n\t\thistory.pushState('', '', this.hash);\n\t}\n\t_removeHash() {\n\t\thistory.pushState('', '', window.location.href.split('#')[0])\n\t}\n\t_focusCatch(e) {\n\t\tconst focusable = this.targetOpen.element.querySelectorAll(this._focusEl);\n\t\tconst focusArray = Array.prototype.slice.call(focusable);\n\t\tconst focusedIndex = focusArray.indexOf(document.activeElement);\n\n\t\tif (e.shiftKey && focusedIndex === 0) {\n\t\t\tfocusArray[focusArray.length - 1].focus();\n\t\t\te.preventDefault();\n\t\t}\n\t\tif (!e.shiftKey && focusedIndex === focusArray.length - 1) {\n\t\t\tfocusArray[0].focus();\n\t\t\te.preventDefault();\n\t\t}\n\t}\n\t_focusTrap() {\n\t\tconst focusable = this.previousOpen.element.querySelectorAll(this._focusEl);\n\t\tif (!this.isOpen && this.lastFocusEl) {\n\t\t\tthis.lastFocusEl.focus();\n\t\t} else {\n\t\t\tfocusable[0].focus();\n\t\t}\n\t}\n\t// Функция вывода в консоль\n\tpopupLogging(message) {\n\t\tthis.options.logging ? (0,_files_functions_js__WEBPACK_IMPORTED_MODULE_0__.FLS)(`[Попапос]: ${message}`) : null;\n\t}\n}\n// Запускаем и добавляем в объект модулей\n_files_modules_js__WEBPACK_IMPORTED_MODULE_1__.flsModules.popup = new Popup({});\n\n//# sourceURL=webpack://gulp-2022/./src/js/libs/popup.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/app.js");
/******/ 	
/******/ })()
;